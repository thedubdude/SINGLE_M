/*
 modified: 5/16/24
 Name:		SINGLE_M.ino
 Created:	3/18/2024 2:41:31 PM
 Author:	Don Wile
*/

/*
 Name:		previously named:   LED_4PANEL_ESP_TEXT.ino
 Created:	1/17/2020 3:30:15 PM
 Author:	Don Wile


 Modified to work with Visual Studio 2022


11/15/23
In this revision:
1. I added PROXIMITY detector
2. I added HEAD COM indicator to GUI

 migrated to MASTER_ESP32 naming on: 9/13/20

 COM M1=5, for M2=3 , M3=8

 SINGLE program version

 FFT stuff adapted from: https://github.com/s-marley/ESP32_FFT_VU
						 https://github.com/G6EJD/ESP32-8266-Audio-Spectrum-Display/blob/master/ESP32_Spectrum_Display_02.ino
 and YouTube Video:  https://www.youtube.com/watch?v=Mgh2WblO5_c&t=627s

 //////////////// new in this version  ///////////////
1.Added FLASH_DRAW_CYLIN_CORDINATES function and tests 43, 44

*/



#include "FastLED.h"
#include "BluetoothSerial.h"

#include "C:\Users\Don Wile\Documents\Arduino\IMAGES_and_FONTS\font_TEXT.h"
#include "C:\Users\Don Wile\Documents\Arduino\IMAGES_and_FONTS\image_TEXT.h"

// Define the print function as a macro
#define pprint(text, variable) \
    do { \
        Serial.print(F(text)); \
        Serial.println(variable); \
    } while (0)

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

BluetoothSerial SerialBT;

//#include "SPI.h"
//#include "C:\Users\Don Wile\Documents\Arduino\Dons Code\LED project\BitMap_TEXT\Included FONT\TEXT.h"
//#include "C:\Users\Don Wile\Documents\Arduino\Dons Code\LED project\TEXT_BitMaps\bmp_array.h"

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^  SWITCHES  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
byte G_MURG = 3; //values: 1 or 2  or 3:  set Murgetroid being programmed...needed to keep BlueTooth names seperate: 
// 1=newest head (spinning processor); 2=first head (spinning processor); ;   3=TEST BASE stationary processor
// previously 2

byte G_Hall_sync = 0;  // set to 0 to prevent Hall syncing...useful for Test purpose, set to 1 for Hall syncing
byte SERIAL_MON = 1;   // set to 1 for serial monitor...  will cause streaking if enabled, 2=FFT serial monitor
byte G_TEST = 0; //13, set to TEST number to execute...if >0 , calls DO_TEST() vs. PRODUCTION#  t56
byte G_skip_SCROLL_TEXT = 0;  // set to 1 to skip SCROLL_TEXT commands
int G_forced_show = 0;  //19 if set to >0 then the SHOW_HANDLER will only play the show number given by G_forced_show...usful for creating new shows: NEGATIVE numbers will allow show to continue after the forced show
byte G_forced_production = 0; //2 if set to >0 then the PRODUCTION_HANDLER will only play the PRODUCTION given by G_forced_production...usful for creating new PRODUCTIONS, negative number not allowed
#define DEFAULT_PRODUCTION 1 // specify which PRODUCTION starts: 1=original, 2=cylindrical coordinates, 3=FFT show, 4=beat detector 
int G_force_sound_productions = 0;  // set to 1 to force PRODUCTIONS that utilize SOUND, set to -1 to exclude SOUND productions, set to 0 to let SOUND trigger SOUND productions
int G_FORCE_HEAD_COM = 0;  //-1  ** For TESTING only: set to 1 to force HEAD COM signal HIGH, set to -1 to make sure it never goes HIGH, 0=normal operation

byte G_GUI = 3;  // sets which GUI is being used   ... default is GUI3
byte DC_ON = 0; // set to 1 to turn on DON COM
byte G_enable_GUI_generator = 0;  // 1=generte GUI when BT connected; 0=don't generate GUI



//int FAST = 0;  // set to 1 to show only 22 LEDs, FAST=0 for 242 LEDs
//int SYNC_IT = 0; // set to 1 for Hall effect sensor syncing
int ADD_DELAY = 1; // set to 1 to add delay between frames


int G_depth = 1; // set to 2 for TEXT to have 2 row depth (NUM_LEDS_FAST=44), otherwise set to 1 (NUM_LEDS_FAST=22)

int G_HI_Z = 0; // set to 1 to high impedance the LED DATA outputs 

int G_text2 = 1;  // set to 1 to enable panels 3,4 display of text and graphics
byte G_BT_enable = 1;  // set to 1 to enable Blue Tooth 

byte G_uppercase = 1;  // set to 1 to convert lower case to upper case

byte G_AUTO_DIM = 1;  // set to 1 for auto dimming of SLOW leds during SCROLL_TEXT

#define CALIBRATION_INTERVAL 8000  //8 second delay during power up, was 8000
#define CREATE_MODE_DEFAULT_IMAGE  17  // sets which image to load when entering CREATE MODE...NOTE: this is not presently used

#define DEFAULT_BRIGTHNESS 220  // higher number is dimmer, max = 255...was 200			
#define SCROLL_TEXT_INCREASED_BRIGTNESS_FACTOR .7   // this factor multiplies G_dim in DISPLAY_TEXT to make TEXT brighter

#define MAXIMUM_IDLE_CREATE_MODE_TIME 180000  // 5 minutes expressed in mills...sets how long you can idle in CREATE mode if PLAY SAVES isn't active: was 180000 = 3min
#define PLAY_SAVES_SHOW_REPEATS 10  // number of times the PLAY_SAVES_SHOW() plays when the GUI "PLAY SAVES" switch is turned on before a RESET() occurs to force a restart of DO_SHOW()

#define DIMMING_INNER 253  // dimming of the inner image, used in PRODUCTION #2
#define DIMMING_MAX_BRIGHTNESS 200  // maximum brightness of outter image, the larger the number the less bright, used in PRODUCTION #2 

#define SOUND_DETECT_THRESHOLD 10  // above this value a sound has been detected
#define NOTE_DETECT_THRESHOLD 80  // this is a percentage used to multiply the maximum MNOTE correlation to determine a threshold for detecting a MNOTE
#define FIRST_SOUND_PRODUCTION 3 // start of first sound production
#define LAST_SOUND_PRODUCTION 5  // last production that utilizes sound
#define MUSIC_DETECTION_INTERVAL 1500  // the presence of MUSIC is determined over this time 
#define MUSIC_DETECTION_COUNT 3 // number of sounds needed to be detected in the MUSIC_DETECTION_INTERVAL
#define NO_MUSIC_TIME 90000 // in ms: sets how long a silence before exiting SOUND shows, was 90000=1.5min

// below is used with TWEEN() 
#define ERASE_IMAGE 999 
#define BLEND_START_END_HUE 1000
#define STARTING_IMAGE_HUE 2000
#define ENDING_IMAGE_HUE 3000

#define RANDOM_IMAGE_KIND 100  // signal to generate a random image KIND for BEAT_SHOW_RAND
#define BEAT_DETECT_THRESHOLD 200  // 200 was determined by turning off sound and looking at the adjusted peak threshold
#define SPACE Serial.println("");  // generate a blank line
#define printD printF(F  // used for printF function

///  ***** FOR TEST ONLY  ***********

#define FORCE_HEAD_COM_HIGH_DURATION 60000  //** For TESTING only: time in ms that FORCE_HEAD_COM=1 will be asserted
//#define FORCE_HEAD_COM_LOW_DURATION 10000  // ** For TESTING only: time in ms that FORCE_HEAD_COM=0 will be asserted
unsigned long head_com_duration_start_time;  // ** For TESTING only: used to determine how long head com has been forced 
//unsigned long head_com_LOW_duration_start_time = millis(); // ** For TESTING only: used to hold off another head com force for 
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

///  SERIAL MONITOR SWITCHES   ////////////////////
byte G_SM_DC = 0;  // set to 1 to show DON COM messages

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define BITmaps2ExcludeFromRandomRing 13 // number of bitmaps that will be excluded from random ring 
int bitmaps2exclude[BITmaps2ExcludeFromRandomRing] = { 30,31,32,33,34,49,53,48, 35, 36, 47, 46, 1 };  // list of bitmaps that will be excluded from random RING selection

int G_count = 0;  // used for debugging
//unsigned long G_count2 = 0;  // used for debugging
unsigned long G_system_time = 0;  // used for BT_DELAY_FILTER()

byte G_scroll_speed = 1;  // controls the speed for TEXT scrolling with BT text
byte G_banner = 0;  // sets the TEXT banner for BT text


int G_test_number = 0; // defines which test is to be run
int G_show_num = 0;  // used to keep track of which show to display 
//int G_show_store = 0; // used to hold the normal next show number before interrupting the next show with a BT text show command
String G_message = "";  // blue tooth message received
char G_incomingChar;
byte G_BT_message_flag = 0;  // set to 1 when full Blue Tooth message received


char G_BT_command = ' ';  // blue toot command
char G_BT_command2 = ' ';  // 2nd blue toot command if G_BT_command='z'
char G_BT_command3 = ' ';  // 3nd blue toot command if G_BT_command='z'
char G_BT_previous_command = ' '; // holds the previous BT command
char G_BT_previous_command3 = ' '; // holds the previous BT command
//char G_BT_previous_command2 = ' '; // holds the previous BT command


byte G_BT_firstMessage_flag = 0;  // set to 1 after first message...which is garbage
volatile byte G_BT_connected_flag = 0;  // set to >0 after BT is connected


char G_special = '*';  // holds the special character for manual TEXT mode
byte G_special_saved_flag = 1;  // use to indicate to display leds_saved '*' and '%'  both
byte G_special_slider = 0; // anything >0  adds a special image TEXT character

//************** DON_COM variables  ***********************
byte G_DC_data = 0;  // data recieved from Don COM
int G_MASTER_SLAVE_FLAG = 1;  // set to 1 if board is MASTER and set to 0 if board is SLAVE; 
int G_frame_delay = 15; // amount of micro second delay between bytes, was 15 , was 50

int DC_M0_PIN = 21; // master Don Com 0 line
int DC_M1_PIN = 22;  // master Don Com 1 line
//int DC_S0_PIN = 23;  // slave Don Com 0 line   
int DC_S0_PIN = 33;  // slave Don Com 0 line   
int DC_S1_PIN = 15;  // slave Don Com 1 line  

int G_DC_M0 = 0; // place holder, get's re-assigned depending on MASTER of SLAVE BOARD
int G_DC_M1 = 0; // place holder, get's re-assigned depending on MASTER of SLAVE BOARD
int G_DC_S0 = 0; // place holder, get's re-assigned depending on MASTER of SLAVE BOARD
int G_DC_S1 = 0; // place holder, get's re-assigned depending on MASTER of SLAVE BOARD

#define DC_ARRAY_SIZE 4  // define the length of the DC array
byte DC_OUT_array[DC_ARRAY_SIZE];  // data to be sent to SLAVE
byte DC_IN_array[DC_ARRAY_SIZE]; // data received by SLAVE
byte G_DC_received_flag = 0;  // this is set to one if DC data is received
byte G_cycle_gen_on = 0;  // set to 1 to turn on cycle generator
byte G_color_cycle_gen_on = 0;  // set to 1 to turn on color cycle generator
//********************************************************

				   // How many leds in your strip?
				   // #define NUM_LEDS 484

#define ELEMENTS(x)   (sizeof(x) / sizeof(x[0]))

#define MAX_NUM_BITMAPS 106  // the maximum number of bitmaps to be stored in the Arduino ... need for mapping the bitmap array...actual # of bitmaps -1 (i.e. 105)


#define NUM_LEDS 484
#define NUM_LEDS_FAST 22
#define NUM_LEDS_PER_ROW 22
#define NUM_ROWS 22
#define NUM_COLUMNS 22



#define UNDO_STACK_SIZE 300   // this sets the size of the UNDO LIFO stack....4 bytes per undo 
byte undo_stack[UNDO_STACK_SIZE];
int G_pointer = 0;  // UNDO STACK pointer
byte G_pointer_rollover_flag = 0;  // set to 1 if the undo stack rolls back to position 0


CRGB fast_leds1[NUM_LEDS_FAST];
CRGB fast_leds2[NUM_LEDS_FAST];
CRGB fast_leds3[NUM_LEDS_FAST];
CRGB fast_leds4[NUM_LEDS_FAST];

CRGB leds_saved[6][NUM_LEDS];   // images saved in GUI2, transfered in by DC, note: leds_saved[0][n] = background 


//#define MAX_TEXT_HEIGHT 14   // maximum height of a TEXT letter
//#define BANNER_HEIGHT 4      // TEXT appears 4 rows down from the top
//#define MAX_TIMER_SLOTS 300  // maximum number of time slots I devide a single rotation into   ... was 300 , 100, 50 not work  .... 10 works 

#define MAX_TEXT_DISPLAYED 50 // maximum number of text letters that can be displayed at the same time before letters are dropped...note: this doesn't actually set this maximum... this will be used to size arrays
#define MAX_BINS 60 // NOTE: 15=maximum number of display bins where each bin holds a letter...in reality the maximum number of bins=max_len
#define NUM_RANDOM_IMAGES 5 // sets the number of random images made

char text_array[MAX_TEXT_DISPLAYED];  // used in CHECK_BLUE_TOOTH and hold BT message
char scroll_text_array[MAX_TEXT_DISPLAYED];  // used when calling SCROLL_TEXT
//char text_array_BT[MAX_TEXT_DISPLAYED];  // keep track of text to be displayed comming from BT
char bined_TEXT[MAX_BINS];   // NOTE: 15=maximum number of display bins where each bin holds a letter...in reality the maximum number of bins=max_len, for panels 1 and 2
char bined_TEXT2[MAX_BINS]; // this array holds the bined sychronized TEXT for panels 3 and 4
byte G_max_bins = 16;  // keeps track of number of times FastLED.show() can be called in one revolution...as measured by HALL_MEASURE3

//CRGB rot_leds3[MAX_TEXT_HEIGHT][MAX_TIMER_SLOTS] = { 0 };  // used to remember data from previously displayed FAST LEDs
//CRGB rot_leds4[MAX_TEXT_HEIGHT][MAX_TIMER_SLOTS] = { 0 };  // used to remember data from previously displayed FAST LEDs


//CRGB fast_leds3[NUM_LEDS_FAST];   // test
//CRGB fast_leds4[NUM_LEDS_FAST];   // test

CRGB leds1[NUM_LEDS];
CRGB leds2[NUM_LEDS];
CRGB leds3[NUM_LEDS];
CRGB leds4[NUM_LEDS];


CRGB leds_buffer1[NUM_LEDS];  // this is used to hold image data for use with SCROLL_TEXT, the data held in these buffers is scanned out with DISPLAY_TEXT
CRGB leds_buffer2[NUM_LEDS];




//CRGB leds[NUM_LEDS];
//CRGB fast_leds[NUM_LEDS_FAST];
//CLEDController *controllers[NUM_STRIPS];

#define MAX_HUES 12
byte hues[MAX_HUES] = { 0,24,42,62, 85,105, 128,148, 171,191, 213, 255 };     // differnt colors to chose from in HSV color space: RED,YELLOW,GREEN,AQUA,BLUE,PURPLE
byte G_hue_select = 0; // 0 to MAX_HUES  
int G_hue = -1;



// For led chips like Neopixels, which have a data line, ground, and power, you just
// need to define DATA_PIN.  For led chipsets that are SPI based (four wires - data, clock,
// ground, and power), like the LPD8806 define both DATA_PIN and CLOCK_PIN
//#define DATA_PIN_AUX 7   // use as a extra data pin for three controllers

//#define DATA_PIN_1 16  //  slow LED data pin for panel 1   ... board 1
#define DATA_PIN_1 14  //  slow LED data pin for panel 1   ... board 1

//#define DATA_PIN_2 19  // slow LED data pin for panel 2   .... board 1
#define DATA_PIN_2 27  // slow LED data pin for panel 2   .... board 1

#define DATA_PIN_3 13  //  slow LED data pin for panel 3  
#define DATA_PIN_4 26   ////  slow LED data pin for panel 4 

//#define DATA_PIN_3 25   /// test
//#define DATA_PIN_4 26   /// test



//#define DATA_PIN_FAST_1 4  // fast LED data pin for panel 1


//#define BRIGHTNESS 34
#define HEAD_COM 12  // intput tied to GPIO 17 output in BASE ... used for base to head communication
#define Hall 34  // Hall sensor tied to pin 2 on both boards...B2
#define Hall_out 32 // an output pin that mirrors the input signal on pin 34, used to drive HEX base

#define maximum_number_of_SAVED_images 5
byte G_AUTO_DIM_LEVEL = 250;  // was 246 amount to dim SLOW display if AUTO-DIM is on

//#define MOSI 23
//#define MISO 19
//#define SCK 18
//#define SS 5



int hall_sig = 1; // goes low when Hall Sensor trips
const int UpSideDown = 12;  // defines pin that determines if image is upside down or not, UpsideDown=1

int G_time_interval = 0;  // tracks how much time it takes for one revolution:  nominal value = 4583675
//int G_max_length = 654811; // corresponds to max_len=7:   devide this number into G_time_interval to calculate the max_len parameter in SCROLL_TEXT
int G_max_length = 572959; // corresponds to max_len=8:   devide this number into G_time_interval to calculate the max_len parameter in SCROLL_TEXT

int SPEED = 1;  //speed of frame

//int sensorPin = 34;    // The potentiometer is connected to 0
					  // analog pin 0
int G_bright = 1023;

int G_upside_down = 0;  // set to 1 to turn image upside down, this will be read by pin #12
int G_flipped = 0;  // this will equal 1 if the display is flipped....used in FLIP function

int G_special_char_select = 1;  // this control which bitmaps map into:   *%#^~
int G_2nd_saved_image = 0;  // used to hold a 2nd saved image to be minipulated by RING_with_IMAGE

int shift = 0; // sets how many bits to right shift to decrease brightness
int mask = 1023;  // 01111111 needed to get rid of sign bit

volatile unsigned long G_Hall_counts = 0;  // keeps track of the number of times the Hall sensor was tripped



int G_production = DEFAULT_PRODUCTION;  // specify which PRODUCTION to do first
int G_next_production = 1; // this will be set by GUI4 for the production to LOAD with the LOAD button
int G_bmp_num = 1;  // keeps track of bitmap number
int leave_flag = 0;
int image_count = 0;  //keeps track of the total number of images displayed
int G_num_col = 11 + 1; // number of columns  was 11
int G_letter_width = 6;  // width of a single ascii letter + 1 space
byte G_char_width_flag12 = 0; // flag =0 if character to be displayed in panels 1 and 2 is of normal G_letter_width and flag=1 if character is full G_num_col width
byte G_char_width_flag34 = 0; // // flag =0 if character to be displayed in panels 3 and 4 is of normal G_letter_width and flag=1 if character is full G_num_col width
int G_phase_dly = 0;  // phase delay between the two panels
int G_max_flashes = 0; // maximum number of FastLED_shows() in one revolution

int BMP_MAP[MAX_NUM_BITMAPS];   // holds the starting index value for each bitmap
int FONT_MAP[MAX_NUM_BITMAPS];   // holds the starting index value for each FONT
int type = 0;  // type=   255= full bitmap, 254=differential bitmap, 253= end of BMP_array
int G_dim = DEFAULT_BRIGTHNESS; // sets dimmness of LEDs...0=maximum brightness
int G_pass = 0;  // keeps track of number of times LOOP() is called

//byte G_execute_CREATE_mode = 0;  // this insures that CREATE mode is entered even if MASTER is in control

byte G_continuous_SPECIAL_mode = 0; // if set to 1 the "special" TEXT image will be displayed continuously
byte G_continuous_SPECIAL_mode_was_ON = 0;  // this is set to 1 if G_continuous_SPECIAL_mode was ON
byte G_TEXT_flag = 0; // set to 1 if a TEXT message is to be displayed


byte G_cycle = 1; // sets which cycle effect to execute
byte G_pervious_cycle = 1; // holds the last G_cycle executed
byte G_CYCLE_ON = 0;  // holds the state of the GUI2 CYCLE generator switch
byte G_CREATE_mode = 0; // set to 1 to turn on CREATE mode
byte G_do_CREATE_mode = 0;  // set to 1 to turn on CREATE mode when transfer is back to SLOW
byte G_SAVED[6] = { 0,0,0,0,0,0 }; // set to 1 if leds_save are saved and LEDs are non-zero
byte G_COLOR_CYCLE_SWITCH_ON = 0; // holds the state of the cycle COLOR switch in GUI2
byte G_COLOR_cycle = 1; // sets which color cycle effect to execute 
byte G_pervious_color_cycle = 1; // holds the last G_color_cycle executed
byte G_PLAY_SAVES_MODE_ON = 0;  // set to 1 if PLAY SAVES mode is on
byte G_exit_PLAY_SAVES_MODE = 0; // set to 1 to exit PLAY SAVES mode after the show is over
byte G_EFFECT_slider_previous = 5;  // holds previous value of EFFECT slider 
byte G_TRANSFERED_image = 0;  // holds current image being transfered from SLAVE
int G_adr = 0;  // holds the present address of the data being received by the SLAVE
int G_active = NUM_LEDS_FAST;  // number of active LEDs
//////////// below is from SLAVE program /////////////////
int G_cal_star_float = 0;  // keep track of how many times STAR_FLOAT is called before I re-calibrate
byte G_hue_cycle = 0;  // current hue to be used in HUE_CYCLE

byte G_beginning_SHOW_flag = 0;  // this will be set to 1 after the very first SHOW
byte G_interceeded_flag = 0; // set to 1 if a DON_COM show was interceeded with an "S" BT command

byte G_repeat_show_flag = 0; // set to 1 to repeat the current show

byte G_executing_CREATE_mode = 0;  // this is set to 1 when inside CREATE mode
byte G_X = 0; // used in CREATE mode
byte G_Y = 0; // used in CREATE mode
byte G_X_previous = 0;  // previous value of G_X
byte G_Y_previous = 0;  // previous value of G_Y

byte G_rotate_color = 0; // set to 1 to rotate colors in CREATE mode
byte G_hue_cycle_vert = 0;  // set to 1 to cycle hues in CREATE mode
byte G_hue_cycle_hoz = 0;  // set to 1 to cycle hues in CREATE mode
byte G_panel1_on = 1;  // set to 1 to turn on panel 1 in CREATE mode, = turns off panel
byte G_panel2_on = 1;  // set to 1 to turn on panel 2 in CREATE mode, = turns off panel
byte G_panel3_on = 1;  // set to 1 to turn on panel 3 in CREATE mode, = turns off panel
byte G_panel4_on = 1;  // set to 1 to turn on panel 4 in CREATE mode, = turns off panel
byte G_STAR_flag = 0;  // set to 1 to turn on STAR mode in CREATE mode
byte G_SPEED_slider = 1; // used in CREATE mode to control special effect speeds
#define G_EFFECT_slider_default 5
byte G_EFFECT_slider = G_EFFECT_slider_default;  // holds value of EFFECT slider and controls the number of random images drawn, was 5
byte G_geometery = 1;  // in CREATE mode: 0=line, 1=dots, 2=circle
byte G_end_flag = 0; // this is set to 1 after second XY pair is receive in LINE or CIRCLE mode
byte G_cycle_XYflipInvert_mode = 0;
byte G_in_TRANSFER2_FAST = 0;  // set to 1 if inside TRANSFER2_FAST function
byte G_RESET = 0;  // set to 1 if RESET occurs, set to 0 by MASTER DC command 34
byte G_Hroll = 0;  // set to 1 for horizontal roll
byte G_Vroll = 0;  // set to 1 for vertical roll
byte G_Xbounce = 0;  // set to 1 for continuous X bounce
byte G_Ybounce = 0;  // set to 1 for continous Y bounce
byte G_MIRROR_HV = 0; // controls direction of horizontal mirroring
byte G_MIRROR_diag = 0; // set to 1 for continuous diagonal mirroring


byte G_CONT_GEN = 0; // set to 1 to enable random CONT_GEN function DC=38
byte G_CYCLE_SAVES = 0;  // set to 1 to cycle saves
byte G_CYCLE = 0;  // holds the number of times CREATE_MODE executed
byte G_CYCLE_BUTTON_pressed = 0; // set to 1 to generate one cycle in GUI2 CYCLE generator
byte G_COLOR_CYCLE_BUTTON_pressed = 0; // set to 1 to generate one COLOR cycle in GUI2 CYCLE generator


byte G_active_PSS_image = 0;  // this is the current SAVED image being processed by PLAY_SAVES
byte G_GEN = 0; // this is set to 1 if a GEN command is received
byte G_RAND_HUE = 1; // this is set to 1 if random hue switch is on
byte G_KEEP = 0; // set to 1 by KEEP button 
byte G_num2UNDO = 0;  // holds the number of undo's to do 
byte G_TRANS_SWITCH = 0;  // state of TRANS switch, 1=on
byte G_transformation = 1; // holds display transformation to be done 
byte G_LOAD_DEFAULT_CREATE_MODE_IMAGE_flag = 0; //if 1 then load default CREATE mode image
byte G_number_of_transformations = 7;  // sets the number of possible transformation...number re-set in DO_TRANSFORMATION()
byte G_number_of_color_transformations = 2;  // sets the number of possible color transformations....number re-set in DO_COLOR_TRANSFORMATION()
byte stored_max_flashes[23];  // holds measured data on the maximum number of FastLED.show(); that can be done for index*22 leds
int G_startup_max_flashes = 0; // holds the maximum number of FastLED.show() that is measured for 22x22 LEDs at startup
int BMP_LOOKUP_ARRAY[2]; // holds bmp which corresponds to TEXT=(*,%),(#,^), ... in that order...array is referenced if G_special_char_sel=3000
byte G_2nd_half_flag = 0; //set to 1 if pre-made image 2nd half is to be ringed
byte G_column_0_count = 0;  // keep track of how many times G_active_column is set
byte G_cont_special_depth = 1; // sets display depth in continuous special mode
byte G_cont_special_effect = 0; // sets display EFFECT in continuous special mode
byte G_do_once = 0;
byte G_first_active_column = 21; // set in SET_VAR

unsigned long G_max_blanks = 6;  // used in STAR FLOAT
unsigned long G_time = 0; // keep track of system time

int G_SHOW_fast_row_offset = 0; // keeps track of how many times SHOW_fast() is called
byte G_row_direction = 1; // 1=incremental row direction is positive, 0= incremental row direction is negative

int8_t bounce[NUM_LEDS];  // signed 7 bit value
int8_t G_UNDO_stored = 0;  // 0= no images stored in leds_buffer1 or leds_buffer2, 1= one undo image stored in leds_buffer#, 2= two undo images stored in leds_buffer#
#define maximum_number_of_stored_buffer_images 2
byte UNDO_stored_array[maximum_number_of_stored_buffer_images] = { 0,0 };  //holds pointer to leds_buffer# that holds the UNDO image , highest index value is last in and first out 

byte G_BT_cmd = 0; // keep track of some BT commands, this is an arbitrary NUMBER assigned for a decoded BT command
byte G_BT_cmd_previous = 0; // keep track of previous BT command

byte G_SHOW_var_COUNT = 0;
byte G_SKIP_BTCH = 0;  // set to 1 to skip BLUE_TOOTH_COMMAND_HANDLER
byte G_SKIP_BTCH_previous = 0;  // used to detect first time G_SKIP_BTCH is set to 1
unsigned long G_BTCH_SKIP_TIME = 0; // a time stamp of when G_SKIP_BTCH is set to 1. I implemented this because sometimes G_SKIP_BTCH=1 gets stuck....I don't know why
unsigned long G_CREATE_MODE_start_time = 0;
byte G_BLOCK_BT_CHECK = 0; // when set to 1 CHECK_BLUE_TOOTH() is skipped

#define MAX_TIMES_CREATE_MODED_SAVED_IMAGES_SHOWN_IN_NORMAL_SHOW 3  // the number of times user saved images are shown in DO_SHOW before random images are generated
unsigned long G_TIMES_SAVED_IMAGES_SHOWN = 0;  // holds the number of times SAVED images are shown in DO_SHOW

byte G_music_only_switch = 0;  // controlled by MUSIC only switch in GUI4
unsigned long G_music_start_time = millis();  // keep track of last MUSIC detection time
byte G_sound_detected_flag = 0;  // will be set to 1 if a sound is detected in a PRODUCTION
byte G_force_production_end = 0;  // this is set to 1 to force end of current PRODUCTION
byte G_production3_counts = 0;  // keep track of how many times PRODUCTION3 is shown
byte G_start_next_production_flag = 0;  // set to 1 to force G_next_production to execute
int G_next_show = 1; // used in GUI4 for choosing which SHOW to LOAD
int G_number_of_shows = 0; // used to display the FINAL SHOW in GUI4
byte G_MIC_ON_flag = 1;  // equals 1 if MIC is on, 0 if off
//byte G_MIC_ENABLE_switch_state_flag = 1;  // equals 1 if MIC switch is on, 0 if MIC switch is off

byte  G_Hall_sync_original = G_Hall_sync;  // holds previous  G_Hall_sync value before DETECT_BASE_and_COME_HITHER() sets G_Hall_sync=0 
int G_force_sound_productions_original = G_force_sound_productions;  // holds previous G_force_sound_productions as HEAD COM can modify G_force_sound_productions
byte G_come_hither_flag = 0;  // set to 1 first time come hither show is needed
float G_beat_detect_threshold;  // adjusted BEAT_DETECTOR threshold level
float G_percentage_beat_detect_amplitude_reduction = 0; // used in to report threshold decay rate in BEAT_DETECTOR
byte G_MUSIC_detected_flag = 0;  // will be set to 1 if MUSIC is detected

#define NUMBER_OF_BEAT_SHOWS 24 // number of different non-random beat shows -1
byte BS_enables[NUMBER_OF_BEAT_SHOWS]; // enable for BEAT_SHOWs
int hue1_bs[NUMBER_OF_BEAT_SHOWS];
int hue2_bs[NUMBER_OF_BEAT_SHOWS];


#define NUMBER_OF_IMAGE_TYPES 9  // 1=line,2=circle, 3=square, 4=triangle, 5=HOZ_V no SE swap, 6=HOZ_V with SE swap, 7=ZIG_ZAG, 8=SPIKES with axis, 9=SPIKES no axis
#define MAX_NUMBER_IMAGES_to_TWEEN 10   // keep track of xy location of randomly generated images using CREATE_RANDOM_IMAGES  
#define MAX_NUMBER_RANDOM_TWEEN 10 // holds random TWEEN data

/// used in IMPRINT function
#define IHUE 1 //hue the imprint screen replaces hue of active screen pixels: IHUE
#define IXOR 2  //XOR the buffer onto  the active screen pixels: IXOR
#define IAND_BUFFER 3  //AND the buffer and  the active screen pixels, leave buffer pixles: IAND_BUFFER
#define IAND_SCREEN 4 //AND the buffer and  the active screen pixels, leave screen pixles: IAND_SCREEN

#define SIZE_of_VALUES_array 13

int VALUES[SIZE_of_VALUES_array] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11, 0 }; // used in conjunction with Serial Monitor and the GET_VALUES function to set the value of elements of this array
// NOTE: use VALUES[0] =1 to report all values.  After this VALUES[0] is set to 0 by the program.


//byte XS[MAX_NUMBER_IMAGES_to_TWEEN];  // starting X
//byte XE[MAX_NUMBER_IMAGES_to_TWEEN];  // ending x  , or radius if circle
//byte YS[MAX_NUMBER_IMAGES_to_TWEEN];  // starting y
//byte YE[MAX_NUMBER_IMAGES_to_TWEEN];  // ending y , or radius if circle
//byte HUE_IMAGE[MAX_NUMBER_IMAGES_to_TWEEN];  // keep track of the hue of the generated object
//byte IMAGE_KIND[MAX_NUMBER_IMAGES_to_TWEEN];  // type of image, line, circle, rectangle, triangle...
//
//byte XS1[MAX_NUMBER_IMAGES_to_TWEEN];  // starting X
//byte XE1[MAX_NUMBER_IMAGES_to_TWEEN];  // ending x  , or radius if circle
//byte YS1[MAX_NUMBER_IMAGES_to_TWEEN];  // starting y
//byte YE1[MAX_NUMBER_IMAGES_to_TWEEN];  // ending y , or radius if circle
//byte HUE_IMAGE1[MAX_NUMBER_IMAGES_to_TWEEN];  // keep track of the hue of the generated object
//byte IMAGE_KIND1[MAX_NUMBER_IMAGES_to_TWEEN];  // type of image, line, circle, rectangle, triangle...

#define DEFAULT_MIC_gain .5
double G_MIC_gain = DEFAULT_MIC_gain;  // 1 = max MIC gain

struct tween
{
	byte XS; // starting X
	byte XE; // ending X
	byte YS; //// starting Y
	byte YE;  //// ending y
	int HUE; // hue for this object, axis hue
	int DATA1; // for general use: for zig_zag=peaks
	int DATA2; // for general use: for zig_zag=amplitude
	int DATA3; // for general use: for spike=spike hue
	//int DATA4; // for general use: for spike=mode 0=no axis only spikes , 1=spikes and axis
	byte IMAGE_KIND; // // type of image, 1=line, 2=circle, 3=rectangle, 4=triangle, 5=HOZ_V , 6=HOZ_V BE swap, 7=ZIG_ZAG, 8=SPIKES with axis, 9=SPIKES no axis

};

tween TWEEN_IMAGE_START[MAX_NUMBER_IMAGES_to_TWEEN];
tween TWEEN_IMAGE_END[MAX_NUMBER_IMAGES_to_TWEEN];

tween TWEEN_RANDOM_START[MAX_NUMBER_RANDOM_TWEEN];
tween TWEEN_RANDOM_END[MAX_NUMBER_RANDOM_TWEEN];



#define MAX_VERTICIES 100
struct verticies {         // holds description of 3D object to be displayed
	int x;
	int y;
	int z;
};

verticies verts[10];

struct cylindrical {   // cylindrical coordinates
	int radius;  // radius
	int angle;
	int z;
};

cylindrical cylin[MAX_VERTICIES];

float G_radius = 0;  // cylindrical coordinate
float G_angle = 0;  // cylindrical coordinate
float G_z = 0;     // cylindrical coordinate
byte G_flash_angle = 0;  // number of flashes corresponding to G_angle

/////////////////// for testing only  /////////////////////
byte test_array[25];  // for test purposes only
byte G_test_count = 0;  // for test purposes only
byte G_max_test_count = 25;

////////////////////////////////////////////////////////////

//volatile unsigned long startMicros;
//volatile unsigned long currentMicros;
//volatile unsigned long period;  //the time between startMillis and currentMillis
//volatile unsigned long delay_interval;  // how long to delay
//volatile unsigned long period_avg = 0; // average time in micros seconds for one revolution
//volatile unsigned long sum_periods = 0;  // running sum used to calculate avg_period
//volatile unsigned long num_averaged = 0;  // number of periods averaged
//volatile unsigned long num2average = 1;  // number of periods to average
//volatile char start_flag = 0; // set to 1 after when you want to start averaging periods
//volatile unsigned long micro_per5Degree = 0; // number if micro seconds of revolution per degree





//// ************  for timer interrupt  ****************
//// from:  https://techtutorialsx.com/2017/10/07/esp32-arduino-timer-interrupts/
//
//volatile int G_timer_count;
////int totalInterruptCounter;
//
//hw_timer_t * timer = NULL;
//portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
//
//void IRAM_ATTR onTimer() {              // this is the timer interrupt routine
//	portENTER_CRITICAL_ISR(&timerMux);
//	G_timer_count++;
//	portEXIT_CRITICAL_ISR(&timerMux);
//
//}

int G_max_timer_count;  // maximum number of timer interrupts in one rotation....typical value=259
//***************************************************

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^




	// the callback function is needed for automatic GUI generation
void callback(esp_spp_cb_event_t event, esp_spp_cb_param_t* param) {
	if (event == ESP_SPP_SRV_OPEN_EVT) {
		Serial.println("Client Connected");
		//	delay(5000);

			//GUI();
		G_BT_connected_flag = 1;  // this will generate the GUI if G_enable_GUI_generator=1

	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////  BEAT DETECTOR  ///////////////////////////////////////////////////
	//  from:  https://www.hackster.io/mamifero/arduino-beat-detector-d0a21f
	//////////////////////////////////////////////////////////////////////////////////////////////



	// Arduino Beat Detector By Damian Peckett 2015
// License: Public Domain.

// Our Global Sample Rate, 5000hz
#define SAMPLEPERIODUS 200
//
//// defines for setting and clearing register bits
//#ifndef cbi
//#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
//#endif
//#ifndef sbi
//#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
//#endif



/////////////////////////////////////////////// FFT STUFF  //////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// (Heavily) adapted from https://github.com/G6EJD/ESP32-8266-Audio-Spectrum-Display/blob/master/ESP32_Spectrum_Display_02.ino
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <dummy.h>
#include <FastLED.h>
#include <arduinoFFT.h>
//#include <JC_Button.h>

#define SAMPLES         1024         // Must be a power of 2, was 1024
#define SAMPLES2         512         // Must be a power of 2, was 1024
#define SAMPLING_FREQ   40000         // Hz, must be 40000 or less due to ADC conversion time. Determines maximum frequency that can be analysed by the FFT Fmax=sampleF/2. , was 40000
#define SAMPLING_FREQ2   8000         // uesed in FFT2: Determines maximum frequency that can be analysed by the FFT Fmax=sampleF/2. , was 8000
#define AMPLITUDE       3000          // Depending on your audio source level, you may need to alter this value. Can be used as a 'sensitivity' control, was 1000
#define AUDIO_IN_PIN    35            // Signal in on this pin
//#define DATA_PIN_1      14            // LED strip data for panel 1
//#define BTN_PIN         2             // Connect a push button to this pin to change patterns
//#define DEBOUNCE_MS     20            // Number of ms to debounce button
//#define COLOR_ORDER     GRB           // If colours look wrong, play with this
//#define CHIPSET         WS2812B       // LED strip type
//#define BRIGHTNESS      50            // Brightness 0 - 255, but won't exceed current specified above
//#define LED_VOLTS       5             // Usually 5 or 12
#define NUM_BANDS       22            // To change this, you will need to change the bunch of if statements describing the mapping from bins to bands, was 16
#define NOISE           500           // Used as a crude noise filter, values below this are ignored

byte G_COMB_bandValues = 22;    // further combined bands 

//////////
//#define DATA_PIN_2 27  // slow LED data pin for panel 2   .... board 
//#define DATA_PIN_3 13  //  slow LED data pin for panel 3  
//#define DATA_PIN_4 26   ////  slow LED data pin for panel 4 
///////////////

const uint8_t kMatrixWidth = 22;                          // Matrix width
const uint8_t kMatrixHeight = 22;                         // Matrix height
//#define NUM_LEDS       (kMatrixWidth * kMatrixHeight)     // Total number of LEDs
#define BAR_WIDTH      (kMatrixWidth  / (NUM_BANDS - 1))  // If width >= 8 light 1 LED width per bar, >= 16 light 2 LEDs width bar etc
#define TOP            (kMatrixHeight - 1)                // Don't allowthe bars to go offscreen

// Sampling and FFT stuff
unsigned int G_sampling_period_us;
unsigned int G_sampling_period_us2;

byte peak[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };              // For more than 16 channels you must increase the size of these arrays
int oldBarHeights[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
int bandValues[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
int COMB_bandValues[] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };  // COMB_bandValues are a summed combination of bandValues 




///////////////////////////////////////////////////////////

#define NUMBER_OF_MNOTES 24
#define MNOTE_SIZE 2  // how much data is contained in a MNOTE, was 15
int image_array[NUMBER_OF_MNOTES];



struct MUSICAl_NOTES {   // musical note FFT info
	int bin[MNOTE_SIZE]; // bin = address
	byte data[MNOTE_SIZE];  // value in bin
	byte hue;  // color for the MNOTE

};

MUSICAl_NOTES MNOTE[NUMBER_OF_MNOTES];  // 24 musical notes

//int G_SD2_sum = 0;  // sum from SOUND_DETECT2
int G_ND_correlation = 0; // holds the maximum NOTE_DETECT correlation used to set a threshold for NOTE_DETECT2

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// NOTE: bin width resolution = 40KHz sample rate/1024 samples = 39Hz per bin
float vReal[SAMPLES];
float vImag[SAMPLES];
float vReal2[SAMPLES2];  // used in FFT2
float vImag2[SAMPLES2];  // used in FFT2
unsigned long newTime;
ArduinoFFT<float> FFT = ArduinoFFT<float>(vReal, vImag, SAMPLES, SAMPLING_FREQ);
ArduinoFFT<float> FFT2 = ArduinoFFT<float>(vReal2, vImag2, SAMPLES2, SAMPLING_FREQ2);  // used for NOTE_DETECT()

// Button stuff
int buttonPushCounter = 0;
//Button modeBtn(BTN_PIN, DEBOUNCE_MS);

// FastLED stuff
//CRGB leds1[NUM_LEDS];
DEFINE_GRADIENT_PALETTE(purple_gp) {
	0, 0, 212, 255,   //blue
		255, 179, 0, 255
}; //purple
DEFINE_GRADIENT_PALETTE(outrun_gp) {
	0, 141, 0, 100,   //purple
		127, 255, 192, 0,   //yellow
		255, 0, 5, 255
};  //blue
CRGBPalette16 purplePal = purple_gp;
CRGBPalette16 outrunPal = outrun_gp;
uint8_t colorTimer = 0;

// XY code for serpentine matrix with input in top left
uint16_t XY(uint8_t x, uint8_t y) {
	uint16_t i;

	y = kMatrixHeight - 1 - y;  // Adjust y coordinate so (0,0) is bottom left

	if (y & 0x01) {
		// Odd rows run backwards
		uint8_t reverseX = (kMatrixWidth - 1) - x;
		i = (y * kMatrixWidth) + reverseX;
	}
	else {
		// Even rows run forwards
		i = (y * kMatrixHeight) + x;
	}
	return i;
}

////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////




void setup() {

	for (int n = 0; n < MAX_NUMBER_IMAGES_to_TWEEN; ++n)
	{
		TWEEN_IMAGE_START[n].DATA1 = 3;   // peaks for spikes and zig_zag
		TWEEN_IMAGE_START[n].DATA2 = 5;   // amplitude for spikes and zig_zag
		TWEEN_IMAGE_START[n].DATA3 = 0;  // hue_spikes for spikes
		//TWEEN_IMAGE_START[n].DATA4 = 0;  // mode for spikes
	}

	///////////  for NOTES ////
	// calibrated with signal generator set to 1VPP and fed directly to the esp32 A2D input.

	// NOTE: FFT2:   bin width resolution = 8KHz sample rate/512 samples = 15Hz per bin
	// for FFT, 125us/sample --> 64ms/512 samples

		/* NOTE detection works by using FFT2 then running FIND_MAX_CORRELATION_VALUE().
		This is needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2.
		G_ND_correlation is the maximum correlation from any of the MNOTES relative to the FFT2 bins (all bins).
		The threshold for NOTE_DETECT2 is a fixed fraction of G_ND_correlation.
		Also, all the MNOTE data is scaled according to MNOTE[].gain_factor. The MNOTE data is retrieved from TEST #51.
		This data is captured from the microphone after playing each note. But, because playing a note multiple times results in
		data that is not consistant in amplitude, I need to scale the MNOTE data to normalize it.
		The MNOTE[].gain_factor is obtained by playing a NOTE multiple times and finding the maximum correlation value
		as reported by NOTE_DETECT2. I then normalized everything to NOTE 0's maximum correlation value.
		*/

		// initizlize MNOTEs
	for (byte note = 0; note < NUMBER_OF_MNOTES; ++note)
	{
		for (int n = 0; n < MNOTE_SIZE; ++n)
		{
			MNOTE[note].bin[n] = 0;
			MNOTE[note].data[n] = 0;

			//MNOTE[note].gain_factor = 1000;

		}
	}

	int HF_gain_correction = 1000;  // was 400

	//  ******* NOTE:  MNOTE data taken with signal generator at Vout = 1V PP feeding the esp32 A2D input (though coupling cap. network)  *******************************************
	// some of the gain values are adjusted to try and more accurately detect the note from the PIANO ... this was done using a cable from the tablet to the A2D input

	// 175 Hz:  F3
	MNOTE[0].bin[0] = 10;
	MNOTE[0].data[0] = 1400;  //was 18
	MNOTE[0].bin[1] = 11;
	MNOTE[0].data[1] = 71;


	// 185 Hz:  F3#
	MNOTE[1].bin[0] = 11;
	MNOTE[1].data[0] = 300; // was 38
	MNOTE[1].bin[1] = 12;
	MNOTE[1].data[1] = 75;  // was 75


	// 196 Hz  G3
	MNOTE[2].bin[0] = 11;
	MNOTE[2].data[0] = 2;  //was 5
	MNOTE[2].bin[1] = 12;
	MNOTE[2].data[1] = 100;  // was 55


	// 196 Hz  G3#
	MNOTE[3].bin[0] = 12;
	MNOTE[3].data[0] = 13;
	MNOTE[3].bin[1] = 13;
	MNOTE[3].data[1] = 67;   // was 67 , 100


	// 220 Hz  A3
	MNOTE[4].bin[0] = 13;
	MNOTE[4].data[0] = 23;
	MNOTE[4].bin[1] = 14;
	MNOTE[4].data[1] = 61;  // was 74 , 100

	// 233 Hz  A3#
	MNOTE[5].bin[0] = 14;
	MNOTE[5].data[0] = 32;
	MNOTE[5].bin[1] = 15;
	MNOTE[5].data[1] = 76;


	// 247 Hz  B3
	MNOTE[6].bin[0] = 15;
	MNOTE[6].data[0] = 38;
	MNOTE[6].bin[1] = 16;
	MNOTE[6].data[1] = 76;

	// 262 Hz:  C4
	MNOTE[7].bin[0] = 16;
	MNOTE[7].data[0] = 41;
	MNOTE[7].bin[1] = 17;
	MNOTE[7].data[1] = 75;


	// 277 Hz:  C4#
	MNOTE[8].bin[0] = 17;
	MNOTE[8].data[0] = 43;
	MNOTE[8].bin[1] = 18;
	MNOTE[8].data[1] = 74;

	// 294 Hz:  D4
	MNOTE[9].bin[0] = 18;
	MNOTE[9].data[0] = 36;
	MNOTE[9].bin[1] = 19;
	MNOTE[9].data[1] = 76;


	// 311 Hz:  D4#
	MNOTE[10].bin[0] = 19;
	MNOTE[10].data[0] = 31;
	MNOTE[10].bin[1] = 20;
	MNOTE[10].data[1] = 76;

	// 330 Hz:  E4
	MNOTE[11].bin[0] = 20;
	MNOTE[11].data[0] = 19;
	MNOTE[11].bin[1] = 21;
	MNOTE[11].data[1] = 73;

	// 349 Hz:  F4
	MNOTE[12].bin[0] = 21;
	MNOTE[12].data[0] = 9;
	MNOTE[12].bin[1] = 22;
	MNOTE[12].data[1] = 64;

	// 370 Hz:  F4#
	MNOTE[13].bin[0] = 23;
	MNOTE[13].data[0] = 44;
	MNOTE[13].bin[1] = 24;
	MNOTE[13].data[1] = 74;

	// 392 Hz:  G4
	MNOTE[14].bin[0] = 24;
	MNOTE[14].data[0] = 19;
	MNOTE[14].bin[1] = 25;
	MNOTE[14].data[1] = 73;

	// 415 Hz:  G4#
	MNOTE[15].bin[0] = 25;
	MNOTE[15].data[0] = 3;
	MNOTE[15].bin[1] = 26;
	MNOTE[15].data[1] = 51;

	// 440 Hz:  A4
	MNOTE[16].bin[0] = 27;
	MNOTE[16].data[0] = 15;
	MNOTE[16].bin[1] = 28;
	MNOTE[16].data[1] = 70;

	// 466 Hz:  A4#
	MNOTE[17].bin[0] = 29;
	MNOTE[17].data[0] = 32;
	MNOTE[17].bin[1] = 30;
	MNOTE[17].data[1] = 76;

	// 494 Hz:  B4
	MNOTE[18].bin[0] = 31;
	MNOTE[18].data[0] = 45;
	MNOTE[18].bin[1] = 32;
	MNOTE[18].data[1] = 74;

	// 523 Hz:  C5
	MNOTE[19].bin[0] = 32;
	MNOTE[19].data[0] = 4;
	MNOTE[19].bin[1] = 33;
	MNOTE[19].data[1] = 54;

	// 554 Hz:  C5#
	MNOTE[20].bin[0] = 34;
	MNOTE[20].data[0] = 4;
	MNOTE[20].bin[1] = 35;
	MNOTE[20].data[1] = 52;

	// 587 Hz:  D5
	MNOTE[21].bin[0] = 36;
	MNOTE[21].data[0] = 2;
	MNOTE[21].bin[1] = 37;
	MNOTE[21].data[1] = 45;

	// 622 Hz:  D5#
	MNOTE[22].bin[0] = 39;
	MNOTE[22].data[0] = 29;
	MNOTE[22].bin[1] = 40;
	MNOTE[22].data[1] = 76;

	// 659 Hz:  E5
	MNOTE[23].bin[0] = 41;
	MNOTE[23].data[0] = 12;
	MNOTE[23].bin[1] = 42;
	MNOTE[23].data[1] = 67;

	////////////  MNOTE SCALING /////////////////////////////////////////////
	// SCALE MNOTE data based on MNOTE.gain_factor
	// gain at HF is reduced as low frequency harmonics often exceed the fundamental resulting in mis-classified or missing notes
	int scaled_MNOTE = 0;
#define gain_factor  500  // relative to 1000 = no gain reduction ...ex. 500 will cut gain in half
#define HF_note_start 13  // MNOTE gain reduced above this note#


	for (byte note = HF_note_start; note < NUMBER_OF_MNOTES; ++note)
	{
		for (int n = 0; n < MNOTE_SIZE; ++n)
		{

			scaled_MNOTE = (((MNOTE[note].data[n]) * gain_factor) / 1000); // 1000 is a because I wanted to use integer math not floating point

			MNOTE[note].data[n] = scaled_MNOTE;


		}
	}




	/////////////////////////////////

	MAP_image_array(1);  // store bmp image numbers into the image_array	

	G_sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQ));  // for FFT , 25us/sample --> 25.6ms/1024 samples
	G_sampling_period_us2 = round(1000000 * (1.0 / SAMPLING_FREQ2));  // for FFT, 125us/sample --> 64ms/512 samples


	// limit my draw to 5A at 5v of power draw
	FastLED.setMaxPowerInVoltsAndMilliamps(5, 5000);   // 5A supply 

	// This is how to use the serial monitor                             *********        FOR SERIAL MONITOR         **********
	if (SERIAL_MON > 0)
	{
		//	Serial.begin(9600);
		Serial.begin(115200);
		while (!Serial); // wait for serial port to connect. Needed for native USB
		Serial.println(F("OK"));
		Serial.println(F("second OK"));
	}

	if (G_BT_enable == 1)
	{

		SerialBT.register_callback(callback);  //needed for GUI generation...callback function is called when tablet connects to ESP32

		if (G_MURG == 1)   // spinning processor
		{
			// formally ESP32_MASTER
			if (!SerialBT.begin("MURGETROID_1")) {
				Serial.println("An error occurred initializing Bluetooth");
			}
			else {
				Serial.println("Bluetooth initialized");
			}
		}

		if (G_MURG == 2)  // spinning processor
		{

			if (!SerialBT.begin("MURGETROID_2")) {
				Serial.println("An error occurred initializing Bluetooth");
			}
			else {
				Serial.println("Bluetooth initialized");
			}
		}

		if (G_MURG == 3)  // version with non-moving processr
		{

			if (!SerialBT.begin("MURGETROID_3")) {
				Serial.println("An error occurred initializing Bluetooth");
			}
			else {
				Serial.println("Bluetooth initialized");
			}
		}

		//SerialBT.flush();
		FLUSH_BT_BUFFER();

		//	SerialBT.begin("ESP32_MASTER"); //Bluetooth device name
		//	Serial.println(F("The device started, now you can pair it with bluetooth!"));

		//	SerialBT.print("*LR0G255B0*");  // turn indicator GREEN
	}

	//// *************  for timer interrupt  *********************
	//timer = timerBegin(0, 80, true);
	//timerAttachInterrupt(timer, &onTimer, true);
	//timerAlarmWrite(timer, 1000, true);   // should interrupt ever  1ms 
	//timerAlarmEnable(timer);
	////**********************************************************

	// Put SCK, MOSI, SS pins into output mode
	// also put SCK, MOSI into LOW state, and SS into HIGH state.
	// Then put SPI hardware into Master mode and turn SPI on
	//SPI.begin();
	//SPI.setClockDivider(SPI_CLOCK_DIV8);



	// Uncomment/edit one of the following lines for your leds arrangement.
	// FastLED.addLeds<TM1803, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<TM1804, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<TM1809, DATA_PIN, RGB>(leds, NUM_LEDS);


	//FastLED.addLeds<WS2812B, DATA_PIN_1, GRB>(fast_leds3, NUM_LEDS_FAST);  // mapping to align with HALL magnet
	//FastLED.addLeds<WS2812B, DATA_PIN_2, GRB >(fast_leds4, NUM_LEDS_FAST);
	//FastLED.addLeds<WS2812B, DATA_PIN_3, GRB>(fast_leds1, NUM_LEDS_FAST);
	//FastLED.addLeds<WS2812B, DATA_PIN_4, GRB >(fast_leds2, NUM_LEDS_FAST);

	// LED DATA PINS
	pinMode(DATA_PIN_1, OUTPUT);
	digitalWrite(DATA_PIN_1, LOW);

	pinMode(DATA_PIN_2, OUTPUT);
	digitalWrite(DATA_PIN_2, LOW);

	pinMode(DATA_PIN_3, OUTPUT);
	digitalWrite(DATA_PIN_3, LOW);

	pinMode(DATA_PIN_4, OUTPUT);
	digitalWrite(DATA_PIN_4, LOW);

	FastLED.addLeds<WS2812B, DATA_PIN_1, GRB>(leds3, NUM_LEDS);  // mapping to align with HALL magnet
	FastLED.addLeds<WS2812B, DATA_PIN_2, GRB >(leds4, NUM_LEDS);
	FastLED.addLeds<WS2812B, DATA_PIN_3, GRB>(leds1, NUM_LEDS);
	FastLED.addLeds<WS2812B, DATA_PIN_4, GRB >(leds2, NUM_LEDS);

	//FastLED.addLeds<WS2812B, DATA_PIN_3, GRB >(fast_leds3, NUM_LEDS_FAST);  // test
	//FastLED.addLeds<WS2812B, DATA_PIN_4, GRB >(fast_leds4, NUM_LEDS_FAST);




	//controllers[0] = &FastLED.addLeds<WS2811, DATA_PIN>(leds, NUM_LEDS);
	//controllers[1] = &FastLED.addLeds<WS2811, DATA_PIN_FAST>(fast_leds, NUM_LEDS_FAST);


	// FastLED.addLeds<WS2812, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<WS2812B, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);
	// FastLED.addLeds<APA104, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<UCS1903, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<UCS1903B, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<GW6205, DATA_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<GW6205_400, DATA_PIN, RGB>(leds, NUM_LEDS);

	// FastLED.addLeds<WS2801, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<SM16716, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<LPD8806, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<P9813, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<APA102, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<DOTSTAR, RGB>(leds, NUM_LEDS);

	// FastLED.addLeds<WS2801, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<SM16716, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<LPD8806, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<P9813, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<APA102, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);
	// FastLED.addLeds<DOTSTAR, DATA_PIN, CLOCK_PIN, RGB>(leds, NUM_LEDS);






	// The next 3 pins allow me to set up 3 controllers each with a different number of LEDs
	//pinMode(DATA_PIN_AUX, INPUT);
	//pinMode(DATA_PIN_FAST, INPUT);   // initially high impedance
	pinMode(DATA_PIN_1, INPUT);
	pinMode(DATA_PIN_2, INPUT);
	pinMode(DATA_PIN_3, INPUT);
	pinMode(DATA_PIN_4, INPUT);

	//pinMode(DATA_PIN_3, OUTPUT);    // TEST
	//pinMode(DATA_PIN_4, OUTPUT);

	pinMode(Hall, INPUT);
	pinMode(Hall_out, OUTPUT);

	digitalWrite(Hall_out, LOW);

	pinMode(HEAD_COM, INPUT);  // a HIGH signals head to COME_HITHER

	/*pinMode(MOSI, OUTPUT);
	pinMode(MISO, INPUT);
	pinMode(SCK, OUTPUT);
	pinMode(SS, OUTPUT);*/



	attachInterrupt(digitalPinToInterrupt(Hall), INC_HALL_COUNT, FALLING);


	randomSeed(analogRead(0));

	FastLED.clear();  // set to black all LEDs..

	for (int n = 0; n < NUM_LEDS; ++n)
	{
		/*leds_save1[n] = 0;
		leds_save2[n] = 0;
		leds_save3[n] = 0;
		leds_save4[n] = 0;
		leds_save5[n] = 0;
		leds_background[n] = 0;*/

		for (byte k = 0; k < 6; ++k)
		{
			leds_saved[k][n] = 0;
		}
	}

	//******************* DON_COM setup *************************************
		// this is the normal pin mapping and is only altered if the MASTER is receiving data from SLAVE or if SLAVE is writing data to MASTER
	G_DC_M0 = DC_M0_PIN;
	G_DC_M1 = DC_M1_PIN;
	G_DC_S0 = DC_S0_PIN;
	G_DC_S1 = DC_S1_PIN;

	pinMode(DC_M0_PIN, OUTPUT);
	pinMode(DC_M1_PIN, OUTPUT);
	pinMode(DC_S0_PIN, INPUT);
	pinMode(DC_S1_PIN, INPUT);

	digitalWrite(DC_M0_PIN, HIGH);
	digitalWrite(DC_M1_PIN, HIGH);

	//***********************************************************************



	//Serial.println("before MAP_ARRAY: BMP_MAP[0]");
	MAP_FONT_ARRAY();  // map the bitmap array and store the index for each bitmap, the array position is the bitmap number starting with #1
	MAP_BMP_ARRAY();

	//Serial.println("after MAP_ARRAY: BMP_MAP[0]");
//	Serial.println(BMP_MAP[0]);

//Serial.print("start of loop: BMP_MAP[0]");
//Serial.println(BMP_MAP[0]);
//Serial.print("start of loop: BMP_MAP[1]");
//Serial.println(BMP_MAP[1]);
//Serial.print("start of loop: BMP_MAP[2]");
//Serial.println(BMP_MAP[2]);

	DISPLAY_RESET_IMAGE(1);

	delay(CALIBRATION_INTERVAL);  // allow time for 5V regulator to come up, was 5000



	// if (SYNC_IT == 1) {
	//	delay(20000);    // allow time to spin up...20 seconds
	//}

//READ_BRIGHTNESS();  // read the G_brightness knob
//G_dim = 128;   // need to delete this afer I check out A2D


					/*
					G_bright = analogRead(sensorPin);
					// set up for a 8 position pot
					if (G_bright >= 1022) { shift = 0; }  // max value of G_brightness = 1023
					if ((G_bright < 1022) && (G_bright >= 876)) { shift = 1; }
					if ((G_bright < 876) && (G_bright >= 730)) { shift = 2; }
					if ((G_bright < 730) && (G_bright >= 584)) { shift = 3; }
					if ((G_bright < 584) && (G_bright >= 438)) { shift = 4; }
					if ((G_bright < 438) && (G_bright >= 292)) { shift = 5; }
					if ((G_bright < 292) && (G_bright >= 146)) { shift = 6; }
					if (G_bright < 146) { shift = 7; }
					*/

					//	activate_fast();


	Serial.println(F("POSITION 1"));    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++




	//activate_fast();  // high Z output pins
	//SET_FAST();  // only show FAST leds 



	CALIBRATE_MAX_FLASHES(4);



	//delay(1000);
	CLEAR_ALL_LEDS();
	SHOW_slow();

	Serial.println(F("POSITION 2"));    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



	//stored_max_flashes holds measured data on the maximum number of FastLED.show(); that can be done for index*22 leds; this data was measured with text number 28
	stored_max_flashes[0] = 72;  // set for completeness
	stored_max_flashes[1] = 72;
	stored_max_flashes[2] = 72;
	stored_max_flashes[3] = 72;
	stored_max_flashes[4] = 60;
	stored_max_flashes[5] = 48;
	stored_max_flashes[6] = 40;
	stored_max_flashes[7] = 36;
	stored_max_flashes[8] = 30;
	stored_max_flashes[9] = 28;
	stored_max_flashes[10] = 24;
	stored_max_flashes[11] = 22;
	stored_max_flashes[12] = 20;
	stored_max_flashes[13] = 20;
	stored_max_flashes[14] = 18;
	stored_max_flashes[15] = 16;
	stored_max_flashes[16] = 16;
	stored_max_flashes[17] = 14;
	stored_max_flashes[18] = 14;
	stored_max_flashes[19] = 14;
	stored_max_flashes[20] = 12;
	stored_max_flashes[21] = 12;
	stored_max_flashes[22] = 12;

	////////////////////////////  test only  ////////////////////
	//int single_max = HALL_MEASURE2(2 * NUM_ROWS);
	//int calculated_max = CALCULATED_MAX_FLASHES(2 * NUM_ROWS);

	//Serial.begin(115200);
	//while (!Serial); // wait for serial port to connect. Needed for native USB
	//Serial.println(F("OK"));
	//Serial.println(F("second OK"));


	//int forever = 1;
	//while (forever == 1)
	//{
	//	Serial.print(F("G_startup_max_flashes ="));
	//	Serial.println(G_startup_max_flashes);
	//	Serial.print(F("single_max ="));
	//	Serial.println(single_max);
	//	Serial.print(F("calculated_max ="));
	//	Serial.println(calculated_max);
	//	delay(1000);
	//}
	//////////////////////////////////////////////////////////////////////////



	//if ((G_enable_GUI_generator == 1) && (G_BT_connected_flag == 1))
	//{
	//	switch (G_GUI) {
	//	case 1:
	//		GUI();
	//		break;
	//	case 2:
	//		GUI2();
	//		break;
	//	case 3:
	//		GUI3();
	//		break;
	//	default:
	//		// statements
	//		break;
	//	}

	//	G_BT_connected_flag = 2;
	//}

	if ((G_production == 1) && (G_GUI == 3)) { MODIFY_GUI3(10); }  // set correct production button

	if ((G_production == 2) && (G_GUI == 3)) { MODIFY_GUI3(11); }  // set correct production button

	if ((G_production == 3) && (G_GUI == 3)) { MODIFY_GUI3(12); }  // set correct production button



	for (int n = 0; n < NUM_LEDS; ++n)  // initialize bounce array
	{
		bounce[n] = 0;  // signed 7 bit value....0 means no bounce
	}

	G_system_time = millis();  // initialize

	if (G_GUI == 3)
	{
		G_special_slider = 1;  // to guarentee 1st position is active at start
	}

	Serial.println(F("LEAVING SETUP"));    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

}

void loop()
{

	Serial.println(F("start of loop"));
	Serial.print(F("G_production="));
	Serial.println(G_production);
	Serial.print(F("G_TEST="));
	Serial.println(G_TEST);
	Serial.print(F("G_forced_production="));
	Serial.println(G_forced_production);
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);
	Serial.println("");

	///// **** TEST ONLY **** //////////
	//G_dim = 253;   /// for TEST ONLY
	///////////////////////////////////

	//MAP_FONT_ARRAY();  // map the bitmap array and store the index for each bitmap, the array position is the bitmap number starting with #1
	//Serial.print("after MAP_ARRAY: BMP_MAP[0]");
	//Serial.println(BMP_MAP[0]);


//	G_BT_interrupt = 0; // allow for SHOW_var to display   // just commented out 11/30/21


	//if ((G_BT_connected_flag == 1) && (G_enable_GUI_generator == 0))
	if (G_BT_connected_flag == 1)
	{
		SerialBT.print("*LR0G255B0*");  // turn show indicator GREEN initally
		//		RESET();


		G_BT_connected_flag = 2;
	}

	if ((G_enable_GUI_generator == 1) && (G_BT_connected_flag == 2) && (G_do_once == 0))
	{
		G_do_once = 1;

		RESET(1);  // reset and load GUI


	}


	//if ((G_BT_connected_flag == 2) && (G_enable_GUI_generator == 1))
	//{
	//	SerialBT.print("*LR0G255B0*");  // turn show indicator GREEN initally
	//	G_BT_connected_flag = 3;
	//}



	//activate_fast();

	++G_pass;   // keeps track of number of times LOOP() is called

	int kind = 1; // keeps track of what the data I'm retriving form the BMP_array is: kind = 1 for marker, kind=2 for speed, kind= 3 for high byte adr, kind = 4 for low byte adr,
	// kind = 5  RED data or GREEN data or BLUE data

	int led_adr = 0;   // led address 
	int bmp_speed = 1;  // frame speed
	int H_led_adr = 0;
	int L_led_adr = 0;
	int index = -1;  // index into BMP_array

	leave_flag = 0;
	G_bmp_num = 1;  // keeps track of bitmap number

	//if (image_count==1)    // ***** NOTE: this is an experiment to see if syncing when images are delayed works
	//{
	//	Serial.println("FORCE_SYNC");

	if (G_TEST > 0)
	{
		Serial.println("loop(): POSITION 3");    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		DO_TEST();  // run test 
	}



	G_bmp_num = 1;

	if (G_TEST == 0) // ************************  DO_PRODUCTION_#  **************************************************
	{

		if (G_beginning_SHOW_flag == 0)  // only execute this  once
		{
			HALL_MEASURE2(NUM_LEDS);  // find G_max_flashes

			FastLED.clear();

			SHOW_slow();

			G_beginning_SHOW_flag = 1;

			//	TRANSFER2_FAST();   ///// MASTER has control at first
		}





		//////////////////////////////////////////  PRODUCTION HANDLER  //////////////////////////////////////////////
		Serial.println(F("** PRODUCTION HANDLER START  **"));
		Serial.println("");
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);

#define NUMBER_OF_PRODUCTIONS 5
#define NUMBER_OF_TIMES_TO_EXECUTE_PRODUCTION3 2


		byte allow = 0;

		static byte previous_production = 0;
		static int previous_show_num = -1;
		byte music_detect = 0;

		if (G_BT_message_flag == 0)
		{
			G_BT_message_flag = CHECK_BLUE_TOOTH();

			/*Serial.println("In DO_SHOW2 after CHECK_BLUE_TOOTH");
			Serial.print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= ");
			Serial.println(G_BT_message_flag);
			Serial.println("");*/
		}

		if (G_BT_message_flag == 1)
		{




			Serial.println(F("PRODUCTION HANDLER start"));
			Serial.print(F("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= "));
			Serial.println(G_BT_message_flag);
			Serial.println("");
			Serial.print(F("G_message= "));
			Serial.println(G_message);
			Serial.print(F("G_BT_command= "));
			Serial.println(G_BT_command);
			Serial.println("");



			BLUE_TOOTH_COMMAND_HANDLER(1);  // execute the BT command  ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

			delay(50);


		}


		////////////////////

		//Serial.println(F(""));
		//Serial.print(F("$$$$$$$$$ 2: G_dim= "));
		//Serial.println(G_dim);
		//Serial.println(F(""));

		// detect if the BASE is trying to communicate with the HEAD through the A2D port and if YES then execute COME_HITHER_SHOW() until another BASE signal is received
		DETECT_BASE_COMMUNICATION_and_COME_HITHER();

		//Serial.println(F(""));
		//Serial.print(F("$$$$$$$$$ 3: G_dim= "));
		//Serial.println(G_dim);
		//Serial.println(F(""));


		/////////////////////


		if ((G_force_sound_productions != -1) && (G_TEST == 0) && (G_CREATE_mode == 0) && ( G_MIC_ON_flag ==1)) // execute unless SOUND productions are not allowed, not in CREATE mode
		{
			//Serial.println(F("** loop(): position 1a **"));
			//Serial.print(F("G_sampling_period_us= "));
			//Serial.println(G_sampling_period_us);

			//Serial.println("");
			//Serial.println(F("** just before music_detect: main loop **"));
			//Serial.println("");

			//music_detect = MUSIC_DETECT(50);
			music_detect = MUSIC_DETECT(MUSIC_DETECTION_INTERVAL, MUSIC_DETECTION_COUNT);  // was 100

			//if (G_music_only_switch == 1) 
			//{ 
			//	music_detect = 1; // FORCE MUSIC 
			//	
			//}  

			SPACE
			Serial.print(F("MAIN LOOP   ** position 1b **:  music_detect ="));
			Serial.println(music_detect );
			SPACE

			
			//if (music_detect == 1)
			//{
			//	G_music_start_time = millis();  // keep track of last MUSIC detection time

			//	//	 Serial.println(F("** position 1c **"));
			//}

			// Serial.println(F("** position 1d **"));


		//	if ((music_detect == 1) || (G_sound_detected_flag > 1)) // SOUND detected, note: G_sound_detected_flag is incremented inside SOUND productions if there is sound
			if (music_detect == 1)  // MUSIC detected
			{
				//Serial.println(F("**** in main loop(): position 1.5"));
				//Serial.print(F("music_detect="));
				//Serial.println(music_detect);
				//Serial.print(F("G_sound_detected_flag="));
				//Serial.println(G_sound_detected_flag);
				//Serial.print(F("G_production="));
				//Serial.println(G_production);
				//Serial.print(F("G_force_sound_productions="));
				//Serial.println(G_force_sound_productions);
				//Serial.println("");



				//if (G_force_sound_productions == 0)  // allow for SOUND detect to trigger SOUND productions
				if (G_force_sound_productions != -1)  // allow for SOUND detect to trigger SOUND productions, note: -1 will exclude sound production
				{
					G_force_sound_productions = 1;  // do sound productions

					previous_show_num = G_show_num;  // allow for return to previous show if SOUND goes away  
					G_show_num = 0;  // restart shows

					if (G_production < FIRST_SOUND_PRODUCTION)
					{
						previous_production = G_production;
						G_production = FIRST_SOUND_PRODUCTION; // set to start of SOUND productions
					}
					//else
					//{
					//	previous_production = 0;  // there is no production 0
					//}

				}
			}

			Serial.println("");
			Serial.print(F("MAIN LOOP    ** position 2 **: millis() - G_music_start_time= "));
			double ctime = millis();  // for test only
			Serial.println(ctime - G_music_start_time);
			Serial.println("");

			//if (((millis() - G_music_start_time > NO_MUSIC_TIME) && (G_production >= FIRST_SOUND_PRODUCTION) && (G_production <= LAST_SOUND_PRODUCTION)) && (G_forced_production != 0)) // no sound detected so return to previous shows, sound productions are >2

			// check if need to exit SOUND productions
			if (((millis() - G_music_start_time > NO_MUSIC_TIME) && (G_production >= FIRST_SOUND_PRODUCTION) && (G_production <= LAST_SOUND_PRODUCTION)) && (G_forced_production == 0)&&((G_music_only_switch ==0))) // no sound detected so return to previous shows, sound productions are >2
			{

				G_force_sound_productions = 0; // set to 1 to force PRODUCTIONS that utilize SOUND, set to -1 to exclude SOUND productions, set to 0 to let SOUND trigger SOUND productions
				G_production = DEFAULT_PRODUCTION;
				G_show_num = 0;  // get incremented before next show


				// clear disply
				SET_SLOW();
				FastLED.clear();
				SHOW_slow();

				//if (previous_production > 0)  // only execute this if SOUND had previously been detected
				//{
				//	G_show_num = previous_show_num;
				//	G_production = previous_production;
				//	previous_production = 0;
				//}

				Serial.println(F("----)))--->NO MUSIC DETECTED"));
				Serial.println(F(""));
			}
		}

		//	Serial.println(F("** position 3 **"));

		if (G_forced_production > 0)  // forced PRODUCTION
		{
			if (G_forced_production <= NUMBER_OF_PRODUCTIONS)
			{
				G_production = G_forced_production;
				allow = 1;   // allow for either SOUND or non-SOUND productions to be forced
			}
		}

		//LABEL_PRODUCTION_BUTTON();

		//SerialBT.print("*I");  // update production number
		//SerialBT.print(G_production);
		//SerialBT.print("*");

		MODIFY_GUI4(18); // update production number

		UPDATE_PRODUCTION_NAME();

		// below was removed on 070924 because only MUSIC_DETECT can change G_MUSIC_detected_flag
		//if (G_production < FIRST_SOUND_PRODUCTION)
		//{
		//	G_MUSIC_detected_flag = 0;
		//	MODIFY_GUI4(17); // turn on/off MUSIC DETECT indicator
		//}

		byte rv = 0;

		Serial.println(F("** in main loop(): position 3"));
		Serial.print(F("G_production="));
		Serial.println(G_production);
		Serial.print(F("music_detect="));
		Serial.println(music_detect);
		Serial.print(F("G_sound_detected_flag="));
		Serial.println(G_sound_detected_flag);
		Serial.print(F("G_force_sound_productions="));
		Serial.println(G_force_sound_productions);
		Serial.print(F("allow="));
		Serial.println(allow);
		Serial.println(F(""));

		G_sound_detected_flag = 0;

		if ((G_force_sound_productions <= 0) || (allow == 1))  // G_force_sound_productions: NO SOUND productions (-1) or sound triggered productions (0)
		{

			if (G_production == 1)  // a no sound production
			{
				rv = PRODUCTION_1();   // run my pre-scripted show
			}
			if (G_production == 2)  // a no sound productoin
			{

				rv = PRODUCTION_2();   // run my pre-scripted cylindracal coordinate show

			}
		}



		if ((G_force_sound_productions == 1) || (allow == 1))  //  SOUND productions
		{


			if (G_production == FIRST_SOUND_PRODUCTION)  // FFT production
			{
				Serial.println(F("---> main loop: just prior to P3 execution"));
				//Serial.println(F(""));

				rv = PRODUCTION_3();   // run FFT

				if (rv == 1)
				{
					++G_production3_counts;
					rv = 0;
				}

				if (G_production3_counts >= NUMBER_OF_TIMES_TO_EXECUTE_PRODUCTION3)
				{
					rv = 1;  // go onto next production
					G_production3_counts = 0;
				}

			}



			if (G_production == FIRST_SOUND_PRODUCTION + 1)  // beat detect show: PRODUCTION 4
			{
				//Serial.println(F("---just before production4"));
				//Serial.print(F("G_show_num="));
				//Serial.println(G_show_num);
				//Serial.println(F(""));

				rv = PRODUCTION_4();   // run beat detector
			}


			if (G_production == FIRST_SOUND_PRODUCTION + 2)  // MNOTE NOTE detection : PRODUCTION 5
			{
				//Serial.println(F("---just before production4"));
				//Serial.print(F("G_show_num="));
				//Serial.println(G_show_num);
				//Serial.println(F(""));

				rv = PRODUCTION_5();   // run beat detector
			}
		}


		/// ***  next production control  ***  ///////////////////

		music_detect = MUSIC_DETECT(MUSIC_DETECTION_INTERVAL, MUSIC_DETECTION_COUNT);  // added 12/16/23, was 50
		//music_detect = MUSIC_DETECT_old(50);  // added 12/16/23

		if ((rv == 1) && (G_forced_production == 0)) // next production
		{

			++G_production;

			if ((music_detect == 0) && (G_sound_detected_flag == 0)) // no sound ... therefore no production >2
			{
				if (G_production >= FIRST_SOUND_PRODUCTION)
				{
					G_production = 1;
				}
			}



			if (G_start_next_production_flag == 0)
			{
				Serial.print(F(" )))))))))-->   incrementing G_production="));
				Serial.println(G_production);
				Serial.println(F(""));
			}

			if (G_start_next_production_flag == 1)
			{
				G_start_next_production_flag = 0;
				G_production = G_next_production;


				Serial.print(F(" )))))))))-->  G_start_next_production_flag=1:   G_production="));
				Serial.println(G_production);
				Serial.println(F(""));

			}



			if ((G_CREATE_mode == 1) && (G_production >= FIRST_SOUND_PRODUCTION))  // no sound productions in CREATE mode
			{
				G_production = 1;


			}



			if (G_production > NUMBER_OF_PRODUCTIONS) { G_production = 1; }

			////G_force_sound_productions: set to 1 to force PRODUCTIONS that utilize SOUND, set to -1 to exclude SOUND productions, set to 0 to let SOUND trigger SOUND productions
			if ((G_force_sound_productions == 1) && (G_production < FIRST_SOUND_PRODUCTION))  // SOUND productions only
			{
				Serial.println(F(" loop:  setting G_production=3"));
				Serial.print(F("music_detect="));
				Serial.println(music_detect);
				Serial.print(F("G_sound_detected_flag="));
				Serial.println(G_sound_detected_flag);
				Serial.println(F(""));

				G_production = FIRST_SOUND_PRODUCTION;  // note: 3 = 1'st SOUND production
			}

			if ((G_force_sound_productions == -1) && (G_production >= FIRST_SOUND_PRODUCTION))  // exclude SOUND productions
			{
				G_production = 1;
			}

			SerialBT.print("*I");  // update production number
			SerialBT.print(G_production);
			SerialBT.print("*");

			UPDATE_PRODUCTION_NAME();

			Serial.println(F(""));
			Serial.print(F(" *** PRODUCTION *** : G_production = "));
			Serial.println(G_production);
			Serial.println(F(""));

			G_show_num = 0;  // restart shows

		}



	}

}

////////////////////////////  FUNCTIONS  ////////////////////////////////////

/************************************************************************************************************************/
int modify_adr(int usd, int H_adr, int L_adr)  // function to make the image upside down if usd=1
{


	if (usd == 1)
	{
		return((256 * H_adr) + L_adr);

	}
	else
	{

		int led_adr_norm = (256 * H_adr) + L_adr;
		int column = (led_adr_norm / 22);
		return((column * 44) + 21 - led_adr_norm);  // modififed LED address

		/*
		Serial.print("**********");
		Serial.print("led_adr_norm=");
		Serial.println(led_adr_norm);
		Serial.print("     column=");
		Serial.println(column);
		Serial.print("     led_adr=");
		Serial.println(led_adr);
		*/
	}
}

/*********************************************************************************************************************/
void DO_TEST()
// This test function can be used for anything you want to test. Use it in place of DO_SHOW()
{

	static byte one_time = 0;

	//Serial.println(F("DO_TEST  start"));    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// ------------------->   TEST DESCRIPTIONs  <---------------------------------------------------------
//  G_test_number = 7;   //** panel centering  **
//	if (G_test_number == 51)  // test FFT, generate MNOTE data
//  if (G_test_number == 52)  // test NOTE_DETECT: also un-comment Serial.prints in FIND_MAX_CORRELATION_VALUE()
//  if (G_test_number == 53)  // test fade
//  if (G_test_number == 54)  // test BEAT_NOTE
 // test 56: check panel tilt alignment

// ----------------------------------------------------------------------------------------------------



	/// IMPORTANT NOTE: the next line necessary if there is to be no streaking of TEXT or GRAPHICS
	G_RESET = 0; // clear RESET in SLAVE

	//*******************************************************
	//G_test_number = 7;   //** panel centering  **
	//*******************************************************

//	if (one_time == 0)  // only need for tests 48 and 49
	{
		one_time = 1;
		G_test_number = G_TEST;
	}

	//G_test_number = 18;



	//G_test_number = 6;  // for mini show
	//G_test_number = 13; // defines which test is to be run
	//G_test_number = 6; // defines which test is to be run

	//G_test_number = 0; // for TRANSFER2SLOW

	int led_adr = 0;


	//FastLED.clear();  // set to black all LEDs.
	//FastLED.show();

	////////////////////////////////////////////////////////////////
	// bare bones panel test
	if (G_test_number == 1)  // bare bones panel test
	{
#define PANEL_TEST_TYPE 2  // 1= xy test, 2=raw address scan test
		
		int adr = 0;
		int adr2 = 0;
		//static byte do_once = 0;

		Serial.println(F("TEST 1"));
		Serial.println("");

		//DISPLAY_RESET_IMAGE(2);

	//	if (do_once == 0)
		{
			SET_SLOW();
//			do_once = 1;
			FastLED.clear();
		}

		if (PANEL_TEST_TYPE == 1)  //// x, y test
		{
			//// x, y test
			// display one pixel at a time
			for (int x = 0; x < 22; ++x)
			{
				for (int y = 0; y < 22; ++y)
				{
					adr = XY_ADR(x, y);
					adr2 = modify_adr(0, 0, adr);

					leds1[adr] = CHSV(0, 255, 255);  // red
					leds3[adr] = CHSV(85, 255, 255);  // green

					leds2[adr2] = CHSV(42, 255, 255);  // yellow
					leds4[adr2] = CHSV(171, 255, 255);  // blue

					SHOW_slow();
					delay(20);
					FastLED.clear();

				}


			}
		}


		if (PANEL_TEST_TYPE == 2)  //// raw address scan test
		{
			for (int adr = 0; adr < 22 * 22; ++adr)
			{
				leds1[adr] = CHSV(0, 255, 255);  // red

				if (adr == 0)
				{
					leds1[adr] = CHSV(171, 255, 255);  // blue to start
				}


				SHOW_slow();
				delay(20);
				FastLED.clear();
			}


		}


		//SET_VAR(4 * 22);
		//FastLED.clear();
		//SET_SLOW();


	}


	/////////////////////////////////////////////////////////////
	if (G_test_number == 2)  // find G_max_flashes
	{
		HALL_MEASURE2(22 * 22);

		SPACE
		printD("DO_TEST: G_max_flashes ="), G_max_flashes);
		SPACE


	}


	////////////////////////////
//	 // test tween
//	if (G_test_number == 2)  // test tween
//	{
//		byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
//		byte image_kind = 0;  // image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
//		byte total_increments = 3;  // number of images created between the two base sets, was 5
//		int time_between_frames = 1000;
//		byte bounce_cycles = 2;  // 
//		static byte active_increment = 0;  // which of the total increments is active for this beat
//		byte previous_increment = 0;  // previously active increment
//		int direction = 1;
//		static byte do_once = 1;
//
//		/////////// BANK 0 ///////////////////
//		///////// zig_zag bottom
//
//		TWEEN_IMAGE_START[0].IMAGE_KIND = 7;
//		TWEEN_IMAGE_START[0].XS = 0;
//		TWEEN_IMAGE_START[0].YS = 0;
//		TWEEN_IMAGE_START[0].XE = 21;
//		TWEEN_IMAGE_START[0].YE = 0;
//		TWEEN_IMAGE_START[0].HUE = 171;
//		TWEEN_IMAGE_START[0].DATA1 = 4;   // peaks
//		TWEEN_IMAGE_START[0].DATA2 = 4;  // amplitude
//
//		TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
//		TWEEN_IMAGE_START[1].XS = 0;
//		TWEEN_IMAGE_START[1].YS = 0;
//		TWEEN_IMAGE_START[1].XE = 0;
//		TWEEN_IMAGE_START[1].YE = 21;
//		TWEEN_IMAGE_START[1].HUE = 42;  // yellow
//		TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
//		TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
//		TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow
//
//
//
//		/////////////////////////
//
//		/////////// BANK 1 ///////////////////
//
//
//
//		TWEEN_IMAGE_END[0].IMAGE_KIND = 7;  //zig_zag
//		TWEEN_IMAGE_END[0].XS = 0;
//		TWEEN_IMAGE_END[0].YS = 21;
//		TWEEN_IMAGE_END[0].XE = 11;
//		TWEEN_IMAGE_END[0].YE = 21;
//		TWEEN_IMAGE_END[0].HUE = 0;
//		TWEEN_IMAGE_END[0].DATA1 = 2;   // peaks
//		TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude
//
//		TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
//		TWEEN_IMAGE_END[1].XS = 0;
//		TWEEN_IMAGE_END[1].YS = 0;
//		TWEEN_IMAGE_END[1].XE = 0;
//		TWEEN_IMAGE_END[1].YE = 21;
//		TWEEN_IMAGE_END[1].HUE = 42;
//		TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
//		TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
//		TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow
//
//		////////
//
//
//
//
//		////////
//
//		image_kind = 0;  // use stored image kind
//
//		FastLED.clear();  // clear interior image
//
//		for (byte n = 0; n <= total_increments; ++n)
//		{
//
//			TWEEN(image_kind, number_of_images, total_increments, n, STARTING_IMAGE_HUE, direction);
//
//			SHOW_slow();
//			delay(500);
//		}
//
//
//
//		///////////////*****************  new code for beat show ************************
//
//
//
//	}
//
//
//	//	///////////////////////////////////////////////////////////////
//	// test BEAT_SHOW
//	if (G_test_number == 3)  // test BEAT_SHOW
//	{
//
//		byte test_old_flag = 0;  // set to 1 to check old BEAT_SHOW
//		byte leave_trace_flag = 0;  // set to 1 to leave traces 
//
//		byte modulus = 1;
//		byte enable = 1;
//		byte total_increments = 8;  // previously skip_beats
//		byte temporary = 0;
//		//byte image_kind = RANDOM_IMAGE_KIND;  // 0=stored image kind  <---------------------------------
//		byte image_kind = 0;  // 0=stored image kind
//		int hue_code = STARTING_IMAGE_HUE;
//		byte repeat_count = 0;  // keeps track of how many time a BS is played before moving on
//#define NUMBER_OF_BS_REPEATS 2  // sets how many time BS is repeated
//		byte enable_index = 0;
//
//		if (test_old_flag == 1)
//		{
//			temporary = modulus;
//			modulus = total_increments; // sets the number of increments
//			total_increments = temporary; // previously skip_beats
//
//		}
//
//		// HUE CODES
//////#define ERASE_IMAGE 999 
//////#define BLEND_START_END_HUE 1000
//////#define STARTING_IMAGE_HUE 2000
//////#define ENDING_IMAGE_HUE 3000
//
//		//int hue = 171 + ENDING_IMAGE_HUE; //   171; // blue
//		//int hue2 = 85 + ENDING_IMAGE_HUE; // green
//
//		int hue1 = 85;  // blue, 171
//		int hue2 = 171; // yellow, 42
//		int hue3 = 171;
//		int hue4 = 85;
//
//
//		int hue = 0;
//
//
//		byte rv1 = 1;
//		byte rv2 = 1;
//		byte rv3 = 1;
//		byte rv4 = 1;
//
//		byte new_randoms_flag = 1;  // set to 1 to re-initialize random numbers in BEAT_SHOW_RAND1
//
//
//		FastLED.clear();
//
//		// initialize
//		for (byte n = 0; n < NUMBER_OF_BEAT_SHOWS; ++n)
//		{
//			BS_enables[n] = 0;
//		}
//
//
//		for (byte beat = 0; beat < 6000; ++beat)
//		{
//
//			if (beat % total_increments == 0)
//			{
//				++repeat_count;
//
//				// control enables to cycle though each BS
//
//
//				if (repeat_count > NUMBER_OF_BS_REPEATS)
//				{
//					repeat_count = 0;
//					++enable_index;
//
//					if (enable_index >= NUMBER_OF_BEAT_SHOWS)
//					{
//						BS_enables[NUMBER_OF_BEAT_SHOWS - 1] = 0;
//
//						enable_index = 0;
//						BS_enables[enable_index] = 1;
//					}
//					else
//					{
//						BS_enables[enable_index] = 1;  // enable next show
//
//						if (enable_index > 0)
//						{
//
//							BS_enables[enable_index - 1] = 0;  // clear previous enable
//						}
//					}
//
//				}
//
//				if (G_GUI == 4)
//				{
//					SerialBT.print("*!");  // update GUI4 text with which BS is playing
//					SerialBT.print(enable_index);
//					SerialBT.print("*");
//				}
//
//			}
//
//
//
//
//			//////////////////// hue control  /////////////////////////////////////////////
//			//hue1 = hue1 + 5;
//			//hue2 = hue2 + 10;
//
//			//if (hue1 > 255) { hue1 = 0; }
//			//if (hue2 > 255) { hue2 = 0; }
//
//			// hue1 = HUE_TRANSITION2(0, 85, total_increments, beat % total_increments);
//			// hue2 = HUE_TRANSITION2(85, 0, total_increments, beat % total_increments);  // smooth transition
//			hue3 = HUE_TRANSITION2(171, 213, total_increments, beat % total_increments);  // smooth transition
//			hue4 = HUE_TRANSITION2(0, 213, total_increments, beat % total_increments);  // smooth transition
//			///////////////////////////////////////////////////////////////////////////////////////
//
//
//			delay(0);  // 150
//
//			//////////////////////////// NEW BEAT SHOW  ///////////////////////////////////////////////////////
//			if (test_old_flag == 0)
//			{
//				if (((beat % total_increments) == 0) && (leave_trace_flag == 1))
//				{
//					FastLED.clear();
//					delay(200);  // to delineate 
//				}
//
//				if (leave_trace_flag == 0)
//				{
//					FastLED.clear();
//
//				}
//
//				// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
//				//3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes with axis, 9=spike no axix
//
//				byte image_kind = 4;   // image_kind= 0 use stored image kind
//				int hue_forced = 0;
//
//				//BEAT_SHOW_17(beat, 1, 1, total_increments, image_kind, hue1, hue2, hue_forced, 0, 0, 0);
//				//BEAT_SHOW_19(beat, 1, 1, total_increments, 0, hue1, hue2, hue_code);
//
//				image_kind = 0;
//
//				BEAT_SHOW_ALL(beat, total_increments, hue_code);
//
//				//BEAT_SHOW_0(beat, 1, BS_enables[0], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_1(beat, 1, BS_enables[1], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_2(beat, 1, BS_enables[2], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_3(beat, 1, BS_enables[3], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_4(beat, 1, BS_enables[4], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_5(beat, 1, BS_enables[5], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_6(beat, 1, BS_enables[6], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_7(beat, 1, BS_enables[7], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_8(beat, 1, BS_enables[8], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_9(beat, 1, BS_enables[9], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_10(beat, 1, BS_enables[10], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_11(beat, 1, BS_enables[11], total_increments, image_kind, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_12(beat, 1, BS_enables[12], 5, image_kind, hue1, hue2, hue_code);
//				//BEAT_SHOW_13(beat, 1, BS_enables[13], 5, image_kind, hue1, hue2, hue_code);
//				//BEAT_SHOW_14(beat, 1, BS_enables[14], 4, image_kind, hue1, hue2, hue_code);
//				//BEAT_SHOW_15(beat, 1, BS_enables[15], 4, image_kind, hue1, hue2, hue_code);
//				//BEAT_SHOW_16(beat, 1, BS_enables[16], 4, image_kind, hue1, hue2, hue_code);
//				//BEAT_SHOW_17(beat, 1, BS_enables[17], total_increments, 0, hue1, hue2, hue_code, 0, 0, 0);
//				//BEAT_SHOW_18(beat, 1, BS_enables[18], total_increments, 0, hue1, hue2, hue_code);
//				//BEAT_SHOW_19(beat, 1, BS_enables[19], total_increments, 0, hue1, hue2, hue_code);
//				////////////////////re-used but changed
//				//BEAT_SHOW_16(beat, 1, BS_enables[20], 4, 9, hue1, hue2, hue_code);  // forced kind=9
//				//BEAT_SHOW_5(beat, 1, BS_enables[21], total_increments, 5, hue1, hue2, hue_code, 0, 0, 0);   // forced kind=5
//				//BEAT_SHOW_8(beat, 1, BS_enables[22], total_increments, 3, hue1, hue2, hue_code, 0, 0, 0); // forced kind=3
//				//BEAT_SHOW_10(beat, 1, BS_enables[23], total_increments, 3, hue1, hue2, hue_code, 0, 0, 0); // forced kind=3
//
//
//
//
//				//BEAT_SHOW_13(beat, 1, enable, 5, 0, hue1, hue2, STARTING_IMAGE_HUE);
//				//rv1 = BEAT_SHOW_RAND(beat, 1, 1, total_increments, RANDOM_IMAGE_KIND, hue1, hue2, STARTING_IMAGE_HUE, rv1, 0);
//
//				//BEAT_SHOW_11(beat, 1, enable, total_increments, image_kind, hue1, hue2, STARTING_IMAGE_HUE, 0, 0, 0 );
//
//				//rv1= BEAT_SHOW_RAND(beat, 1, enable, total_increments, image_kind, hue1, hue2, STARTING_IMAGE_HUE, new_randoms_flag, 0);
//
//				//rv1 = BEAT_SHOW_RAND(beat, 1, enable, total_increments, image_kind, hue1, hue2, STARTING_IMAGE_HUE, rv1, 0);
//				//rv2 =BEAT_SHOW_RAND(beat, 1, enable, total_increments, image_kind, hue1, hue2, ENDING_IMAGE_HUE, rv2, 1);
//
//				//rv1 = BEAT_SHOW_RAND(beat, 1, enable, total_increments, image_kind, hue1, hue2, STARTING_IMAGE_HUE, rv1, 0);
//				//rv2 = BEAT_SHOW_RAND(beat, 2, enable, total_increments, image_kind, hue2, hue2, ENDING_IMAGE_HUE, rv2, 1);
//				//rv3 = BEAT_SHOW_RAND(beat, 1, enable, total_increments, image_kind, hue3, hue3, STARTING_IMAGE_HUE, rv3, 2);
//				//rv4 = BEAT_SHOW_RAND(beat, 2, enable, total_increments, image_kind, hue4, hue4, STARTING_IMAGE_HUE, rv4, 3);
//
//				new_randoms_flag = 0;
//
//				//Serial.print(F("DO_TEST: rv1="));
//				//Serial.println(rv1);
//				//Serial.println(F(""));
//			}
//
//			//////////////////////////////////
//
//			//////////////////////////// OLD BEAT SHOW  ///////////////////////////////////////////////////////
//			if (test_old_flag == 1)
//			{
//				FastLED.clear();
//
//				//BEAT_SHOW_13x(beat, 1, enable, 5, 0, hue1);
//
//				//BEAT_SHOW_5x(beat, 8, enable, 5, 0, 0);
//				//BEAT_SHOW_1x(beat, modulus, enable, total_increments, hue);
//
//				//BEAT_SHOW_1x(beat_count, 1, enable, 8, 0);  // upward moving red cone
//				//BEAT_SHOW_7x(beat, 8, enable, 0, hue1);  // orangish in/out moving tube
//				//BEAT_SHOW_8x(beat, 8, enable, 2, hue1);  // orangish in/out moving tube
//				//BEAT_SHOW_9x(beat, 8, enable, 2, hue1);  // orangish in/out moving tube
//				//BEAT_SHOW_10x(beat, 7, enable, 0, 84);
//				//BEAT_SHOW_11x(beat, 4, enable, 0, 114);
//
//			}
//
//
//
//			SHOW_var(484);
//
//			delay(300);  // to delineate 
//
//		}
//
//
//
//
//
//
//	}
//
//
//	///////////////////////////////////////////////////
//	// load bitmap
//	if (G_test_number == 4)  // load bitmap
//	{
//		int bmp = 1;
//
//		FastLED.clear();
//
//		Serial.print(F(""));
//		Serial.print(F("DO_TEST : test 4="));
//
//		for (int n = 1; n < 5; ++n)
//		{
//			LOAD_BMP(n);
//			//LOAD_BMP(57);
//
//			//LOAD_BMP_PANEL(bmp, 1);
//
//			//Serial.println("before panel 2 load");
//			//Serial.println("");
//
//			//LOAD_BMP_PANEL(bmp, 2);
//
//			//Serial.println("before panel 3 load");
//			//Serial.println("");
//
//			//LOAD_BMP_PANEL(bmp, 3);
//
//			//Serial.println("before panel 4 load");
//			//Serial.println("");
//			//LOAD_BMP_PANEL(bmp, 4);
//
//			Serial.print(F(""));
//			Serial.print(F("DO_TEST : test 4: after LOAD_BMP "));
//			Serial.println("");
//
//			//LOAD_BMP_PANEL(57, 1);
//
//			SHOW_var(484);
//
//			delay(200);  // to delineate 
//
//			Serial.print(F(""));
//			Serial.print(F("DO_TEST:test 4: before BT_CHECKandDO() "));
//			Serial.println("");
//
//			BT_and_DC_CHECKandDO();
//
//			Serial.print(F(""));
//			Serial.print(F("DO_TEST : test 4: after BT_CHECKandDO() "));
//			Serial.println("");
//
//		}
//
//
//	}
//
//
//	//////////////////////////////////////////////////////////////////////////////////////////
//	// test cylindrical coordinates again
//	if (G_test_number == 5)  // test cylindrical coordinates again
//	{
//		byte show_loops = 100;  // number of times this show loops
//		int saved_G_dim = G_dim;
//
//		byte active_columns = 22;  // number of active columns
//		int num_leds = active_columns * 22; // number of active LEDs
//
//		byte depth = 4;
//
//		byte blanks = 5; // number of flashes to ignore at the end to prevent over wrap, was 4
//		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command
//
//		byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color
//
//
//		SET_SLOW();
//		G_dim = DIMMING_INNER;
//
//		G_dim = saved_G_dim;
//
//		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
//		{
//			G_dim = DIMMING_MAX_BRIGHTNESS;
//		}
//
//		num_leds = active_columns * 22; // number of active LEDs
//		SET_VAR(num_leds);
//		blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes
//
//
//		//cylin[0] = { 0, 120,0 };  //radius, angle, z  // center
//		//cylin[1] = { 21,120,10 };
//
//		//radius, angle, z
//		//cylin[0] = { int(10), int(163), 13 };  // 1st end point 
//		//cylin[10] = { 0, int(163), 13 - 5 };  // the -5 adds depth  , 2nd end point anchor at rotation axis
//
//			//radius, angle, z
//		cylin[0] = { int(10), int(90), 13 };  // 1st end point 
//		cylin[10] = { 0, int(90), 13 - 5 };  // the -5 adds depth  , 2nd end point anchor at rotation axis
//
//
//		for (byte sl = 0; sl < show_loops; ++sl)
//		{
//			//if (sl % 4 == 0) // check out the effect if changing depth
//			//{
//			//	++depth;
//			//	if (depth > 21)
//			//	{
//			//		depth = 1; 
//			//	}
//			//}
//
//		
//				///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//			
//			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
//			{
//				
//				
//			
//				//for (int n = 0; n < NUMBER_OF_BOTTOM_VERTICIES; ++n)
//				{
//					FLASH_DRAW_CYLIN_CORDINATES(10, 0, flash, HUES[1], depth);
//				}
//
//
//				//BT_interrupt = SHOW_var_no_dimming(num_leds); // display a variable number of LEDs with no dimming from G_dim
//				BT_interrupt = SHOW_var(num_leds);
//				FastLED.clear();
//
//				if (BT_interrupt != 0) { break; }
//
//			}
//			FastLED.clear();  // remove all streaking during blanking
//			SHOW_var(num_leds);
//
//			blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1
//			if (BT_interrupt != 0) { break; }
//
//			//blanks = 3;   // test only
//		}
//
//		G_dim = saved_G_dim;  // restore dimming
//
//
//
//	}
//
//
//	
//
//
//	//////////////////////// original  
//
//		// text testing
//		if (G_test_number == 6)
//		{
//			////activate_fast();  // high Z output pins
//			//FastLED.clear();  // set to black all LEDs.
//			//// HALL_SYNC2();
//			//SHOW_fast(1, 0);
//	
//	
//			//HALL_MEASURE3(22);  //find G_max_bins
//	
//			//Serial.println("");
//			//Serial.println(F("TEST 6"));
//			//Serial.println("");
//	
//	
//			G_special_char_select = 1;
//	
//			//text_array[0] = { "ABCD123456789" };
//			//strcpy(text_array, "0123456789ABCDEFGHIJKL");
//			//strcpy(scroll_text_array, "MURGETROID 3");
//			strcpy(scroll_text_array, "A    B    C");
//			int stringSize = strlen(scroll_text_array);
//			int hue = -1;  // white
//			SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, hue, 0, 0, 1, 0);
//
//			Serial.println(F(""));
//			Serial.println(F("DO_TEST : test 6: MURGETROID 3"));
//			Serial.println("");
//	
//			//strcpy(scroll_text_array, "~~~~BY DON WILE****");
//			//stringSize = strlen(scroll_text_array);
//			//SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, hue, 2, 0, 1, 0);
//	
//			////char* myStrings[] = { "0123456789ABCDEFGX" };
//			////BT_and_DC_CHECKandDO();
//	
//			////strcpy(text_array, "MURGETROID 3");
//			////stringSize = strlen(text_array);
//			////hue = 1;  // white
//			////SCROLL_TEXT(text_array, stringSize, 1, 1, hue, 0, 1);
//	
//			////strcpy(text_array, "~~BY DON WILE**");
//			////stringSize = strlen(text_array);
//			////SCROLL_TEXT(text_array, stringSize, 1, 1, hue, 2, 1);
//	
//	
//			//BT_and_DC_CHECKandDO();
//	
//			//strcpy(scroll_text_array, "************************");
//			//stringSize = strlen(scroll_text_array);
//			//SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, hue, 2, 1, 1, 0);
//	
//			//strcpy(scroll_text_array, "~~~~~~~~~~~~~~~~~~~~~~~~");
//			//stringSize = strlen(scroll_text_array);
//			//SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, hue, 2, 1, 1, 0);
//	
//			//BT_and_DC_CHECKandDO();
//	
//		}
//	
//
//
//	//	// PANEL centering calibration and alignment
//	if (G_test_number == 7)
//	{
//		//Serial.print(F("TEST 7"));
//
//		DISPLAY_RESET_IMAGE(3);
//
//
//	}
//
//
//	////////////////////// test DIMMING slider
//	if (G_test_number == 8)
//	{
//		G_dim = 0;
//
//		Serial.println("");
//		Serial.print(F("G_dim ="));
//		Serial.println(G_dim);
//		Serial.println("");
//
//		MODIFY_GUI3(1);
//		delay(5000);
//
//		//////////
//
//		G_dim = 254;
//
//		Serial.println("");
//		Serial.print(F("G_dim ="));
//		Serial.println(G_dim);
//		Serial.println("");
//
//		MODIFY_GUI3(1);
//		delay(5000);
//
//		///
//
//
//	}
//
//
//	/////////////////////////////////
//	// test MUSIC_DETECT
//	if (G_test_number == 9)
//	{
//		unsigned long start_stamp = millis();
//		
//		//byte music = MUSIC_DETECT(1500, 3);
//		//byte music = SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0);
//
//		//byte music = 0;
//		//FFT_COMPUTE(); ////sample analog input and  Compute FFT
//
//		//byte music = SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0);  // takes 122ms
//
//		byte music = BEAT_DETECT(BEAT_DETECT_THRESHOLD); // 200 was determined by turning off sound and looking at the adjusted peak threshold
//
//		unsigned long end_stamp = millis();
//		unsigned long delta_time =   end_stamp - start_stamp;
//
//		if (music == 0)
//		{
//			FastLED.clear();
//		}
//		else
//		{
//			LINE(0, 11, 21, 11, 0);
//\
//		}
//
//		FastLED.show();
//
//
//
//		Serial.print(F("music="));
//		Serial.println(music);
//		Serial.print(F("delta_time="));
//		Serial.println(delta_time);
//		Serial.println("");
//	}
//
//
//
//	/////////////////////////////////
//	// test FLIP_DISPLAY function
//	if (G_test_number == 10)
//	{
//		FastLED.clear();
//
//		LINE(0, 0, 21, 0, 0);
//
//		FastLED.show();
//
//		delay(1000);
//
//		FLIP_DISPLAY();
//
//		FastLED.show();
//
//
//		delay(3000);
//
//	}
//
//
//	/////////////////////////////////////////////////////////
//	// test MURGERTOID_PC PRINT function
////#define printD printF(F
//
//	if (G_test_number == 11)
//	{
//		byte giggle = 45;
//
//		//printF(F("Hello Don"), giggle);
//
//		printD("good boy ="), giggle);
//		SPACE
//
//
//
//	}
//
//	/////////////////////////////////////////////
//	// test IMPRINT (test 4 in MURGETROID_PC)
//	if (G_test_number == 12)
//	{
//		for (byte dim = 0; dim < 256; dim = dim + 10)
//		{
//
//			FastLED.clear();
//
//
//			//for (int adr = 0; adr < NUM_LEDS/2; ++adr) // fill screen with solid colors
//			//{
//			//	leds1[adr] = CHSV(85, 255, 100);;
//			//}
//
//			//G_dim = dim;
//			//G_dim_shape = dim;
//
//			FILL_VERT(5, 10, 15, 10, 1, 5, 85);
//			FILL_VERT(5, 10, 15, 10, -1, 5, 85);
//			//FILL_HOZ(10, 5, 10, 15, 1, 5, 85);
//
//			//print("G_dim=", G_dim);
//
//			SAVE_TO_BUFFER(1);
//
//			//G_dim = 0;
//			//G_dim_shape = 0;
//
//			FastLED.clear();
//
//			//LOAD_BUFFER(1);
//
//			//create HUE screen to IMPRINT
//			LINE(0, 0, 21, 21, 0);
//			LINE(0, 21, 21, 0, 171);
//
//			//	SHOW_slow(window);
//			//	delay(100);
//
//
//			IMPRINT(IHUE);
//
//			FastLED.show();
//
//			//SHOW_slow(window);
//			delay(200);
//
//			//LINE(1, 10, 20, 10, 0);
//
//
//			//int adr = XY_ADR(10, 10);
//			//leds1[adr] = CHSV(0, 255, 255);  // 
//
//
//			//leds1[0].r = 255;
//		}
//
//
//	}
//
//	/////////////////////////////////////////////
//// test IMPRINT_SHOW 
//	if (G_test_number == 13)
//	{
//		/////used for IMPRINT_SHOW function  /////
//		byte IMPRINT_ONLY = 0;  // set to 1 to only show IMPRINT,   set to  0 to only show IMPRINT and IMAGE
//
//		byte imp = 1; // type of imprint to use
//		byte imp_show = 1;  // defines which IMPRINT_SHOW to execute
//		int hue_start = 0;  // sets the starting hue of the hue imprint
//		int hue_end = 171;  // sets the ending hue of the hue imprint
//		byte total_cycles = 10; // sets the duration of HUE cycling of a given show, hue transitions from hue_start to hue_end during this cycle
//		byte delta_per_cycle = 3;  // each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines how far each instance of the shape moves per cycle
//		byte num_instances = 2;  // number of instances of the shape used to hue imprint
//		byte distance_between_instances = 4; // each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines the distance between repeats of the shape
//		byte fill_depth = 1; // number of lines filled when using FILL_HOZ or FILL_VERT function in some of the shows, 0=1 line
//		static byte reset_imprint_show = 0; // set to 1 to restore a given IMPRINT_SHOW back to cycle=0;
//		int brightness_percentage = 100; // This is the percentage dimmer or brighter the IMPRINT will be relative to the current display brightness, 100=current brightness
//
//		//IMPRINT_SHOW(imp_show, hue_start, hue_end, total_cycles, delta_per_cycle, num_instances, distance_between_instances, fill_depth, dimming_imp,  reset_imprint_show);
//
//
//		///////////////////////////////////////////
//
//
//
//
//		// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
//		// 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
//
//
//		TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  // line
//		TWEEN_IMAGE_START[0].XS = 0;
//		TWEEN_IMAGE_START[0].YS = 0;
//		TWEEN_IMAGE_START[0].XE = 21;
//		TWEEN_IMAGE_START[0].YE = 0;
//		TWEEN_IMAGE_START[0].HUE = 85;
//		TWEEN_IMAGE_START[0].DATA1 = 0;   // not used
//		TWEEN_IMAGE_START[0].DATA2 = 0;  // not used
//		TWEEN_IMAGE_START[0].DATA3 = 0;  // not used
//
//		TWEEN_IMAGE_START[1].IMAGE_KIND = 1;  //line
//		TWEEN_IMAGE_START[1].XS = 0;
//		TWEEN_IMAGE_START[1].YS = 21;
//		TWEEN_IMAGE_START[1].XE = 21;
//		TWEEN_IMAGE_START[1].YE = 21;
//		TWEEN_IMAGE_START[1].HUE = 171;
//		TWEEN_IMAGE_START[1].DATA1 = 0;
//		TWEEN_IMAGE_START[1].DATA2 = 0;
//		TWEEN_IMAGE_START[1].DATA3 = 0;
//
//
//
//		/////////////////////////
//
//		/////////// END ///////////////////
//
//
//
//		TWEEN_IMAGE_END[0].IMAGE_KIND = 1;  //circle
//		TWEEN_IMAGE_END[0].XS = 0;
//		TWEEN_IMAGE_END[0].YS = 10;  // 10
//		TWEEN_IMAGE_END[0].XE = 2; // radius
//		TWEEN_IMAGE_END[0].YE = 10;
//		TWEEN_IMAGE_END[0].HUE = 171;
//		TWEEN_IMAGE_END[0].DATA1 = 0;   // not used
//		TWEEN_IMAGE_END[0].DATA2 = 0;  // amplitude
//		TWEEN_IMAGE_END[0].DATA3 = 0;  // amplitude
//
//		TWEEN_IMAGE_END[1].IMAGE_KIND = 1;  //line
//		TWEEN_IMAGE_END[1].XS = 0;
//		TWEEN_IMAGE_END[1].YS = 11;
//		TWEEN_IMAGE_END[1].XE = 2;
//		TWEEN_IMAGE_END[1].YE = 11;
//		TWEEN_IMAGE_END[1].HUE = 0;
//		TWEEN_IMAGE_END[1].DATA1 = 0;   // peaks  // not used
//		TWEEN_IMAGE_END[1].DATA2 = 0;  // amplitude  // not used
//		TWEEN_IMAGE_END[1].DATA3 = 0;  // spike color yellow  // not used
//
//
//		///for (byte hue = 0; hue < 256; hue = hue + 10)
//		//byte forever = 1; 
//
//		while (1)
//		{
//
//			//////////////*************************** first genereate FILL IMPRINT  ****************************** //////////////////////////////////////
//
//			static byte do_once = 1;
//
//			if (do_once == 1)
//			{
//				FastLED.clear();
//				do_once = 0;
//			}
//
//			//FILL_VERT(5, 10, 15, 10, 1, 5, hue);
//			//FILL_VERT(5, 10, 15, 10, -1, 5, hue);
//
//			//static byte reset = 0;
//
//			if (reset_imprint_show == 1)
//			{
//				FastLED.clear();
//			}
//
//
//
//			/// INITIALIZATION of IMPRINT_SHOW
//			imp_show = 1;
//			num_instances = 4;  //8
//			fill_depth = 1;  //0
//			hue_start = 0;
//			hue_end = 171;
//			total_cycles = 3; //10
//			delta_per_cycle = 3;  //3, each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines how far each instance of the shape moves per cycle
//
//
//			////////////********************************
//			//imp = 1;   // TEST ONLY to fix the imprint being used, otherwise they will cycle through all imprint types
//			////////////********************************
//
//
//			////////////********************************
//			brightness_percentage = brightness_percentage + 20;  // change brightness of IMPRINT from 50% to 150% of the present display brightness
//
//			if (brightness_percentage > 150) { brightness_percentage = 50; }
//
//			
//			////////////********************************
//
//
//			///////////// TEST ONLY  ///////////////
//			//G_dim = 250;
//			//brightness_percentage = 500;
//
//			/////////////////////////////////////////
//
//
//			////////////////////////////////*********  IMPRINT_SHOW ********* /////////////////////////////////////
//
//			reset_imprint_show = IMPRINT_SHOW(imp_show, hue_start, hue_end, total_cycles, delta_per_cycle, num_instances, distance_between_instances, fill_depth, brightness_percentage, reset_imprint_show);
//
//			//reset = 0;
//
//			//IMPRINT_SHOW(1, 0);
//
//			///////////// for viewing IMPRINT alone  ///////////////////////////////////////
//
//
//			if (IMPRINT_ONLY == 1) // allow for showing the IMPRINT
//			{
//
//				//SHOW_slow(window);
//				FastLED.show();  // no dimming
//				delay(1000);
//
//			}
//
//			///////////////////////////////////////////////////////////////////////////
//
//
//
//			if (IMPRINT_ONLY == 0)  // SKIP for now, use IMPRINT
//			{
//				//SAVE_TO_BUFFER(1);
//
//				//G_dim = 0;
//				//G_dim_shape = 0;
//
//				FastLED.clear();
//
//				//////////////////////////////////////////////////////////////////////////
//
//				//LOAD_BUFFER(1);
//
//				//create HUE screen to IMPRINT
//				//LINE(0, 0, 21, 21, 0);
//				//LINE(0, 21, 21, 0, 171);
//
//				//LINE(0, 10, 10, 21, 171);
//
//				///////////////********************************* NOW generate IMAGE to use imprint on ************************************ /////////////////////////
//
//				for (byte increment = 0; increment < 11;++increment)
//				{
//					// hue_code = 0 to 255 will force hue; 999=ERASE image;  1000  = generate a weighted blend between start and end images;  2000=use hue from starting image, 3000=use hue from ending image
//
//					//if (isPaused == 0)
//					//{
//						//print("increment=", increment);
//					//}
//
//					// hue_code = 0 to 255 will force hue; 999=ERASE image;  1000  = generate a weighted blend between start and end images;  2000=use hue from starting image, 3000=use hue from ending image
//					TWEEN(1, 2, 11, increment, 171, 1);
//
//				}
//
//
//				/////////////////  NOW IMPRINT the BUFFER onto the IMAGE /////////////////////////
//				// method =1: hue the imprint screen replaces hue of active screen pixels: IHUE
//				// method =2: XOR the buffer onto  the active screen pixels: IXOR
//				// method =3: AND the buffer and  the active screen pixels, leave buffer pixles: IAND_BUFFER  (i.e. leave the overlap buffer region with the buffer color)
//				// method =4: AND the buffer and  the active screen pixels, leave screen pixles: IAND_SCREEN (i.e. leave the overlap buffer region with the screen pixles color)
//				// method =5  AND the buffer and the active screen pixels, EXCLUDE the AND'd region from the active screen pixels (i.e. cut out the buffer region)
//
//				//imp = 1;  // for test
//
//				printD("IMPRINT kind:  imp="), imp);
//
//				IMPRINT(imp);
//
//				++imp;  // global at level of main
//
//				if (imp > 5)
//				{
//					imp = 1;
//				}
//
//				//////////////////////////////////////////////////////////////////////////////////
//
//				//FastLED_show(window);
//
//				//SHOW_slow(window);
//				FastLED.show();  // no dimming
//				delay(1000);
//
//				//LINE(1, 10, 20, 10, 0);
//
//
//				//int adr = XY_ADR(10, 10);
//				//leds1[adr] = CHSV(0, 255, 255);  // 
//
//
//				//leds1[0].r = 255;
//			}
//		}
//	}



	
	
	////////////////////////////////////////////////////////

	//
	//
	//	if (G_test_number == 8)
	//	{
	//		//activate_fast();
	//		int adr = 0;
	//		int led_adr = 0;
	//
	//		fast_leds1[adr].r = 255;  // 
	//		fast_leds1[adr].g = 0;
	//		fast_leds1[adr].b = 0;
	//
	//		led_adr = modify_adr(0, 0, adr);   //make image right side up or upside down
	//
	//		fast_leds2[led_adr].r = 255;  // 
	//		fast_leds2[led_adr].g = 0;  // 
	//		fast_leds2[led_adr].b = 0;  // 
	//
	//		HALL_SYNC2();
	//		FastLED.show();
	//
	//		FastLED.clear();  // set to black all LEDs..
	//
	//		//^
	//
	//		adr = 21;
	//
	//		fast_leds1[adr].r = 0;  // 
	//		fast_leds1[adr].g = 0;
	//		fast_leds1[adr].b = 255;
	//
	//		led_adr = modify_adr(0, 0, adr);   //make image right side up or upside down
	//
	//		fast_leds2[led_adr].r = 0;  // 
	//		fast_leds2[led_adr].g = 0;  // 
	//		fast_leds2[led_adr].b = 255;  // 
	//
	//
	//		HALL_SYNC2();
	//		FastLED.show();
	//
	//		FastLED.clear();  // set to black all LEDs..
	//
	//
	//
	//			//delay(1000);
	//
	//	}
	//
	//
	//	if (G_test_number == 9)
	//	{
	//		BT_and_DC_CHECKandDO();
	//	}
	//
	//	if (G_test_number == 10)
	//	{
	//		// find a number that is proportional to the time between hall counts
	//		unsigned long start_count = 0;
	//		int time_interval = 0;
	//		int spin_ups = 50; // sets the time for spin up
	//
	//		FastLED.clear();  // set to black all LEDs.
	//		FastLED.show();
	//
	//
	//		for (int n = 0; n < spin_ups; ++n)
	//		{
	//			HALL_SYNC2();
	//		}
	//
	//		for (int adr = 0; adr < 5; ++adr)   // light LEDs to indicte spin up is done
	//		{
	//			fast_leds1[adr].r = 255;  // 
	//			fast_leds1[adr].g = 0;
	//			fast_leds1[adr].b = 0;
	//
	//			led_adr = modify_adr(0, 0, adr);   //make image right side up or upside down
	//			fast_leds2[led_adr].r = 0;  // 
	//			fast_leds2[led_adr].g = 0;  // 
	//			fast_leds2[led_adr].b = 255;  // 
	//		}
	//
	//		FastLED.show();
	//
	//
	//		HALL_SYNC2();
	//		start_count = G_Hall_counts;
	//
	//		while (start_count == G_Hall_counts)
	//		{
	//			++time_interval;
	//		}
	//
	//
	//		/*Serial.println("Experiment Done");
	//		Serial.println(time_interval);
	//		Serial.println("");*/
	//
	//		int endless = 1;
	//
	//		while (endless == 1)
	//		{
	//			// just wait to read serial monitor
	//			Serial.println(F("Experiment Done"));
	//			Serial.println(time_interval);
	//			Serial.println("");
	//		}
	//
	//	}
	//
	//	if (G_test_number == 11)
	//	{
	//		// find a number that is proportional to the time between hall counts
	//		int start_count = 0;
	//		int time_interval = 0;
	//		int spin_ups = 50; // sets the time for spin up
	//
	//		FastLED.clear();  // set to black all LEDs.
	//		FastLED.show();
	//
	//
	//		for (int n = 0; n < spin_ups; ++n)
	//		{
	//			HALL_SYNC2();
	//		}
	//
	//		for (int adr = 0; adr < 5; ++adr)   // light LEDs to indicte spin up is done
	//		{
	//			fast_leds1[adr].r = 255;  // 
	//			fast_leds1[adr].g = 0;
	//			fast_leds1[adr].b = 0;
	//
	//			led_adr = modify_adr(0, 0, adr);   //make image right side up or upside down
	//			fast_leds2[led_adr].r = 0;  // 
	//			fast_leds2[led_adr].g = 0;  // 
	//			fast_leds2[led_adr].b = 255;  // 
	//		}
	//
	//		FastLED.show();
	//
	//		time_interval = HALL_MEASURE3(22);
	//
	//		/*Serial.println("Experiment Done");
	//		Serial.println(time_interval);
	//		Serial.println("");*/
	//
	//		int endless = 1;
	//
	//		while (endless == 1)
	//		{
	//			// just wait to read serial monitor
	//			Serial.println(F("Experiment Done"));
	//			Serial.println(time_interval);
	//			Serial.println("");
	//		}
	//
	//	}
	//
	//	// text testing
	//	if (G_test_number == 12)
	//	{
	//		G_special_char_select = 1;
	//		HALL_MEASURE3(22);  //find G_max_bins
	//
	//		G_text2 = 1;  // set to 1 to enable panels 3,4 display of text and graphics
	//
	//
	//		//text_array[0] = { "ABCD123456789" };
	//		//strcpy(text_array, "0123456789ABCDEFGH");
	//		strcpy(scroll_text_array, "NEW METHOD NOW");
	//
	//		unsigned long blanks_interval = 195 / 8;   // nominal value in mills  : 1 revolution = 195ms , 8 = nominal max_len
	//		int max_len = HALL_MEASURE3(22) / blanks_interval;  // calculate the maximum number of blanks before blinking occurs  .... GOOD restore
	//		int stringSize = strlen(scroll_text_array);
	//
	//		//DISPLAY_TEXT_ARRAY(text_array , max_len, 1, 1, 0);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//
	//		strcpy(scroll_text_array, "T  ~~**~~");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//		strcpy(scroll_text_array, "12345");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//		strcpy(scroll_text_array, "~~XYZ~~");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//
	//		///
	//		G_text2 = 0;  // set to 1 to enable panels 3,4 display of text and graphics
	//
	//		strcpy(scroll_text_array, "OLD METHOD NOW");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//		strcpy(scroll_text_array, "T ~~**~~");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//		strcpy(scroll_text_array, "12345");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//		strcpy(scroll_text_array, "~~XYZ~~");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//		/////////////////
	//
	//	}
	//
	//	// image testing
	//	if (G_test_number == 13)
	//	{
	//
	//		int stringSize = 0;
	//
	//		G_special_char_select = 1;
	//		HALL_MEASURE3(22);  //find G_max_bins
	//
	//		//strcpy(text_array, "0123456789ABCDEFGH");
	//		//strcpy(text_array, "~~ EK AB");  // rainbow
	//		//strcpy(text_array, "~~");  // rainbow
	//
	//		strcpy(scroll_text_array, "^^^^^^^^************************************");
	//		stringSize = strlen(scroll_text_array);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 1, 0);
	//
	//		//unsigned long blanks_interval = 195 / 8;   // nominal value in mills  : 1 revolution = 195ms , 8 = nominal max_len
	//		//int max_len = HALL_MEASURE3(22) / blanks_interval;  // calculate the maximum number of blanks before blinking occurs  .... GOOD restore
	//
	//		//DISPLAY_TEXT_ARRAY(text_array , max_len, 1, 1, 0);
	//
	//
	//		//strcpy(text_array, "^^NOW IS THE TIME FOR ALL GOOD MEN^^");
	//		strcpy(scroll_text_array, "0123456789ABCDEFGH");
	//		stringSize = strlen(scroll_text_array);
	//
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 1, 0);
	//		//SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0, 0);
	//
	//		/*strcpy(text_array, "A");
	//		stringSize = strlen(text_array);
	//		SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0);
	//
	//		strcpy(text_array, "12345");
	//		stringSize = strlen(text_array);
	//		SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0);
	//
	//		strcpy(text_array, "XYZ");
	//		stringSize = strlen(text_array);
	//		SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0);*/
	//	}
	//
	//	////////////////////////////////////////////////////////
	//	// BlueTooth TEST with SCROLL TEXT write
	//	if (G_test_number == 14)
	//	{
	//
	//		/*Serial.println("");
	//		Serial.println("TEST 14");
	//		Serial.println("");*/
	//
	//
	//
	//		FastLED.clear();  // set to black all LEDs.
	//		SHOW_fast(1, 0);
	//
	//
	//		G_special_char_select = 1;
	//
	//		G_text2 = 1;  // set to 1 to enable panels 3,4 display of text and graphics
	//
	//
	//		if (SerialBT.available())
	//		{
	//			G_incomingChar = SerialBT.read();
	//
	//			if (G_incomingChar != '\n') {
	//				G_message += String(G_incomingChar);
	//			}
	//			else {
	//				//G_message = "";
	//				G_BT_message_flag = 1;
	//			}
	//			/*Serial.println(G_message);
	//			Serial.write(G_incomingChar);*/
	//
	//		}
	//
	//
	//		/*if (G_message != "END")
	//		{
	//			Serial.println("");
	//			Serial.print("TEST 14:  count=");
	//			++G_count;
	//			Serial.println(G_count);
	//		}
	//		else
	//		{
	//			Serial.println("GOT MESSAGE");
	//			Serial.println(G_message);
	//			delay(1000);
	//		}*/
	//
	//
	//
	//		/*if (Serial.available()) {
	//			SerialBT.write(Serial.read());
	//		}
	//		if (SerialBT.available()) {
	//			Serial.write(SerialBT.read());
	//		}*/
	//		delay(20);
	//
	//		//strcpy(text_array, "MURGETROID 3");
	//		//text_array = message;
	//		//strcpy(text_array, message);
	//
	//		//if (G_message != "")
	//		if (G_BT_message_flag == 1)
	//		{
	//
	//			/*Serial.print("message got=");
	//			Serial.println(G_message);
	//			Serial.println("");*/
	//
	//			HALL_MEASURE3(22);  //find G_max_bins
	//
	//			int stringSize = G_message.length();
	//
	//			G_message.toCharArray(scroll_text_array, stringSize);  // convert message to my text_array
	//
	//			/*Serial.print("text_array=");
	//			Serial.println(text_array);
	//			Serial.println("");*/
	//
	//			/*Serial.print("message_flag=");
	//			Serial.println(message_flag);
	//			Serial.println("");*/
	//
	//
	//			int hue = -1;  // white
	//			stringSize = strlen(scroll_text_array);
	//
	//			SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, hue, 0, 0, 1, 0);
	//
	//			G_BT_message_flag = 0;
	//			G_message = "";
	//		}
	//	}
	//
	//	// DON COM test
	//	if (G_test_number == 15)
	//	{
	//		Serial.println(F("MASTER: start of DON COM test"));
	//		Serial.println("");
	//
	//		byte rv = 0;
	//
	//		for (int n = 0; n < DC_ARRAY_SIZE; ++n)  // initialize the DC_OUT_array
	//		{
	//			DC_OUT_array[n] = n;
	//		}
	//
	//		rv = DC_SEND_ARRAY();
	//
	//		Serial.println(F("MASTER array sent"));
	//		Serial.print(F("rv="));
	//		Serial.println(rv);
	//		Serial.println("");
	//
	//		//delay(100);
	//
	//	}
	//
	//	// another Blue Tooth Test
	//	if (G_test_number == 16)
	//	{
	//		int hue = 1;  // white
	//
	//		G_BT_message_flag = CHECK_BLUE_TOOTH();
	//
	//		if (G_BT_message_flag == 1)
	//		{
	//			++G_count;
	//
	//			if (G_count > 1)
	//			{
	//				hue = 171;  // blue
	//			}
	//
	//			SHOW_BLUE_TOOTH_MESSAGE(hue);
	//		}
	//	}
	//
	//	// DON COM test
	//	if (G_test_number == 17)
	//	{
	//
	//		Serial.println(F(" ************ TEST 17  ***********"));
	//		//int temp1 = 0;
	//		//int temp2 = 0;
	//		//digitalWrite(G_DC_M0, HIGH);
	//		//digitalWrite(G_DC_M1, HIGH);
	//		//temp1 = digitalRead(G_DC_M0);
	//		//temp2 = digitalRead(G_DC_M1);
	//		//Serial.print(F("G_DC_M0="));
	//		//Serial.println(temp1);
	//		//Serial.print(F("G_DC_M1="));
	//		//Serial.println(temp2);
	//		//Serial.println(F(""));
	//
	//		//temp1 = digitalRead(G_DC_S0);
	//		//temp2 = digitalRead(G_DC_S1);
	//		//Serial.print(F("G_DC_S0="));
	//		//Serial.println(temp1);
	//		//Serial.print(F("G_DC_S1="));
	//		//Serial.println(temp2);
	//		//Serial.println(F(""));
	//
	//		//Serial.println(F(" G_DC_0 writing LOW"));
	//		//digitalWrite(G_DC_M0, LOW);
	//		//temp1 = digitalRead(G_DC_M0);
	//		//temp2 = digitalRead(G_DC_M1);
	//		//Serial.print(F("G_DC_M0="));
	//		//Serial.println(temp1);
	//		//Serial.print(F("G_DC_M1="));
	//		//Serial.println(temp2);
	//		//Serial.println(F(""));
	//
	//		//Serial.println(F(" G_DC_1 writing LOW"));
	//		//digitalWrite(G_DC_M0, HIGH);
	//		//digitalWrite(G_DC_M1, LOW);
	//		//temp1 = digitalRead(G_DC_M0);
	//		//temp2 = digitalRead(G_DC_M1);
	//		//Serial.print(F("G_DC_M0="));
	//		//Serial.println(temp1);
	//		//Serial.print(F("G_DC_M1="));
	//		//Serial.println(temp2);
	//		//Serial.println(F(""));
	//
	//		//Serial.println(F(" G_DC_0 AND G_DC_1 writing LOW"));
	//		//digitalWrite(G_DC_M0, LOW);
	//		//digitalWrite(G_DC_M1, LOW);
	//		//temp1 = digitalRead(G_DC_M0);
	//		//temp2 = digitalRead(G_DC_M1);
	//		//Serial.print(F("G_DC_M0="));
	//		//Serial.println(temp1);
	//		//Serial.print(F("G_DC_M1="));
	//		//Serial.println(temp2);
	//		//Serial.println(F(""));
	//
	//
	//		//DC_OUT_array[0] = 1;  // test sending
	//		//DC_SEND();
	//
	//		delay(3000);
	//		DC_OUT_array[0] = 2;  // test receiving
	//		DC_SEND();
	//
	//		delay(1000);
	//		DC_CHECK_AND_DO();
	//
	//
	//
	//		//BT_and_DC_CHECKandDO();
	//		Serial.println(F("test 17 "));
	//		Serial.print(F("G_DC_received_flag= "));
	//		Serial.println(G_DC_received_flag);
	//		Serial.print(F("DC_IN_array[0]= "));
	//		Serial.println(DC_IN_array[0]);
	//		Serial.print(F("DC_IN_array[1]= "));
	//		Serial.println(DC_IN_array[1]);
	//		Serial.println("");
	//
	//
	//
	//
	//
	//
	//		G_DC_received_flag = 0;  // must be cleared 
	//
	//		//
	//		//Serial.println("");
	//		//Serial.println("before DC_READ");
	//		////int rv=DC_READ_BYTE();
	//
	//	 //
	//		//int rv = DC_RECEIVE_ARRAY();
	//		//Serial.println("after DC_READ");
	//		//Serial.print("rv= ");
	//		//Serial.println(rv);
	//		//Serial.print("G_DC_data= ");
	//		//Serial.println(G_DC_data);
	//
	//		/*Serial.print("DC_IN_array[0]= ");
	//		Serial.println(DC_IN_array[0]);
	//		Serial.print("DC_IN_array[1]= ");
	//		Serial.println(DC_IN_array[1]);*/
	//
	//	}
	//
	//	// image testing
	//	if (G_test_number == 18)
	//	{
	//		//DC_OUT_array[0] = 34;  // clear RESET in SLAVE
	//		//DC_SEND();
	//
	//		int stringSize = 0;
	//
	//
	//		//G_special_slider = 8;
	//		//G_continuous_SPECIAL_mode = 1;
	//		//G_CREATE_mode = 1;
	//		//G_special_saved_flag = 1;
	//
	//		//G_special_char_select = 1;
	//		G_special_char_select = 1001;
	//
	//
	//		//stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
	//
	//
	//
	//		//LOAD_BMP_PANEL(52, 1);  // only load leds1 as leds2 will be loaded with the sychronized TEXT for panels 3 and 4
	//
	//		//Serial.println(F(""));
	//		//Serial.println(F("<<<  test 18: after LOAD_BMP_PANEL(52,1)  >>>"));
	//		//DUMP_LED_ARRAY(leds1, NUM_LEDS); // dump the passed LED array to the Serial Monitor
	//		//
	//		//
	//		//
	//		//LOAD_BMP_SAVED_2BUFFER(1001, 1);
	//
	//		//Serial.println(F(""));
	//		//Serial.println(F("<<<  test 18: after LOAD_BMP_SAVED_2BUFFER(1001,1)  >>>"));
	//		//DUMP_LED_ARRAY(leds1, NUM_LEDS); // dump the passed LED array to the Serial Monitor
	//
	//
	//		for (int n = 0; n < NUM_LEDS; ++n)
	//		{
	//			leds_saved[1][n] = 0;  // clear array
	//		}
	//		CLEAR_FONT_BUFFER_1();
	//		LOAD_FONT_BUFFER(54, 1);    /// test image in FONT images
	//
	//		for (int row = 0; row < 22; ++row)  // first half
	//		{
	//			for (int col = 0; col < 11; ++col)
	//			{
	//				int adr_from = GET_LED_ADR(row, col);
	//				int adr_to = GET_LED_ADR(row, col);
	//				leds_saved[1][adr_to] = leds_buffer1[adr_from];
	//			}
	//		}
	//
	//
	//
	//		CLEAR_FONT_BUFFER_1();
	//		LOAD_FONT_BUFFER(55, 1);    /// test image
	//
	//		for (int row = 0; row < 22; ++row)   // 2nd half in FONT images
	//		{
	//			for (int col = 0; col < 11; ++col)
	//			{
	//				int adr_from = GET_LED_ADR(row, col);
	//				int adr_to = GET_LED_ADR(row, col + 11);
	//				leds_saved[1][adr_to] = leds_buffer1[adr_from];
	//			}
	//		}
	//
	//
	//		//if (SERIAL_MON == 1)
	//		//{
	//		//	Serial.println(F(""));
	//		//	Serial.println(F("DO_TEST: combined image"));
	//
	//		//	DUMP_LED_ARRAY(leds_saved[1], NUM_LEDS);
	//		//	//DUMP_LED_ARRAY(leds1, NUM_LEDS);
	//		//}
	//
	//
	//		//CLEAR_FONT_BUFFER_1();
	//
	//		////LOAD_BMP_PANEL(53, 1);    /// test image
	//		//LOAD_BMP_PANEL(54, 1);    /// test image
	//
	//		//
	//
	//		//if (SERIAL_MON == 1)
	//		//{
	//		//	Serial.println(F(""));
	//		//	Serial.println(F("DO_TEST 18: BMP54:   before DUMP after LOAD_BMP_PANEL"));
	//
	//
	//		//	DUMP_LED_ARRAY(leds1, NUM_LEDS);
	//		//}
	//
	//		//CLEAR_FONT_BUFFER_1();
	//
	//		//LOAD_BMP_PANEL(55, 1);    /// test image
	//
	//
	//
	//		//if (SERIAL_MON == 1)
	//		//{
	//		//	Serial.println(F(""));
	//		//	Serial.println(F("DO_TEST 18:BMP55 **** before DUMP after LOAD_BMP_PANEL"));
	//
	//
	//		//	DUMP_LED_ARRAY(leds1, NUM_LEDS);
	//		//}
	//
	//
	//
	//		//strcpy(text_array, "************************************");
	//		//strcpy(text_array, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
	//		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");
	//		////strcpy(text_array, "*%*%*");
	//		//strcpy(text_array, "ABABABABABABABABABABABABABAB");
	//
	//
	//		stringSize = strlen(scroll_text_array);
	//
	//		HALL_MEASURE3(22);  //find G_max_bins
	//
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 1, 0);
	//
	//
	//
	//	}
	//
	//	if (G_test_number == 19)
	//	{
	//		int led_adr_bad = 0;
	//		int led_adr_good = 0;
	//
	//		for (int adr = 0; adr < NUM_LEDS; ++adr)
	//		{
	//			led_adr_bad = modify_adr(1, 0, ((NUM_LEDS)-adr));
	//			led_adr_good = modify_adr(1, 0, adr);
	//
	//			Serial.println(F(""));
	//			Serial.print(F("adr="));
	//			Serial.print(adr);
	//			Serial.print("  led_adr_bad=");
	//			Serial.print(led_adr_bad);
	//			Serial.print("  led_adr_good=");
	//			Serial.println(led_adr_good);
	//
	//		}
	//	}
	//
	//	// Single ESP32 board test
	//	if (G_test_number == 20)
	//	{
	//		//DC_OUT_array[0] = 34;  // clear RESET in SLAVE
	//		//DC_SEND();
	//
	//		int stringSize = 0;
	//
	//
	//		//G_special_slider = 8;
	//		//G_continuous_SPECIAL_mode = 1;
	//		//G_CREATE_mode = 1;
	//		//G_special_saved_flag = 1;
	//
	//		//G_special_char_select = 1;
	//		G_special_char_select = 1001;
	//
	//
	//		//stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
	//
	//
	//
	//		//LOAD_BMP_PANEL(52, 1);  // only load leds1 as leds2 will be loaded with the sychronized TEXT for panels 3 and 4
	//
	//		//Serial.println(F(""));
	//		//Serial.println(F("<<<  test 18: after LOAD_BMP_PANEL(52,1)  >>>"));
	//		//DUMP_LED_ARRAY(leds1, NUM_LEDS); // dump the passed LED array to the Serial Monitor
	//		//
	//		//
	//		//
	//		//LOAD_BMP_SAVED_2BUFFER(1001, 1);
	//
	//		//Serial.println(F(""));
	//		//Serial.println(F("<<<  test 18: after LOAD_BMP_SAVED_2BUFFER(1001,1)  >>>"));
	//		//DUMP_LED_ARRAY(leds1, NUM_LEDS); // dump the passed LED array to the Serial Monitor
	//
	//
	//		for (int n = 0; n < NUM_LEDS; ++n)
	//		{
	//			leds_saved[1][n] = 0;  // clear array
	//		}
	//		CLEAR_FONT_BUFFER_1();
	//		LOAD_FONT_BUFFER(54, 1);    /// test image
	//
	//		for (int row = 0; row < 22; ++row)  // first half
	//		{
	//			for (int col = 0; col < 11; ++col)
	//			{
	//				int adr_from = GET_LED_ADR(row, col);
	//				int adr_to = GET_LED_ADR(row, col);
	//				leds_saved[1][adr_to] = leds_buffer1[adr_from];
	//			}
	//		}
	//
	//
	//
	//		CLEAR_FONT_BUFFER_1();
	//		LOAD_FONT_BUFFER(55, 1);    /// test image
	//
	//		for (int row = 0; row < 22; ++row)   // 2nd half
	//		{
	//			for (int col = 0; col < 11; ++col)
	//			{
	//				int adr_from = GET_LED_ADR(row, col);
	//				int adr_to = GET_LED_ADR(row, col + 11);
	//				leds_saved[1][adr_to] = leds_buffer1[adr_from];
	//			}
	//		}
	//
	//
	//		//if (SERIAL_MON == 1)
	//		//{
	//		//	Serial.println(F(""));
	//		//	Serial.println(F("DO_TEST: combined image"));
	//
	//		//	DUMP_LED_ARRAY(leds_saved[1], NUM_LEDS);
	//		//	//DUMP_LED_ARRAY(leds1, NUM_LEDS);
	//		//}
	//
	//
	//		//CLEAR_FONT_BUFFER_1();
	//
	//		////LOAD_BMP_PANEL(53, 1);    /// test image
	//		//LOAD_BMP_PANEL(54, 1);    /// test image
	//
	//		//
	//
	//		//if (SERIAL_MON == 1)
	//		//{
	//		//	Serial.println(F(""));
	//		//	Serial.println(F("DO_TEST 18: BMP54:   before DUMP after LOAD_BMP_PANEL"));
	//
	//
	//		//	DUMP_LED_ARRAY(leds1, NUM_LEDS);
	//		//}
	//
	//		//CLEAR_FONT_BUFFER_1();
	//
	//		//LOAD_BMP_PANEL(55, 1);    /// test image
	//
	//
	//
	//		//if (SERIAL_MON == 1)
	//		//{
	//		//	Serial.println(F(""));
	//		//	Serial.println(F("DO_TEST 18:BMP55 **** before DUMP after LOAD_BMP_PANEL"));
	//
	//
	//		//	DUMP_LED_ARRAY(leds1, NUM_LEDS);
	//		//}
	//
	//	//	LOAD_BMP(17);
	//	//	SHOW_slow();
	//
	//		//strcpy(text_array, "************************************");
	//		//strcpy(text_array, "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
	//
	//		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");
	//
	//		////strcpy(text_array, "*%*%*");
	//		//strcpy(text_array, "ABABABABABABABABABABABABABAB");
	//
	//
	//		stringSize = strlen(scroll_text_array);
	//
	//		HALL_MEASURE3(22);  //find G_max_bins
	//
	//
	//
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 1, 0);
	//
	//
	//
	//	}
	//
	//
	//	// check dimming
	//	if (G_test_number == 21)
	//	{
	//		LOAD_BMP(17);
	//
	//		for (int dim = 1; dim < 255;dim = dim + 20)
	//		{
	//			G_dim = dim;
	//
	//			SHOW_slow();
	//
	//			Serial.println(F(""));
	//			Serial.print(F("DO_TEST 21: G_dim="));
	//			Serial.println(G_dim);
	//			Serial.println(F(""));
	//
	//
	//			delay(500);
	//		}
	//	}
	//
	//	// panel orientation test
	//	if (G_test_number == 22)
	//	{
	//		SET_SLOW();
	//		FastLED.clear();  // set to black all LEDs.
	//
	//		// panel 1: adr 0 = RED
	//		leds1[0].r = 255;
	//		leds1[0].g = 0;
	//		leds1[0].b = 0;
	//
	//		// panel 2: adr 0 = GREEN
	//		leds2[0].r = 0;
	//		leds2[0].g = 255;
	//		leds2[0].b = 0;
	//
	//		// panel 3: adr 0 = BLUE
	//		leds3[0].r = 0;
	//		leds3[0].g = 0;
	//		leds3[0].b = 255;
	//
	//		// panel 4: adr 0 = WHITE
	//		leds4[0].r = 255;
	//		leds4[0].g = 255;
	//		leds4[0].b = 255;
	//
	//		SHOW_slow();
	//
	//	}
	//
	//	/// test HALL sensor
	//	if (G_test_number == 23)
	//	{
	//		byte HS = digitalRead(Hall);
	//
	//		++G_count;
	//
	//		if (G_count > 9) { G_count = 0; }
	//
	//		Serial.print(G_count);
	//		Serial.print(F(": HS="));
	//		Serial.println(HS);
	//		Serial.print(F(""));
	//	}
	//
	//	// check BT
	//	if (G_test_number == 24)
	//	{
	//		String message = "";
	//		char incomingChar;
	//
	//
	//
	//		if (SerialBT.available())
	//		{
	//			char incomingChar = SerialBT.read();
	//			if (incomingChar != '\n') {
	//				message += String(incomingChar);
	//			}
	//			else {
	//				message = "";
	//			}
	//
	//			Serial.write(incomingChar);
	//
	//		}
	//
	//
	//		/*Serial.print("message got=");
	//		Serial.println(message);
	//		Serial.println("");
	//		delay(1000);*/
	//
	//		if (message == "end")
	//		{
	//			Serial.println("GOT MESSAGE");
	//			Serial.println(message);
	//			delay(1000);
	//		}
	//	}
	//
	//	// text alignment testing
	//	if (G_test_number == 25)
	//	{
	//		G_max_test_count = 20;  // sets how much data to capture....must not exceed 20 due to test_array[] limit
	//
	//		G_special_char_select = 1;
	//		//	HALL_MEASURE3(22);  //find G_max_bins
	//
	//		G_text2 = 1;  // set to 1 to enable panels 3,4 display of text and graphics
	//
	//
	//
	//		strcpy(scroll_text_array, "A");
	//
	//		unsigned long blanks_interval = 195 / 8;   // nominal value in mills  : 1 revolution = 195ms , 8 = nominal max_len
	//		int max_len = HALL_MEASURE3(22) / blanks_interval;  // calculate the maximum number of blanks before blinking occurs  .... GOOD restore
	//		int stringSize = strlen(scroll_text_array);
	//
	//		int depth = 2;
	//		//DISPLAY_TEXT_ARRAY(text_array , max_len, 1, 1, 0);
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, depth, 0);
	//
	//
	//
	//		if (G_test_count < G_max_test_count)
	//		{
	//			test_array[G_test_count] = G_max_bins;  // record max bins
	//		}
	//
	//		if (G_test_count == G_max_test_count)
	//		{
	//			// start serial monitor
	//			Serial.begin(115200);
	//			while (!Serial); // wait for serial port to connect. Needed for native USB
	//			Serial.println(F("OK"));
	//			Serial.println(F("second OK"));
	//
	//			SET_SLOW();
	//			CLEAR_ALL_LEDS();
	//			SHOW_slow();
	//
	//			for (int tadr = 0; tadr < 21; ++tadr)  //light LEDs to signal finish
	//			{
	//				// flag finish
	//				leds1[tadr].r = 0;  // 
	//				leds1[tadr].g = 255;
	//				leds1[tadr].b = 0;
	//
	//				tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
	//				leds2[tadr].r = 0;  // 
	//				leds2[tadr].g = 255;  // 
	//				leds2[tadr].b = 0;  // 
	//
	//
	//				leds3[tadr].r = 0;  // 
	//				leds3[tadr].g = 255;
	//				leds3[tadr].b = 0;
	//
	//				tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
	//				leds4[tadr].r = 0;  // 
	//				leds4[tadr].g = 255;  // 
	//				leds4[tadr].b = 0;  // 
	//
	//
	//			}
	//
	//			G_dim = 1;
	//			SHOW_slow();
	//
	//
	//			//delay(10000);  // 5 second delay
	//
	//		}
	//
	//
	//
	//		while (G_test_count == G_max_test_count)  // stay here dumping data
	//		{
	//			Serial.println("");
	//			delay(50);
	//
	//			Serial.println(F("---> test_array DUMP: G_max_bins  <------  "));
	//			delay(50);
	//
	//			for (int n = 0; n < G_max_test_count; ++n)
	//			{
	//				Serial.println(test_array[n]);
	//				delay(50);
	//			}
	//
	//		}
	//
	//
	//		++G_test_count;
	//
	//
	//
	//
	//	}
	//
	//	//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	//	// FLOATING boxs variable LED depth
	//	if (G_test_number == 26)
	//	{
	//
	//		CLEAR_ALL_LEDS();
	//		SHOW_slow();
	//		int num2show = 5 * 22;
	//		int max_col = 22;
	//
	//		for (int col = 0; col < max_col; col = col + 5)
	//		{
	//			//	CAL_SPIN2(col*22);  // find the maximum number of blanks for STAR FLOAT ... prevents flashing
	//			int reps = 1;
	//
	//			for (int n = 0; n < reps; ++n)
	//			{
	//				num2show = (col * 22) + 22;
	//
	//				G_bmp_num = 22;
	//				STAR_FLOAT(1, 5, 1, 5, num2show);
	//
	//				//G_bmp_num = 23;
	//				//STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
	//
	//				//DC_CHECK_AND_DO();
	//
	//				//G_bmp_num = 24;
	//				//STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
	//
	//				//G_bmp_num = 25;
	//				//STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
	//			}
	//		}
	//
	//
	//		//CAL_SPIN2(NUM_LEDS);  // find the maximum number of blanks for STAR FLOAT ... prevents flashing
	//		//for (int n = 0; n < 3; ++n)
	//		//{
	//
	//		//	G_bmp_num = 22;
	//		//	STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
	//
	//		//	//G_bmp_num = 23;
	//		//	//STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
	//
	//		//	//DC_CHECK_AND_DO();
	//
	//		//	//G_bmp_num = 24;
	//		//	//STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
	//
	//		//	//G_bmp_num = 25;
	//		//	//STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
	//		//}
	//
	//
	//	}
	//
	//	// variable number of LEDs test
	//	if (G_test_number == 27)
	//	{
	//		int delta_x = 1;
	//		int adr = 0;
	//		int tadr = 0;
	//		int x = 0;
	//		int num2show = 0;
	//		int mini_test_num = 1; // select which portion of this test to do
	//
	//
	//		if (mini_test_num == 1)
	//		{
	//
	//			CLEAR_ALL_LEDS();
	//
	//			SHOW_slow();
	//
	//
	//			for (x = 0; x < 22; x = x + delta_x)
	//			{
	//				num2show = NUM_LEDS - (x * 22);
	//
	//
	//				LOAD_BMP(22);
	//				SHOW_var(num2show);
	//
	//
	//
	//				CLEAR_VAR_LEDS(num2show);
	//				SHOW_var(num2show);
	//
	//
	//			}
	//		}
	//
	//		if (mini_test_num == 2)
	//		{
	//
	//			for (x = 0; x < 22; x = x + delta_x)
	//			{
	//				num2show = NUM_LEDS - (x * 22);
	//
	//				for (int y = 0; y < 22; ++y)
	//				{
	//					adr = GET_XY_ADR(x, y);
	//
	//					leds1[adr] = (0, 0, 255);
	//					leds3[adr] = (0, 0, 255);
	//
	//					tadr = modify_adr(0, 0, adr);
	//
	//					leds2[tadr] = (0, 0, 255);
	//					leds4[tadr] = (0, 0, 255);
	//
	//					SHOW_var(num2show);
	//
	//				}
	//
	//				CLEAR_VAR_LEDS(num2show);
	//				SHOW_var(num2show);
	//
	//
	//			}
	//
	//		}
	//
	//
	//	}
	//
	//	// find G_max_flashes for each column of LEDs enabled
	//	if (G_test_number == 28)
	//	{
	//		int delta_x = 1;
	//		int adr = 0;
	//		int tadr = 0;
	//		int x = 0;
	//		int num2show = 0;
	//		int mini_test_num = 1; // select which portion of this test to do
	//
	//
	//		CLEAR_ALL_LEDS();
	//
	//		SHOW_slow();
	//
	//		G_test_count = 0;
	//
	//
	//		for (x = 0; x < 22; x = x + delta_x)   // gather data
	//		{
	//			num2show = NUM_LEDS - (x * 22);
	//
	//
	//			LOAD_BMP(22);
	//			SHOW_var(num2show);
	//
	//			HALL_MEASURE2(num2show);  // measure G_max_flashes
	//
	//			if (G_test_count < G_max_test_count)
	//			{
	//				test_array[G_test_count] = G_max_flashes;  // record G_max_flashes
	//			}
	//
	//			++G_test_count;
	//
	//			CLEAR_VAR_LEDS(num2show);
	//			SHOW_var(num2show);
	//
	//
	//		}
	//
	//
	//		// start serial monitor and signal finish
	//		Serial.begin(115200);
	//		while (!Serial); // wait for serial port to connect. Needed for native USB
	//		Serial.println(F("OK"));
	//		Serial.println(F("second OK"));
	//
	//		SET_SLOW();
	//		CLEAR_ALL_LEDS();
	//		SHOW_slow();
	//
	//		for (int tadr = 0; tadr < 21; ++tadr)  //light LEDs to signal finish
	//		{
	//			// flag finish
	//			leds1[tadr].r = 0;  // 
	//			leds1[tadr].g = 255;
	//			leds1[tadr].b = 0;
	//
	//			tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
	//			leds2[tadr].r = 0;  // 
	//			leds2[tadr].g = 255;  // 
	//			leds2[tadr].b = 0;  // 
	//
	//
	//			leds3[tadr].r = 0;  // 
	//			leds3[tadr].g = 255;
	//			leds3[tadr].b = 0;
	//
	//			tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
	//			leds4[tadr].r = 0;  // 
	//			leds4[tadr].g = 255;  // 
	//			leds4[tadr].b = 0;  // 
	//
	//
	//		}
	//
	//		G_dim = 1;
	//		SHOW_slow();
	//
	//		byte forever = 1;
	//
	//		while (forever == 1)   // print out the data in a forever loop
	//		{
	//			Serial.println("");
	//
	//			for (int n = 0; n < 22; ++n)  // print the data
	//			{
	//				int num2show = NUM_LEDS - (n * 22);
	//
	//
	//				Serial.print(num2show);
	//				Serial.print(F(": "));
	//				Serial.println(test_array[n]);
	//
	//
	//			}
	//		}
	//
	//
	//		//***** this is the data recovered  *******//////
	//
	//					/*
	//					numLEDs: G_max_flashes
	//					484: 14
	//					462: 14
	//					440: 15
	//					418: 16
	//					396: 16
	//					374: 17
	//					352: 19
	//					330: 20
	//					308: 21
	//					286: 23
	//					264: 24
	//					242: 27
	//					220: 29
	//					198: 32
	//					176: 36
	//					154: 41
	//					132: 47
	//					110: 56
	//					88: 69
	//					66: 81
	//					44: 81
	//					22: 82
	//
	//					*/
	//
	//
	//	}
	//
	//	// text depth testing
	//	if (G_test_number == 29)
	//	{
	//		G_special_char_select = 1;
	//		//	HALL_MEASURE3(22);  //find G_max_bins
	//
	//		G_text2 = 1;  // set to 1 to enable panels 3,4 display of text and graphics
	//
	//
	//		//text_array[0] = { "ABCD123456789" };
	//		//strcpy(text_array, "0123456789ABCDEFGH");
	//		//strcpy(scroll_text_array, "NEW METHOD NOW");
	//		strcpy(scroll_text_array, "AT  ~~~~****~~~~");
	//		//strcpy(scroll_text_array, "TTTTTT");
	//
	//		int stringSize = strlen(scroll_text_array);
	//
	//		G_depth = 3;
	//		//SET_VAR(G_depth * 22);
	//		//FastLED.clear();
	//		//FastLED.show();
	//
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 1, 0);
	//
	//
	//		//strcpy(scroll_text_array, "T  ~~**~~");
	//		//stringSize = strlen(scroll_text_array);
	//		//SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0);
	//
	//
	//
	//	}
	//
	//	////
	//	if (G_test_number == 30)
	//	{
	//
	//		SET_SLOW();
	//		CLEAR_ALL_LEDS();
	//		SHOW_slow();
	//		Serial.println("");
	//
	//		for (int x = 21; x > 10; --x)
	//		{
	//			for (int y = 0; y < 22; ++y)
	//			{
	//				int adr = GET_XY_ADR(x, y);
	//				int adr2 = GET_XY_ADR(x - 1, y);
	//
	//
	//				leds1[adr].r = 255;
	//				leds1[adr2].g = 255;
	//
	//				SHOW_slow();
	//				CLEAR_ALL_LEDS();
	//
	//				Serial.print(x);
	//				Serial.print(F(","));
	//				Serial.print(y);
	//				Serial.print(F(": "));
	//				Serial.println(adr);
	//
	//				//delay(100);
	//
	//			}
	//		}
	//	}
	//
	//	// test SHOW_fast at different depths
	//	if (G_test_number == 31)
	//	{
	//
	//
	//		CLEAR_ALL_LEDS();
	//		G_dim = 1;
	//
	//
	//		for (int y = 0; y < NUM_ROWS / 2; ++y)
	//		{
	//			fast_leds1[y].r = 255;
	//			fast_leds2[y].r = 255;
	//			fast_leds3[y].r = 255;
	//			fast_leds4[y].r = 255;
	//
	//		}
	//
	//		for (int y = NUM_ROWS / 2; y < NUM_ROWS; ++y)
	//		{
	//			fast_leds1[y].g = 255;
	//			fast_leds2[y].g = 255;
	//			fast_leds3[y].g = 255;
	//			fast_leds4[y].g = 255;
	//
	//		}
	//
	//		int depth = 3;
	//		int adr = 0;
	//		int adr2 = 0;
	//
	//		G_depth = depth;
	//
	//		//	fast_leds1[0].b=255;
	//
	//
	//		for (int x = NUM_COLUMNS - 1; x >= (NUM_COLUMNS - depth); x = x - 1)
	//			//for (int x = 21; x >= 19; --x)
	//		{
	//			for (int y = 0; y < NUM_ROWS; ++y)
	//			{
	//				adr = XY_ADR(x, y);
	//				//adr = GET_XY_ADR(x, y);
	//				adr2 = modify_adr(0, 0, adr);  // upside down
	//
	//				leds1[adr2] = fast_leds1[y];
	//				leds3[adr2] = fast_leds3[y];
	//
	//				leds2[adr] = fast_leds1[y];
	//				leds4[adr] = fast_leds3[y];
	//				//for (int x = NUM_COLUMNS - 1; x >= NUM_COLUMNS - depth; --x)
	//				//{
	//				//	for (int y = 0; y < NUM_ROWS; ++y)
	//				//	{
	//
	//				//		adr = GET_XY_ADR(x, y);
	//
	//				//		leds1[adr] = fast_leds1[y];
	//				//		leds3[adr] = fast_leds3[y];
	//
	//				//		adr2 = modify_adr(0, 0, adr);  // upside down
	//
	//				//		leds2[adr2] = fast_leds2[y];
	//				//		leds4[adr2] = fast_leds4[y];
	//
	//						//Serial.print(F("x="));
	//						//Serial.println(x);
	//						//Serial.print(F("y="));
	//						//Serial.println(y);
	//						//Serial.print(F("adr="));
	//						//Serial.println(adr);
	//
	//						//Serial.print(F("fast_leds1[y].r="));
	//						//Serial.println(fast_leds1[y].r);
	//						//Serial.print(F("fast_leds1[y].g="));
	//						//Serial.println(fast_leds1[y].g);
	//						//Serial.print(F("fast_leds1[y].b="));
	//						//Serial.println(fast_leds1[y].b);
	//						//Serial.print(F("y="));
	//						//Serial.println(y);
	//						//Serial.print(F("adr="));
	//						//Serial.println(adr);
	//
	//
	//
	//			}
	//		}
	//
	//		//SHOW_fast();
	//
	//		int num2show = 22 * depth;
	//		SHOW_var(num2show);
	//
	//		//SET_VAR(num2show);
	//		//FastLED.show();
	//
	//		//int adr = GET_XY_ADR(21, 0);
	//		//leds1[adr].r = 255;
	//		//adr = GET_XY_ADR(20, 0);
	//		//leds1[adr].g = 255;
	//
	//
	//
	//		//FastLED.show();
	//
	//
	//		//G_depth = 2;
	//		//SHOW_fast(G_depth);
	//
	//
	//		//Serial.println(F(""));
	//		//Serial.println(F("TEST 31"));
	//		//int adr = GET_XY_ADR(21, 0);
	//		//Serial.print(F("21="));
	//		//Serial.println(leds1[adr].r);
	//		//adr = GET_XY_ADR(20, 0);
	//		//Serial.print(F("20="));
	//		//Serial.println(leds1[adr].r);
	//		//Serial.println(F(""));
	//
	//		delay(100);
	//
	//	}
	//
	//	// test for loop
	//	if (G_test_number == 32)
	//	{
	//		int depth = 2;
	//
	//		Serial.println(F(""));
	//		Serial.println(F("TEST 32"));
	//
	//		//for (int x = NUM_COLUMNS - 1; x >= (NUM_COLUMNS - 2); x = x - 1)
	//		//{
	//
	//		//	Serial.print(F("x="));
	//		//	Serial.println(x);
	//		//}
	//
	//
	//
	//
	//
	//		for (int x = NUM_COLUMNS - 1; x >= (NUM_COLUMNS - depth - 1); x = x - 1)
	//			//for (int x = 21; x >= 19; --x)
	//		{
	//			Serial.println(F(""));
	//
	//			for (int y = 0; y < 3; ++y)
	//			{
	//				Serial.print(F("x="));
	//				Serial.println(x);
	//				Serial.print(F("y="));
	//				Serial.println(y);
	//			}
	//
	//		}
	//		delay(100);
	//	}
	//
	//	// test increasing x
	//	if (G_test_number == 33)
	//	{
	//		CLEAR_ALL_LEDS();
	//		FastLED.show();
	//
	//
	//
	//		fast_leds1[0].r = 255;
	//		fast_leds2[0].r = 255;
	//		fast_leds3[0].g = 255;
	//		fast_leds4[0].g = 255;
	//
	//		G_depth = 4;
	//		SET_VAR(G_depth * 22);
	//
	//
	//		int adr = 0;
	//		int adr2 = 0;
	//
	//		int num2show = G_depth * NUM_ROWS;
	//
	//		//if (G_active != NUM_LEDS_FAST) // if current set to SLOW LEDs
	//	//if (G_active != num2show) // if current set to SLOW LEDs
	//	//{
	//	//	//SET_FAST();
	//	//	SET_VAR(num2show);
	//	//}
	//
	//
	//		//for (int x = NUM_COLUMNS - 1; x >= (NUM_COLUMNS - G_depth - 1); x = x - 1)  // I don't understand why  x >= (NUM_COLUMNS - depth -1) rather than  x >= (NUM_COLUMNS - depth) but the extra -1 is needed for correct depth
	//		for (int x = 21; x >= 19; --x)
	//		{
	//			for (int y = 0; y < NUM_ROWS; ++y)
	//			{
	//
	//				adr = GET_XY_ADR(x, y);
	//
	//				leds1[adr] = fast_leds1[y];
	//				//leds3[adr] = fast_leds3[y];
	//
	//				//adr2 = modify_adr(0, 0, adr);  // upside down
	//
	//				//leds2[adr2] = fast_leds2[y];
	//				//leds4[adr2] = fast_leds4[y];
	//
	//
	//
	//				Serial.println(F(""));
	//				Serial.print(F("x="));
	//				Serial.println(x);
	//				Serial.print(F("y="));
	//				Serial.println(y);
	//				Serial.print(F("adr="));
	//				Serial.println(adr);
	//
	//				Serial.print(F("fast_leds1[y].r="));
	//				Serial.println(fast_leds1[y].r);
	//				Serial.print(F("fast_leds1[y].g="));
	//				Serial.println(fast_leds1[y].g);
	//				Serial.print(F("fast_leds1[y].b="));
	//				Serial.println(fast_leds1[y].b);
	//				//Serial.print(F("y="));
	//				//Serial.println(y);
	//				//Serial.print(F("adr="));
	//				//Serial.println(adr);
	//
	//
	//
	//			}
	//		}
	//
	//		//Serial.println(F(""));
	//		//Serial.println(F("SHOW_fast"));
	//		//adr = GET_XY_ADR(21, 0);
	//		//Serial.print(F("21="));
	//		//Serial.println(leds1[adr].r);
	//		//adr = GET_XY_ADR(20, 0);
	//		//Serial.print(F("20="));
	//		//Serial.println(leds1[adr].r);
	//		//Serial.println(F(""));
	//
	//		//SHOW_var(num2show);
	//		FastLED.show();
	//		delay(300);
	//
	//
	//
	//	}
	//
	//	// test ringing with arbitrary image
	//	if (G_test_number == 34)
	//	{
	//
	//		int img = 54;
	//		G_special_char_select = 3000;
	//
	//		for (int n = 0; n < 484; ++n)  // clear LEDs
	//		{
	//			leds1[n] = 0;
	//			leds2[n] = 0;
	//
	//			leds_buffer1[n] = 0;
	//			leds_buffer2[n] = 0;
	//		}
	//
	//		//LOAD_BMP_2BUFFER(G_special_char_select, 1);
	//		//LOAD_BMP_2BUFFER(G_special_char_select, 2);
	//		//
	//		////LOAD_BMP_PANEL(img, 5);  // load leds_buffer1
	//		////LOAD_BMP_PANEL(img, 6);  // load leds_buffer2
	//
	//		//for (int n = 0; n < 484; ++n)
	//		//{
	//		//	leds1[n] = leds_buffer1[n];
	//		//	leds2[n] = leds_buffer2[n];
	//		//}
	//
	//		//SHOW_slow();
	//		//delay(100);
	//
	//
	//		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");
	//
	//
	//		int stringSize = strlen(scroll_text_array);
	//
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 3, 0);
	//
	//
	//
	//	}
	//
	//	// test ringing with arbitrary image
	//	if (G_test_number == 35)
	//	{
	//		int img = 54;   // was 56
	//		int img2 = 60;
	//		int max_depth = 2;  // was 9
	//		int increment = 3;
	//		int ring_length = 48;  // 48=max
	//
	//		//for (int n = 1; n < max_depth; n=n+ increment)
	//		//{
	//		//	RING_with_IMAGE(img,img2, ring_length, 2, n);
	//		//}
	//
	//
	//		for (int n = 1; n < max_depth; n = n + increment)
	//		{
	//			RING_with_IMAGE(img, 0, 20, 2, n, 0);
	//		}
	//
	//		//img = 57;
	//		//for (int n = 1; n < max_depth; n = n + increment)
	//		//{
	//		//	RING_with_IMAGE(img, 0, 20, 2, n);
	//		//}
	//
	//		//img = 58;
	//		//for (int n = 1; n < max_depth; n = n + increment)
	//		//{
	//		//	RING_with_IMAGE(img, 0, 20, 2, n);
	//		//}
	//
	//
	//
	//
	//	}
	//
	//	// scroll text debug jitter
	//	if (G_test_number == 36)
	//	{
	//		HALL_MEASURE2(NUM_LEDS);  // find G_max_flashes, only need if speed changes
	//		G_startup_max_flashes = G_max_flashes;  // find G_max_flashes, only need if speed changes
	//
	//			//text_array[0] = { "ABCD123456789" };
	//			//strcpy(text_array, "0123456789ABCDEFGHIJKL");
	//		G_special_char_select = 1;
	//
	//		strcpy(scroll_text_array, "MURGETROID 3");
	//		//strcpy(scroll_text_array, "3");
	//		int stringSize = strlen(scroll_text_array);
	//		int hue = -1;  // white
	//		int speed = 4;
	//
	//		SCROLL_TEXT(scroll_text_array, stringSize, 1, speed, hue, 0, 0, 2, 0);
	//
	//		//DISPLAY_TEXT_ARRAY(scroll_text_array, scroll_text_array, G_max_bins, speed, -1, 0, 0, 0);  // display max_len number of text in the text
	//	}
	//
	//	// depth_effect for SHOW_fast
	//	if (G_test_number == 37)
	//	{
	//		fast_leds1[21].g = 255;  // green  ... top
	//		fast_leds3[21].g = 255;
	//
	//		fast_leds1[0].b = 255;  // blue
	//		fast_leds3[0].b = 255;
	//
	//
	//		//****
	//		fast_leds2[21].r = 255;  // yellow
	//		fast_leds2[21].g = 255;
	//
	//		fast_leds4[21].r = 255;  // yellow
	//		fast_leds4[21].g = 255;
	//
	//
	//		fast_leds2[0].r = 255;   // red
	//		fast_leds4[0].r = 255;
	//
	//		SHOW_fast(10, 1);
	//
	//		delay(300);
	//
	//
	//
	//
	//
	//
	//	}
	//
	//	// measure DON COM receive rate
	//	if (G_test_number == 38)
	//	{
	//
	//
	//		if (G_count == 0)
	//		{
	//			Serial.println(F("---> START:   test 38  <------ "));
	//			G_count = 1;
	//			DC_OUT_array[0] = 4;  // flag start of test to SLAVE
	//			DC_SEND();
	//		}
	//		else
	//		{
	//			++G_count;
	//		}
	//
	//		delay(450);  // 300 does not work, 400 works
	//
	//		//DC_OUT_array[0] = 2;  // test receiving
	//		//DC_SEND();
	//
	//		//delay(1000);
	//		//DC_CHECK_AND_DO();  // note: G_DC_received_flag set to 0 by DC_COMMAND_HANDLER()
	//
	//
	//		G_DC_received_flag = DC_RECEIVE_ARRAY();
	//
	//		if ((G_DC_received_flag == 1) && (DC_IN_array[0] == 2))  // start recording time
	//		{
	//			//	G_count2 = millis();
	//
	//		}
	//
	//		if ((G_DC_received_flag == 1) && (DC_IN_array[0] == 3)) // flag end of test
	//		{
	//			Serial.println("");
	//			Serial.println(F("END of DC TEST "));
	//			Serial.println("");
	//		}
	//
	//		if ((G_DC_received_flag == 1) && (DC_IN_array[0] == 3))  // stop recording time
	//		{
	//			//	G_count2 = millis() - G_count2;
	//
	//			Serial.println(F("test 38 "));
	//			Serial.print(F("G_DC_received_flag= "));
	//			Serial.println(G_DC_received_flag);
	//			Serial.print(F("DC_IN_array[0]= "));
	//			Serial.println(DC_IN_array[0]);
	//			Serial.print(F("DC_IN_array[1]= "));
	//			Serial.println(DC_IN_array[1]);
	//			Serial.print(F("DC_IN_array[2]= "));
	//			Serial.println(DC_IN_array[2]);
	//			Serial.print(F("DC_IN_array[3]= "));
	//			Serial.println(DC_IN_array[3]);
	//			Serial.print(F("G_count= "));
	//			Serial.println(G_count);
	//			//Serial.print(F("G_count2= "));
	//			//Serial.println(G_count2);
	//			Serial.println("");
	//		}
	//
	//		G_DC_received_flag = 0;  // must be cleared 
	//	}
	//
	//	/////////////////////////////////////////////////////////////////////////////////////
	//	// test static/stationary point
	//	if (G_test_number == 39)
	//	{
	//		int active_LEDs = 22 * 4;   //@300 RPM: two columns: 1 column=3 dots 84 flashes, 2 columns=3 dots, 4=3 dots 74 flashes, 5 columns=4 dots 61 flashes,  6 columns =4 dots 52 flashes, 8 col=6 dots 37 flashes
	//		int static max_flashes = 0;
	//		unsigned long start_count = 0;
	//		int adr = GET_XY_ADR(21-3, 11);  // set position where dot is displayed
	//		int adr_mod = modify_adr(0, 0, adr);
	//		byte static start = 0;
	//
	//		int static display_position = 40;   // rotation that display starts						
	//	   // display_position = display_position + 1;  // move start position
	//
	//		
	//
	//	//	CLEAR_ALL_LEDS();
	//	//	SHOW_slow();
	//
	//		if (start == 0)  // do once
	//		{
	//			start = 1; 
	//			SET_VAR(active_LEDs);
	//		    HALL_MEASURE2(active_LEDs);
	//		}
	//
	//
	//		Serial.println(F("test 39 "));
	//		Serial.print(F("display_position= "));
	//		Serial.println(display_position);
	//		Serial.print(F("max_flashes= "));
	//		Serial.println(max_flashes);
	//		Serial.println("");
	//
	//
	//		HALL_SYNC2();
	//		start_count = G_Hall_counts;
	//		//FastLED.clear();
	//
	//		for (int n = 0; n < max_flashes; ++n)
	//		{
	//			if (n == display_position)
	//			{
	//				
	//				leds1[adr] = CRGB(255, 255, 255);
	//				leds3[adr] = CRGB(255, 255, 255);
	//				leds2[adr_mod] = CRGB(255, 255, 255);
	//				leds4[adr_mod] = CRGB(255, 255, 255);
	//
	//				
	//				SHOW_var(active_LEDs);
	//				FastLED.clear(); 
	//				
	//
	//				//Serial.print(F("-->display_position= "));
	//				//Serial.println(display_position);
	//				//Serial.println("");
	//
	//			}
	//			else
	//			{
	//				//SHOW_fast(2, 0);
	//				SHOW_var(active_LEDs);
	//			}
	//		}
	//	}
	//
	//	if (G_test_number == 40)  // light specific address on each panel  t40
	//	{
	//
	//		int active_LEDs = 22 * 2;   // two columns
	//		int static max_flashes = 0;
	//		unsigned long start_count = 0;
	//		int adr = GET_XY_ADR(21, 11);  // set position where dot is displayed
	//		int adr_mod = modify_adr(0, 0, adr);
	//		byte static start = 0;
	//
	//		int static display_position = 20;   // rotation that display starts						
	//		display_position = display_position + 1;  // move start position
	//
	//
	//
	//	//	CLEAR_ALL_LEDS();
	//	//	SHOW_slow();
	//
	//		if (start == 0)  // do once
	//		{
	//			start = 1;
	//			SET_VAR(active_LEDs);
	//			//max_flashes = HALL_MEASURE2(active_LEDs);
	//		}
	//
	//
	//
	//		leds1[adr] = CRGB(255, 0, 0);  // red
	//		leds3[adr] = CRGB(0,255, 0);  // green
	//		leds2[adr_mod] = CRGB(0, 0, 255);  // blue
	//		leds4[adr_mod] = CRGB(255, 0, 255);  // magenta
	//
	//		
	//
	//		//fast_leds1[adr] = CRGB(255, 0, 0);  // red
	//		//fast_leds3[adr] = CRGB(0, 255, 0);  // green
	//		//fast_leds2[adr_mod] = CRGB(0, 0, 255);  // blue
	//		//fast_leds4[adr_mod] = CRGB(255, 0, 255);  // magenta
	//
	//		//SHOW_fast(2, 0);
	//		FastLED.show();
	//		
	//	//	SHOW_var(active_LEDs);
	//		//FastLED.clear();
	//
	//
	//
	//	}
	//
	//	///////////////////////////////
	//	if (G_test_number == 41)  // conversion of cartisian to cylindrical coordinates  t41
	//	{
	//		int scale = 21;  // sets size of object
	//		byte number_of_verticies = 4; 
	//		int x = 0;
	//		int y = 0;
	//		int z = 0; 
	//		
	//		
	//
	//		verts[0] = { 1,1,1 };  // top right 
	//		verts[1] = { 1,-1,1 }; // top left
	//		verts[2] = { -1,-1,1 }; // top left and back
	//		verts[3] = { -1,1,1 }; // top right and back
	//
	//
	//
	//		for (byte n = 0; n < number_of_verticies; ++n)
	//		{
	//
	//			x = scale * verts[n].x;
	//			y = scale * verts[n].y;
	//			z= scale * verts[n].z; 
	//
	//			CART2CYLIN(x, y, z);
	//		}
	//
	//
	//	}
	//
	//
	//	/////////////////////////////////////////////////////    t42
	//	if (G_test_number == 42)
	//	{
	//		byte active_columns = 6;  // number of active columns
	//		int num_leds = active_columns * 22; // number of active LEDs
	//		
	//		
	//		verts[0] = { 21,21,21 };  // top right 
	//		verts[1] = { 21,-21,21 }; // top left
	//		verts[2] = { -1,-1,1 }; // top left and back
	//		verts[3] = { -1,1,1 }; // top right and back
	//
	//		HALL_MEASURE2(num_leds);  // find G_max_flashes
	//
	//		HALL_SYNC2();
	//		FLASH_DRAW_LINE(0, 1); // v1 and v2 are indexs for verts[] array which contains shape verticies.  A line is drawn from v1 to v2
	//	}
	//
	//
	//	/////////////////////////////////////////////////////
	//	if (G_test_number == 43)  // test FLASH_DRAW_CYLIN_CORDINATES  t43
	//	{
	//		byte active_columns = 8;  // number of active columns
	//		int num_leds = active_columns * 22; // number of active LEDs
	//		
	//		int start_angle = 45; 
	//		int stop_angle = 45; 
	//		byte start_radius = 14; 
	//		byte stop_radius = 21;
	//		byte start_z = 10;
	//		byte stop_z = 21; 
	//		byte depth = 1; 
	//		static byte do_once = 0; 
	//		byte blanks = 3; // number of flashes to ignore at the end to prevent over wrap
	//		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command
	//
	//		SET_VAR(num_leds);
	//
	//		cylin[0] = { start_radius,start_angle,start_z};  // top right 
	//		cylin[1] = { stop_radius,stop_angle,stop_z }; // top left
	//
	//		cylin[2] = { 18 ,90, 0 };  // top right 
	//		cylin[3] = { 21 ,180,21 }; // top left
	//	
	//	//	if (do_once == 0)
	//		{
	//			HALL_MEASURE2(num_leds);  // find G_max_flashes
	//			do_once = 1;
	//		}
	//
	//		HALL_SYNC2();
	//		
	//		for (byte n=0 ; n<G_max_flashes-blanks ; ++n)
	//			{
	//				FLASH_DRAW_CYLIN_CORDINATES(0, 1, n, 0, depth);
	//			//	FLASH_DRAW_CYLIN_CORDINATES(2, 3, n, 171, depth);
	//				
	//				BT_interrupt = SHOW_var(num_leds);
	//				FastLED.clear();
	//
	//				if (BT_interrupt != 0) { break; }
	//
	//			}
	//
	//
	//	}
	//
	//	/////////////////////////////////////////////////////
	//	if (G_test_number == 44)  // fun with FLASH_DRAW_CYLIN_CORDINATES  t44
	//	{
	//		byte active_columns = 8;  // number of active columns
	//		int num_leds = active_columns * 22; // number of active LEDs
	//
	//		int start_angle = 90;
	//		int stop_angle = 90;   // was 100 with 3
	//		byte start_radius = 21;
	//		byte stop_radius = 21;
	//		byte start_z = 0;  // up and down
	//		byte stop_z = 21;  // up and down
	//		byte depth = 1;
	//		static byte do_once = 0;
	//		byte blanks = 4; // number of flashes to ignore at the end to prevent over wrap, was 10
	//		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command
	//
	//		SET_VAR(num_leds);
	//
	//		cylin[0] = { start_radius,start_angle,start_z };  // top right 
	//		cylin[1] = { stop_radius,stop_angle,stop_z }; // top left
	//
	//		
	//													  
	//		// create a star:: {radius, angle, z}
	//		cylin[2] = { 14 ,50, 10 };  
	//		cylin[3] = { 21 ,50,5 };       //*
	//			//cylin[4] = { 21 ,100,0 };
	//		cylin[5] = { 21 ,150,5 }; //<--
	//		cylin[6] = { 21 ,150,10 };
	//		cylin[7] = { 21 ,150,16 };     //*
	//			//cylin[8] = { 21 ,100,21 };
	//		cylin[9] = { 21 ,50,16 }; //<--
	//
	//		cylin[4] = { 14 ,100,0 };
	//		cylin[8] = { 21 ,100,21 };
	//
	//		if (do_once == 0)
	//		{
	//			HALL_MEASURE2(num_leds);  // find G_max_flashes
	//			do_once = 1;
	//		}
	//
	//		//HALL_SYNC2();
	//		
	//		byte tilt = 0;
	//		byte anit_tilt = active_columns - tilt;
	//
	//		for (int tilt = 0; tilt < active_columns; ++tilt)
	//		{
	//			HALL_SYNC2();
	//			
	//			anit_tilt = active_columns - tilt;
	//			
	//			// create a star:: {radius, angle, z}
	//			cylin[2] = { 21-tilt ,50, 10 };
	//			cylin[3] = { 21-tilt ,50,5 };       //*
	//			cylin[4] = { 21-tilt ,100,0 };
	//			cylin[5] = { 21-tilt ,150,5 }; //<--
	//			cylin[6] = { 21- anit_tilt ,150,10 };
	//			cylin[7] = { 21- anit_tilt ,150,16 };     //*
	//			cylin[8] = { 21- anit_tilt ,100,21 };
	//			cylin[9] = { 21- anit_tilt ,50,16 }; //<--
	//			
	//			
	//			
	//			for (byte flash = 0; flash < G_max_flashes-blanks; ++flash)
	//			{
	//
	//				FLASH_DRAW_CYLIN_CORDINATES(4, 8, flash, 171, depth);  // blue, verticle
	//				FLASH_DRAW_CYLIN_CORDINATES(5, 9, flash, 213, depth);  // purple top right to bottom left
	//				FLASH_DRAW_CYLIN_CORDINATES(2, 6, flash, 0, depth);  // red , horizontal
	//		        FLASH_DRAW_CYLIN_CORDINATES(3, 7, flash, 42, depth);  // yellow, bottom right to top left
	//				
	//
	//				BT_interrupt = SHOW_var(num_leds);
	//				FastLED.clear();
	//
	//				if (BT_interrupt != 0) { break; }
	//
	//			}
	//		}
	//
	//
	//	}
	//
	//	////////////////////////////////////////////////
	//	if (G_test_number == 45)  // test uP in base noise  t45
	//	{
	//
	//		
	//		SET_SLOW();
	//		LOAD_BMP(57);
	//		SHOW_slow();
	//		delay(50);
	//
	//		for (int n = 0; n < 1000; ++n)
	//		{
	//			FastLED.clear();
	//			SHOW_slow();
	//
	//			LOAD_BMP(58);
	//			G_dim = 253;
	//			DIM_SLOW_LEDS(G_dim);
	//			SHOW_slow();
	//			delay(1);   // this delay is necessary to prevent false data to the panels
	//		}
	//	}
	//
	//	////////////////////////////////////////////////
	//	if (G_test_number == 46)  // Measure G_max_flashes and blanks  t46
	//	{
	//		int num_leds = 0;
	//		byte blanks = 0;
	//		
	//		for (byte active_columns = 1; active_columns < 22; ++active_columns)
	//		{
	//			num_leds = active_columns * 22;
	//
	//			blanks = HALL_MEASURE2(num_leds);
	//
	//			//Serial.print(F("active_columns= "));
	//			//Serial.println(active_columns);
	//			//Serial.print(F("G_max_flashes= "));
	//			//Serial.println(G_max_flashes);
	//			//Serial.print(F("blanks= "));
	//			//Serial.println(blanks);
	//			//Serial.println("");
	//
	//
	//		}
	//
	//
	//	}
	//
	//	///////////////////////////////////////////////////////////
	////	if (G_test_number == 47)  // FFT  Don  beat detection experiment  t47
	////	{
	////
	////#define num_loops 1
	////#define run_time 30000 // 30 seconds...how long prior to displaying BPM
	////
	////		int beats = 0;  // keep track of how many beats detected
	////		int count = 0; 
	////		int count_at_threshold = 0;  // count when threshold is exceeded 
	////		
	////		unsigned long start_time = millis();
	////		unsigned long stop_time = 0;
	////		unsigned long delta_total_time = 0;
	////		
	////		int threshold = 8;
	////
	////
	////		unsigned long time_detect = millis();  // system time at which a peak is detected
	////		unsigned long time_detect_previous = millis();
	////		unsigned long time_delta = 0;
	////		int beats_per_min = 0;
	////		int BPM_array[num_loops];  // store BPM in an array
	////		byte band_detected_array[num_loops];  // store which band exceeded the threshold
	////		int data_above_threshold_array[num_loops]; // store the bar height value for the bin that triggered the threshold event
	////
	////		for (int n = 0; n < num_loops; ++n)  // initialize to 0
	////		{
	////			BPM_array[n] = 0;
	////			band_detected_array[n] = 0;
	////			data_above_threshold_array[n] = 0;
	////		}
	////
	////
	////		byte forever = 1;
	////
	////		//for (int loop=0; loop< num_loops; ++loop)
	////		while (millis() < start_time + run_time)  // loop a specified amount of time
	////		{
	////			FastLED.clear();
	////			// Compute FFT
	////			FFT_COMPUTE(); ////sample analog input and  Compute FFT
	////			G_COMB_bandValues = 1;  
	////			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 
	////			
	////			++count; 
	////
	////			// Process the FFT data into bar heights
	////			//for (byte band = 0; band < NUM_BANDS; band++) 
	////			for (byte band = 0; band < G_COMB_bandValues; band++)
	////			{
	////
	////				// Scale the bars for the display
	////				//int barHeight = bandValues[band] / AMPLITUDE;
	////				int barHeight = COMB_bandValues[band] / AMPLITUDE;
	////				if (barHeight > TOP) barHeight = TOP;
	////
	////				// Small amount of averaging between frames
	////				barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;
	////
	////				// Move peak up
	////				if (barHeight > peak[band]) {
	////					peak[band] = min(TOP, barHeight);
	////				}
	////
	////				//rainbowBars(band, barHeight);
	////				//whitePeak(band);
	////
	////				///////  beat detection stuff
	////				// note I added code to only save the highest bar height 
	////				//if ((barHeight > threshold)  && (oldBarHeights[band]<barHeight))
	////			    if ((barHeight > threshold) && (count > count_at_threshold+3) ) // don't allow two counts in a row to register as a beat
	////				{
	////					count_at_threshold = count; 
	////					
	////					++beats; 
	////
	////					rainbowBars(band, barHeight);
	////					
	////					time_detect = millis();
	////					
	////
	////					//if (time_detect_previous == 0)
	////					//{
	////					//	time_detect_previous = time_detect;
	////					//	
	////					//}
	////
	////					time_delta = time_detect - time_detect_previous;
	////					time_detect_previous = time_detect;
	////
	////					//if (time_delta > 0)  // save the data
	////					//{
	////
	////					//	beats_per_min = 60000 / time_delta;
	////					//	BPM_array[loop] = beats_per_min;
	////					//	band_detected_array[loop] = band;  // keep track of which band exceeded the threshold
	////					//	data_above_threshold_array[loop] = barHeight;
	////					//}
	////
	////				}
	////
	////
	////				// Save oldBarHeights for averaging later
	////				oldBarHeights[band] = barHeight;
	////			}
	////
	////			//++index;
	////
	////			//if (index > 20)  // leave while loop
	////			//{
	////			//	break;
	////			//}
	////
	////			SHOW_slow();
	////
	////		}
	////
	////		stop_time = millis();
	////		delta_total_time = stop_time - start_time;
	////
	////		if (SERIAL_MON == 2)
	////		{
	////			int BPM = beats * 60000/run_time ;
	////			
	////			Serial.print(F("--------- beats ="));
	////			Serial.println(beats);
	////			Serial.print(F("BPM ="));
	////			Serial.println(BPM);
	////			Serial.println("");
	////
	////
	////			
	////			//for (byte n = 0; n < num_loops ; ++n)  // print results
	////			//{
	////			//	
	////			//	
	////			//	
	////			//	Serial.print(F("BPM_array["));
	////			//	Serial.print(n);
	////			//	Serial.print(F("]="));
	////			//	Serial.println(BPM_array[n]);
	////			//	Serial.print(F("band_detected_array["));
	////			//	Serial.print(n);
	////			//	Serial.print(F("]="));
	////			//	Serial.println(band_detected_array[n]);
	////			//	Serial.print(F("data_above_threshold_array["));
	////			//	Serial.print(n);
	////			//	Serial.print(F("]="));
	////			//	Serial.println(data_above_threshold_array[n]);
	////			//	//Serial.print(F("time_delta="));
	////			//	//Serial.print(60000/ BPM_array[n]);
	////			//	
	////			//	Serial.print(F("delta_total_time="));
	////			//	Serial.println(delta_total_time);
	////			//	Serial.println("");
	////
	////			//}
	////		}
	////
	////
	////	}
	//
	//
	//
	//
	////	///////////////////////////////////////////////////////////
	////	if (G_test_number == 49)  // FFT  Don  beat detection experiment2...this did not work as well as test non-fft beat detector
	////	{
	////
	////#define num_loops 1
	////#define run_time 30000 // 30 seconds...how long prior to displaying BPM
	////
	////		int beats = 0;  // keep track of how many beats detected
	////		int count = 0;
	////		int count_at_threshold = 0;  // count when threshold is exceeded 
	////
	////		unsigned long start_time = millis();
	////		unsigned long stop_time = 0;
	////		unsigned long delta_total_time = 0;
	////
	////		int threshold = 5;  // was 10
	////
	////
	////		unsigned long time_detect = millis();  // system time at which a peak is detected
	////		unsigned long time_detect_previous = millis();
	////		unsigned long time_delta = 0;
	////		int beats_per_min = 0;
	////		int BPM_array[num_loops];  // store BPM in an array
	////		byte band_detected_array[num_loops];  // store which band exceeded the threshold
	////		int data_above_threshold_array[num_loops]; // store the bar height value for the bin that triggered the threshold event
	////
	////		for (int n = 0; n < num_loops; ++n)  // initialize to 0
	////		{
	////			BPM_array[n] = 0;
	////			band_detected_array[n] = 0;
	////			data_above_threshold_array[n] = 0;
	////		}
	////
	////		LOAD_BMP(59);
	////
	////		byte forever = 1;
	////
	////		//for (int loop=0; loop< num_loops; ++loop)
	////		while (millis() < start_time + run_time)  // loop a specified amount of time
	////		{
	////			//FastLED.clear();
	////			// Compute FFT
	////			FFT_COMPUTE(); ////sample analog input and  Compute FFT
	////			G_COMB_bandValues = 8;
	////			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 
	////
	////			++count;
	////
	////			// Process the FFT data into bar heights
	////			//for (byte band = 0; band < NUM_BANDS; band++) 
	////			//for (byte band = 0; band < G_COMB_bandValues; band++)
	////			{
	////				byte band = 1;  // base band only
	////
	////
	////				// Scale the bars for the display
	////				//int barHeight = bandValues[band] / AMPLITUDE;
	////				int barHeight = COMB_bandValues[band] / AMPLITUDE;
	////				if (barHeight > TOP) barHeight = TOP;
	////
	////				// Small amount of averaging between frames
	////				barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;
	////
	////				// Move peak up
	////				if (barHeight > peak[band]) {
	////					peak[band] = min(TOP, barHeight);
	////				}
	////
	////				//rainbowBars(band, barHeight);
	////				//whitePeak(band);
	////
	////				///////  beat detection stuff
	////				// note I added code to only save the highest bar height 
	////				//if ((barHeight > threshold)  && (oldBarHeights[band]<barHeight))
	////				
	////				//Serial.print(F("PreTh------ barHeight ="));
	////				//Serial.println(barHeight);
	////				//Serial.println("");
	////			
	////
	////				if ((barHeight > threshold) && (count > count_at_threshold + 3)) // don't allow two counts in a row to register as a beat
	////				{
	////					
	////					//Serial.print(F("--------- barHeight ="));
	////					//Serial.println(barHeight);
	////					//Serial.println("");
	////					
	////					
	////					count_at_threshold = count;
	////
	////					++beats;
	////
	////					//rainbowBars(band, barHeight);
	////					ROTATE_COLORS(1);
	////
	////					int adr = GET_XY_ADR(21, 19);
	////					
	////
	////					leds1[adr] = CHSV(171, 255, 255);  // blue 
	////					leds3[adr] = leds1[adr];
	////
	////					int adr2 = modify_adr(0, 0, adr);   //make image right side up or upside down
	////					leds2[adr2] = leds1[adr];
	////					leds4[adr2] = leds1[adr];
	////
	////					SHOW_slow();
	////
	////					time_detect = millis();
	////
	////
	////					//if (time_detect_previous == 0)
	////					//{
	////					//	time_detect_previous = time_detect;
	////					//	
	////					//}
	////
	////					time_delta = time_detect - time_detect_previous;
	////					time_detect_previous = time_detect;
	////
	////					//if (time_delta > 0)  // save the data
	////					//{
	////
	////					//	beats_per_min = 60000 / time_delta;
	////					//	BPM_array[loop] = beats_per_min;
	////					//	band_detected_array[loop] = band;  // keep track of which band exceeded the threshold
	////					//	data_above_threshold_array[loop] = barHeight;
	////					//}
	////
	////				}
	////
	////
	////				// Save oldBarHeights for averaging later
	////				oldBarHeights[band] = barHeight;
	////			}
	////
	////			//++index;
	////
	////			//if (index > 20)  // leave while loop
	////			//{
	////			//	break;
	////			//}
	////
	////			//SHOW_slow();
	////
	////		}
	////
	////		stop_time = millis();
	////		delta_total_time = stop_time - start_time;
	////
	////		//G_test_number = 48;
	////
	////		if (SERIAL_MON == 2)
	////		{
	////			int BPM = beats * 60000 / run_time;
	////
	////			Serial.print(F("--------- beats ="));
	////			Serial.println(beats);
	////			Serial.print(F("BPM ="));
	////			Serial.println(BPM);
	////			Serial.println("");
	////
	////
	////
	////			//for (byte n = 0; n < num_loops ; ++n)  // print results
	////			//{
	////			//	
	////			//	
	////			//	
	////			//	Serial.print(F("BPM_array["));
	////			//	Serial.print(n);
	////			//	Serial.print(F("]="));
	////			//	Serial.println(BPM_array[n]);
	////			//	Serial.print(F("band_detected_array["));
	////			//	Serial.print(n);
	////			//	Serial.print(F("]="));
	////			//	Serial.println(band_detected_array[n]);
	////			//	Serial.print(F("data_above_threshold_array["));
	////			//	Serial.print(n);
	////			//	Serial.print(F("]="));
	////			//	Serial.println(data_above_threshold_array[n]);
	////			//	//Serial.print(F("time_delta="));
	////			//	//Serial.print(60000/ BPM_array[n]);
	////			//	
	////			//	Serial.print(F("delta_total_time="));
	////			//	Serial.println(delta_total_time);
	////			//	Serial.println("");
	////
	////			//}
	////		}
	////
	////
	////	}
	//
	//
	//	if (G_test_number == 50)  // test MUSIC detector  t50
	//	{
	//		//for (int th = 0; th < 35; th = th + 5)
	//		//{
	//		//	
	//		//	
	//		//	SOUND_DETECT(th);
	//		//	delay(200);
	//
	//		//}
	//
	//		if (MUSIC_DETECT(50) == 1)
	//		{
	//			LOAD_BMP(15);
	//			SHOW_slow();
	//		}
	//		else
	//		{
	//			FastLED.clear();
	//			SHOW_slow();
	//		}
	//
	//
	//	}
	//
	//	///////////////////////////////////////////////////////////////////////////////////
	//	if (G_test_number == 51)  // test FFT, generate MNOTE data   t51
	//	{
	//		
	//		
	//		
	//		//if (vReal[i] > NOISE)
	//		
	//		//if (SOUND_DETECT2(SOUND_DETECT_THRESHOLD - 8, 0) == 1)  // also computes FFT
	//		{
	//			//for (int n = 2; n < (SAMPLES2 / 2); n++) // initialize
	//			//{
	//			//	vReal2[n] = 0;
	//			//}
	//			
	//			FFT2_COMPUTE();
	//
	//			int sum = 0;
	//			unsigned long mag = 0;
	//			unsigned long amplitude = 1000;
	//			static unsigned long time_SD = millis();  // time of sound detect
	//			unsigned long time_stamp = millis();
	//			//int noise = 800; // was 500
	//			byte index_bin = 0;  
	//
	//			
	//
	//			if ((time_stamp - time_SD) > 1000)  // can't have two sound detects closer than 100ms
	//			{
	//				//Serial.println(F("test 51"));
	//				//Serial.println(F(""));
	//				
	//				time_SD = millis();
	//
	//				Serial.println("");
	//
	//				for (int i = 2; i < (SAMPLES2 / 2); i++) // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.
	//				{
	//					//mag = (int)(vReal[i] / AMPLITUDE);
	//
	//					mag = (int)(vReal2[i] / amplitude);
	//
	//
	//					if ((mag > 1) && (index_bin < MNOTE_SIZE))
	//					{
	//						//Serial.print(F("vReal2["));
	//						//Serial.print(i);
	//						//Serial.print(F("]/AMPLITUDE= "));
	//						//Serial.println(mag);
	//						//sum = sum + mag;
	//
	//						
	//
	//						Serial.print(F("MNOTE[#].bin["));
	//						Serial.print(index_bin);
	//						Serial.print(F("]= "));
	//						Serial.print(i); // bin that data is in
	//						Serial.println(";");
	//
	//						Serial.print(F("   MNOTE[#].data["));
	//						Serial.print(index_bin);
	//						Serial.print(F("]= "));
	//						Serial.print((int)(vReal2[i] / amplitude));
	//						Serial.println(";");
	//
	//						++index_bin;
	//
	//					}
	//
	//				}
	//
	//				//Serial.print(F("++++  SUM = "));
	//				//Serial.println(sum);
	//
	//			}
	//
	//		}
	//
	//	}
	//
	//	//////////////////////////////////////////////////////////////
	//	if (G_test_number == 52)  // test NOTE_DETECT  t52
	//	{
	//		//  ****  IMPORTANT  ****:   also un - comment Serial.prints in FIND_MAX_CORRELATION_VALUE()
	//
	//	// NOTE: FFT2:   bin width resolution = 8KHz sample rate/512 samples = 15Hz per bin
	//	// for FFT, 125us/sample --> 64ms/512 samples
	//
	//		/* NOTE detection works by using FFT2 then running FIND_MAX_CORRELATION_VALUE().  
	//		This is needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2.
	//		G_ND_correlation is the maximum correlation from any of the MNOTES relative to the FFT2 bins (all bins).
	//		The threshold for NOTE_DETECT2 is a fixed fraction of G_ND_correlation. 
	//		Also, all the MNOTE data is scaled according to MNOTE[].gain_factor. The MNOTE data is retrieved from TEST #51. 
	//		This data is captured from the microphone after playing each note. But, because playing a note multiple times results in 
	//		data that is not consistant in amplitude, I need to scale the MNOTE data to normalize it. 
	//		The MNOTE[].gain_factor is obtained by playing a NOTE multiple times and finding the maximum correlation value
	//		as reported by NOTE_DETECT2. I then normalized everything to NOTE 0's maximum correlation value. 		
	//		*/
	//		
	//		
	//		// NOTE: FFT bin width resolution = 40KHz sample rate/1024 samples = 39Hz per bin
	//		// highest freq. note 16 E5 = 659 Hz --> 659/39 = bin 17
	//		// lowest freq. note 0 C4 =261 Hz --> 261/39 = bin 6 or 7
	//		
	//		//byte CHOOSE_NOTE_DETECT_type = 1;  // 0=find most likely note,  1 = test an individual note
	//		unsigned long time_stamp = millis();
	//		static unsigned long time_SD = millis();  // time of sound detect
	//		unsigned long amplitude = 1000;  // was 2000
	//		int noise = 800; // was 500
	//
	//		if ((time_stamp - time_SD) > 1000)  // can't have two sound detects closer than 100ms
	//		{
	//			//byte sd = SOUND_DETECT2(SOUND_DETECT_THRESHOLD, 0);
	//			
	//			//byte sd = SOUND_DETECT2(4, 0);  // threshold was 2
	//			byte sd = SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0);
	//			
	//			if (sd == 1)
	//				//if (SOUND_DETECT2(SOUND_DETECT_THRESHOLD - 8, 0) == 1)
	//			{
	//				byte detected_note = 0;
	//
	//				FFT2_COMPUTE();
	//				FIND_MAX_CORRELATION_VALUE();  // needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2
	//
	//				time_SD = millis();
	//
	//				Serial.print(F("$$$$$------->>>> G_ND_correlation ="));
	//				Serial.println(G_ND_correlation);
	//				Serial.println(F(""));
	//			
	//			///////////use NOTE_DETECT
	//			//	if (CHOOSE_NOTE_DETECT_type == 0)
	//			//	{
	//			//		detected_note = FIND_MAX_CORRELATION_VALUE();
	//
	//			//		Serial.print(F("*****------->>>>   detected NOTE="));
	//			//		Serial.println(detected_note);
	//			//		Serial.println(F(""));
	//			//	}
	//
	//			////////////////////////////////////////////////////
	//
	//			///////// use NOTE_DETECT2
	//			//	if (CHOOSE_NOTE_DETECT_type == 1)
	//				{
	//					int threshold = (G_ND_correlation * NOTE_DETECT_THRESHOLD) / 100;  // take 80% to set threshold;
	//					int threshold2 = threshold;  // this copy needed to calculate correct threshold when note>12
	//					byte detected = 0;
	//				
	//
	//					for (byte note = 0; note < NUMBER_OF_MNOTES; ++note)
	//					{
	//					//	if (note > 12) { threshold = (threshold2*40)/100; }  // higher note have lower threshold, was 60
	//						
	//						detected = NOTE_DETECT2(note, threshold);
	//
	//						
	//						if (detected == 1)
	//						{
	//							//  ****  IMPORTANT  ****:   also un - comment Serial.prints in FIND_MAX_CORRELATION_VALUE()
	//
	//							Serial.print(F("*****------->>>>   detected NOTE="));
	//							Serial.println(note);
	//							Serial.println(F(""));
	//
	//							Serial.print(F("%%%%%------->>>> threshold="));
	//							Serial.println(threshold);
	//							Serial.println(F(""));
	//
	//						}
	//
	//					}
	//
	//					Serial.print(F("_________________________________________________"));
	//					Serial.println(F(""));
	//					Serial.println(F(""));
	//				}
	//
	//				////////////////////////////////////////////
	//
	//
	//				//for (byte band = 0; band < 22; ++band)
	//				//{
	//
	//				//	if (bandValues[band]/AMPLITUDE > 0)
	//				//	{
	//				//		Serial.print(F("bandValues["));
	//				//		Serial.print(band);
	//				//		Serial.print(F("]/AMPLITUDE= "));
	//				//		Serial.println(bandValues[band]/AMPLITUDE);
	//				//	}
	//
	//				//}
	//
	//
	//				//for (byte band = 0; band < 22; ++band)
	//				//{
	//
	//
	//				//	Serial.print(F("MNOTE[#]["));
	//				//	Serial.print(band);
	//				//	Serial.print(F("]= "));
	//				//	Serial.print(bandValues[band] / AMPLITUDE);
	//				//	Serial.println(";");
	//
	//				//}
	//
	//
	//				//////////////
	//
	//				//for (int i = 2; i < (SAMPLES2 / 2); i++) 
	//				//{       // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.
	//
	//				//	// print in MNOTE format
	//				//	if (vReal[i] > noise) 
	//				//	{                    // A
	//
	//				//	Serial.print(F("MNOTE[#]["));
	//				//	Serial.print(i);
	//				//	Serial.print(F("]= "));
	//				//	Serial.print((int)(vReal2[i] / amplitude));
	//				//	Serial.println(";");
	//
	//
	//				//	}
	//
	//				//}
	//
	//
	//
	//
	//
	//
	//
	//			}
	//		}
	//	}
	//
	//
	//	///////////////////////////////////////////////////////////
	//	if (G_test_number == 53)  // test dimming t53
	//	{
	//			Serial.println(F("test 53"));
	//			
	//			
	//		byte dim_rate = 100;  // this level dims to black in 10 steps
	//		unsigned long time_stamp = millis();
	//		
	//		FastLED.clear();
	//
	//		LINE(0, 11, 11, 11, 0);
	//
	//		FastLED.show();
	//
	//		byte always = 1;
	//		int n=0;
	//
	//		//for (int n = 0; n < 10; ++n)
	//		while (always==1)
	//		{
	//
	//			Serial.print(F("loop count="));
	//			Serial.println(n);
	//			Serial.println(F(""));
	//
	//
	//			if (n > 20) { n = 0; }
	//			
	//
	//			if (n == 0)
	//			{
	//				LINE(0, 11, 11, 11, 0);
	//			}
	//
	//			if (n == 5)
	//			{
	//				LINE(0, 5, 11, 5, 30);
	//			}
	//
	//
	//			for (int i = 0; i < NUM_LEDS; ++i)
	//			{
	//				leds1[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
	//				leds2[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
	//				leds3[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
	//				leds4[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
	//			}
	//			
	//			FastLED.show();
	//			delay(1000);
	//
	//			++n;
	//
	//		}
	//
	//
	//		
	//	}
	//
	//	/////////////////////////////////////////////////////////////////
	//	if (G_test_number == 54)  // test BEAT_SHOWS   t54 
	//	{
	//		
	//		byte forever = 1;
	//		unsigned long beat_count = 0;
	//		byte enable = 1;
	//		byte hue = 30; 
	//		
	//		while (forever == 1)
	//		{
	//			++beat_count;
	//			
	//			BEAT_SHOW_11(beat_count, 6, enable, 0, 60);  // orange circle moving up and down while changing radius
	//
	//			FastLED.show();
	//
	//			delay(500);
	//		}
	//
	//		
	//
	//	}
	//
	//	/////////////////////////////////////////////////////////////////
	//	if (G_test_number == 55)  // test MERGE_LOAD  t55
	//	{
	//		byte note_offset = 12;
	//		byte offset_note = 0;
	//		
	//		FastLED.clear();
	//		FastLED.show();
	//
	//		delay(500);
	//
	//		MAP_MNOTE_HUES(0, 255); // assign a HUE to each musical note
	//
	//		for (byte mnote = 0; mnote < NUMBER_OF_MNOTES; ++mnote)
	//		{
	//			MERGE_LOAD(95, MNOTE[mnote].hue);
	//
	//			FastLED.show();
	//
	//			delay(500);
	//
	//			offset_note = mnote + note_offset; 
	//
	//			if (offset_note >= NUMBER_OF_MNOTES) { offset_note = offset_note - note_offset; }
	//
	//			MERGE_LOAD(89, MNOTE[offset_note].hue);
	//
	//			FastLED.show();
	//
	//			delay(500);
	//
	//
	//			FastLED.clear();
	//		}
	//
	//
	//
	//
	//
	//
	//
	//		//LOAD_BMP(95);
	//
	//		//FastLED.show();
	//
	//		//delay(1000);
	//
	//		////MERGE_LOAD(89);
	//		//LOAD_BMP(89);
	//
	//		//FastLED.show();
	//
	//		//delay(1000);
	//
	//
	//
	//
	//	}
	//
	//	/////////////////////////////////////////////////////////////////
	//	if (G_test_number == 56)  // test panel tilt alignment   t56
	//	{
	//		
	//
	//		int adr1 = XY_ADR(21, 0);  // for panels 1
	//		int adr2 = modify_adr(0, 0, adr1);  // for panel 2
	//		int adr3 = XY_ADR(21, 1);  // for panels 3
	//		int adr4 = modify_adr(0, 0, adr3);  // for panel 4
	//
	//		FastLED.clear();
	//
	//
	//		//// bottom 
	//		leds1[adr1] = CHSV(0, 255, 255);
	//		leds2[adr2] = CHSV(0, 255, 255);
	//		leds3[adr3] = CHSV(85, 255, 255);
	//		leds4[adr4] = CHSV(85, 255, 255);
	//
	//
	//		adr1 = XY_ADR(21, 20);  // for panels 1
	//		adr2 = modify_adr(0, 0, adr1);  // for panel 2
	//		adr3 = XY_ADR(21, 21);  // for panels 3
	//		adr4 = modify_adr(0, 0, adr3);  // for panel 4
	//		
	//		//top
	//		leds1[adr1] = CHSV(0, 255, 255);
	//		leds2[adr2] = CHSV(0, 255, 255);
	//		leds3[adr3] = CHSV(85, 255, 255);
	//		leds4[adr4] = CHSV(85, 255, 255);
	//	
	//		FastLED.show();
	//
	//		delay(1000);
	//
	//		FastLED.clear();
	//
	//		//////////// bottom  aligned
	//		// all panels aligned
	//		adr1 = XY_ADR(21, 0);  // for panels 1
	//		adr2 = modify_adr(0, 0, adr1);  // for panel 2
	//		adr3 = XY_ADR(21, 0);  // for panels 3
	//		adr4 = modify_adr(0, 0, adr3);  // for panel 4
	//
	//
	//		leds1[adr1] = CHSV(0, 255, 255);
	//		leds2[adr2] = CHSV(0, 255, 255);
	//		leds3[adr3] = CHSV(0, 255, 255);
	//		leds4[adr4] = CHSV(0, 255, 255);
	//
	//		// all panels aligned
	//		adr1 = XY_ADR(21, 1);  // for panels 1
	//		adr2 = modify_adr(0, 0, adr1);  // for panel 2
	//		adr3 = XY_ADR(21, 1);  // for panels 3
	//		adr4 = modify_adr(0, 0, adr3);  // for panel 4
	//
	//
	//		leds1[adr1] = CHSV(85, 255, 255);
	//		leds2[adr2] = CHSV(85, 255, 255);
	//		leds3[adr3] = CHSV(85, 255, 255);
	//		leds4[adr4] = CHSV(85, 255, 255);
	//
	//
	//		//////////////// top  aligned
	//		// all panels aligned
	//		adr1 = XY_ADR(21, 20);  // for panels 1
	//		adr2 = modify_adr(0, 0, adr1);  // for panel 2
	//		adr3 = XY_ADR(21, 20);  // for panels 3
	//		adr4 = modify_adr(0, 0, adr3);  // for panel 4
	//
	//
	//		leds1[adr1] = CHSV(0, 255, 255);
	//		leds2[adr2] = CHSV(0, 255, 255);
	//		leds3[adr3] = CHSV(0, 255, 255);
	//		leds4[adr4] = CHSV(0, 255, 255);
	//
	//		// all panels aligned
	//		adr1 = XY_ADR(21, 21);  // for panels 1
	//		adr2 = modify_adr(0, 0, adr1);  // for panel 2
	//		adr3 = XY_ADR(21, 21);  // for panels 3
	//		adr4 = modify_adr(0, 0, adr3);  // for panel 4
	//
	//
	//		leds1[adr1] = CHSV(85, 255, 255);
	//		leds2[adr2] = CHSV(85, 255, 255);
	//		leds3[adr3] = CHSV(85, 255, 255);
	//		leds4[adr4] = CHSV(85, 255, 255);
	//
	//		FastLED.show();
	//
	//		delay(1000);
	//
	//
	//	}
	//
	//	if (G_test_number == 57)  // test BASE communication detector  t57
	//	{
	//		Serial.println(F("test 57"));
	//		
	//		byte base_com_detected = DETECT_BASE_COMMUNICATION2();   // check if BASE is trying to communicate with the HEAD
	//
	//
	//		if (base_com_detected == 1)
	//		{
	//			Serial.println(F("+++++   base communication detected"));
	//			
	//			LOAD_BMP(15);
	//			SHOW_slow();
	//			delay(500);
	//		}
	//		else
	//		{
	//			Serial.println(F("-------  NO base communication detected"));
	//			
	//			FastLED.clear();
	//			SHOW_slow();
	//			delay(500);
	//		}
	//
	//
	//	}
	//
	//


	////////////////////


			//if (G_test_number == 58)  // blank ready to use
			//	{
			//		


			//	}


		////////////////////////////////////////////////  END OF DO_TEST ////////////////////////////////////////////////////////


}





//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
/*********************************************  SHOW_TIME  ***********************************************************/
//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


// NOTE: the PRODUCTION control is handled in loop()
byte PRODUCTION_1()  // return 1 if PRODUCTION is complete
{

#define NUMBER_OF_PRODUCTION1_SHOWS 28 // sets the number of shows in the PRODUCTION

	//int number_of_shows = 100;       // number of SHOWs
	int show_num = 0;

	int stringSize = 0;
	int hue = -1;  // white
	byte BT_interrupt = 0;



	//CLEAR_ALL_LEDS();
	//HALL_SYNC2();
	//SHOW_slow();


	if ((SERIAL_MON == 1) && ((G_DC_received_flag == 1) || (G_BT_message_flag == 1)))
	{
		//Serial.println("");
		//Serial.println(F("$$$$$$$$$$$$$$$$$$$$$$$$$$$$START of DO_SHOW"));
		//Serial.print(F("G_DC_received_flag= "));
		//Serial.println(G_DC_received_flag);
		//Serial.print(F("G_BT_message_flag= "));
		//Serial.println(G_BT_message_flag);
		//Serial.print(F("G_show_num= "));
		//Serial.println(G_show_num);
		//Serial.println("");


	}

	//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	if ((G_continuous_SPECIAL_mode == 0) && (G_continuous_SPECIAL_mode_was_ON == 1))
	{
		G_continuous_SPECIAL_mode_was_ON = 0;

		CLEAR_FAST_LEDS();

		SHOW_fast(1, 0);
	}


	// ********* old SHOW handler  

	//++G_show_num;
	//int rv=DC_RECEIVE_ARRAY();
	//int rv = 0;

	//G_show_num = 1;
	//DC_COMMAND_HANDLER();



	if (G_BT_message_flag == 0)
	{
		G_BT_message_flag = CHECK_BLUE_TOOTH();

		/*Serial.println("In DO_SHOW2 after CHECK_BLUE_TOOTH");
		Serial.print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= ");
		Serial.println(G_BT_message_flag);
		Serial.println("");*/
	}

	if (G_BT_message_flag == 1)
	{



		//int stringSize = strlen(text_array);
		Serial.println(F("In DO_SHOW after CHECK_BLUE_TOOTH"));
		Serial.print(F("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= "));
		Serial.println(G_BT_message_flag);
		Serial.println("");
		Serial.print(F("G_message= "));
		Serial.println(G_message);
		//Serial.print("stringSize= ");
		//Serial.println(stringSize);
		Serial.print(F("G_BT_command= "));
		Serial.println(G_BT_command);
		Serial.println("");

		/*SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0, 0);
		G_BT_message_flag = 0;*/


		BLUE_TOOTH_COMMAND_HANDLER(1);  // execute the BT command  ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
		DC_COMMAND_HANDLER();  // need this if the BT COMMAND HANDLER calls TRANSFER2_SLOW which will transfer back a DON_COM command
		delay(50);


	}

	if (G_continuous_SPECIAL_mode == 1)
	{
		G_show_num = 255;
	}

	//if ((G_show_num > number_of_shows) || (G_show_num == 1))
	//{
	//	if ((G_show_num != 255) && (G_show_num != 254))  // 255 is a flag to show BT text_array
	//	{
	//		G_show_num = 1;
	//		HALL_MEASURE3(22);  //find G_max_bins
	//	}

	//}



	/////////////////////////////  THE SHOW ///////////////////////////


	//	HALL_MEASURE3(22);  //find G_max_bins

		// -------------->    get next show number  <--------------------------
	show_num = SHOW_HANDLER(NUMBER_OF_PRODUCTION1_SHOWS);  ////// SHOW HANDLER  ///////////



	if (SERIAL_MON == 1)
	{
		Serial.println("");
		Serial.println(F("------> PRODUCTION 1 <------ "));
		Serial.print(F("******************************************* G_show_num= "));
		Serial.println(G_show_num);
		Serial.print(F("show_num= "));
		Serial.println(show_num);
		Serial.println("");
	}

	if (show_num == 0)   // CREATE mode
	{
		unsigned long present_system_time = millis();
		unsigned long delta_time = present_system_time - G_CREATE_MODE_start_time;

		//Serial.println("");
		//Serial.println(F("--------->  DO_SHOW:"));
		//Serial.print(F(" G_CREATE_MODE_start_time="));
		//Serial.println(G_CREATE_MODE_start_time);
		//Serial.print(F(" delta_time="));
		//Serial.println(delta_time);
		//Serial.print(F(" G_executing_CREATE_mode="));
		//Serial.println(G_executing_CREATE_mode);
		//Serial.print(F(" G_PLAY_SAVES_MODE_ON="));
		//Serial.println(G_PLAY_SAVES_MODE_ON);
		//Serial.println("");

		if (G_PLAY_SAVES_MODE_ON == 0) //  not PLAY SAVES
		{

			if (((delta_time) > MAXIMUM_IDLE_CREATE_MODE_TIME))  // EXIT CREATE MODE and execute SHOW
			{
				// NOTE: G_CREATE_MODE_start_time is set in the BT command handler every time a BT command is called
				G_BT_command = 'L'; // turn off CREATE MODE and turn on SHOW

				//Serial.println("");
				//Serial.println(F("--------->  before BT command to exit CREATE MODE:"));
				//Serial.println("");

				BLUE_TOOTH_COMMAND_HANDLER(1);
				return 1;
			}

		}

		CREATE_MODE();
		//Serial.println(F("DO_SHOW: before DUMP after CREATE_MODE(): show_num=0"));
		//DUMP_LED_ARRAY(leds1, NUM_LEDS);

	}

	//////  SHOW 255...show BT text
	if (G_show_num == 255)
	{
		SHOW_255();

		//HALL_MEASURE3(22);

		////stringSize = strlen(text_array);

		//stringSize=ADD_SPECIAL_TEXT();  // add special image Text characters to text_array

		////stringSize = strlen(text_array);  // new string size
		//
		//SCROLL_TEXT(text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0);
		//BT_and_DC_CHECKandDO();
	}

	if (G_show_num == 254)  // works in conjunction with DC command 11
		// display G_SAVED image 
	{
		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");

		int stringSize = strlen(scroll_text_array);

		//HALL_MEASURE3(22);  //find G_max_bins
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 2, 0);
		G_special_char_select = 1;
		BT_and_DC_CHECKandDO();

	}


	if (show_num == 1)
	{
		//G_skip_RESET = 1; // don't allow a RESET

		// note: I added the below back in on 04/14/24  to try an fix text panel display offset timing between panel1 and panel2 
		CALIBRATE_MAX_FLASHES(1);  // find G_max_flashes, only need if speed changes......had to comment out as this causes RESET during a SCROLL text to screw up

		//text_array[0] = { "ABCD123456789" };
		//strcpy(text_array, "0123456789ABCDEFGHIJKL");
		G_special_char_select = 1;


		strcpy(scroll_text_array, "MURGETROID3");
		stringSize = strlen(scroll_text_array);
		hue = -1;  // white
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 2, hue, 0, 0, 2, 0);

		//G_skip_RESET = 0; //allow for a RESET
	}

	if (show_num == 2)
	{
		//G_skip_RESET = 1; // don't allow a RESET

		strcpy(scroll_text_array, "~~~~BY DON WILE AND KM****");
		stringSize = strlen(scroll_text_array);
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 2, hue, 2, 0, 2, 0);

		//G_skip_RESET = 0; //allow for a RESET
	}




	//+++++++++++++++++++++++++++++++++++++++++
	if (show_num == 3)
	{

		//int num_bmps = 20;
		int num_bmps = 9;
		int start = 1;   // starting bmp

		CLEAR_ALL_LEDS();

		//for (int n = 1; n <= num_bmps; ++n)
		for (int n = start; n < (num_bmps + start); ++n)
		{
			if (G_BT_connected_flag != 1)  // allow for quick abort
			{

				Serial.println("");
				Serial.println("P1: show_num=3");
				Serial.print("bmp_num= ");
				Serial.println(n);
				Serial.println("");

				LOAD_BMP(n);
				//HALL_SYNC2();


				//FastLED.clear();  // set to black all LEDs..
				//LOAD_BMP_PANEL(n, 2);    // note: panel 2 has G_upside_down=0
				//LOAD_BMP_PANEL(n, 1);    // note: panel 2 has G_upside_down=0

				SHOW_slow();
				BT_DELAY(1000);
			}

		}
	}

	/////////////////////////////////////
	if (show_num == 4)
	{
		CLEAR_ALL_LEDS();
		LOAD_BMP(42);
		SHOW_slow();

		G_special_char_select = 1;
		strcpy(scroll_text_array, "************************");
		stringSize = strlen(scroll_text_array);
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, hue, 2, 1, 2, 0); ///// ringed images    TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	}

	///////////////////////////////////////////
	if (show_num == 5)
	{

		CLEAR_ALL_LEDS();
		LOAD_BMP(43);
		SHOW_slow();

		G_special_char_select = 1;
		strcpy(scroll_text_array, "~~~~~~~~~~~~~~~~~~~~~~~~");
		stringSize = strlen(scroll_text_array);
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, hue, 2, 1, 2, 0);

		CLEAR_ALL_LEDS();
		SHOW_slow();
	}

	//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	if (show_num == 6)
	{
		int start = 10;
		int num_bmps = 11;  // was 11  then 8


		for (int n = start; n < (num_bmps + start); ++n)
		{

			if (G_BT_connected_flag != 1)  // allow for quick abort
			{
				/*Serial.println("");
				Serial.println("TEST 5");
				Serial.print("bmp_num= ");
				Serial.println(n);
				Serial.println("");*/

				LOAD_BMP(n);
				//HALL_SYNC2();


				SHOW_slow();
				BT_DELAY(1000);
			}
		}

		CLEAR_ALL_LEDS();
		SHOW_slow();


	}

	//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	if ((show_num == 7) && (1 == 0))   // SEASONAL  
	{
		G_special_char_select = 1;
		byte previous_AUTO_DIM_LEVEL = G_AUTO_DIM_LEVEL;

		byte banner = 0;   // no banner
		//byte banner = 3;

		//strcpy(scroll_text_array, "~~~~LOVE~~~~");

		LOAD_BMP(64);  // XMAS tree
		//LOAD_BMP(65);  // Easter egg 



		//LOAD_BMP(97);  // Westmont tree logo
		SHOW_slow();



		//strcpy(scroll_text_array, "~~^^HAPPY EASTER^^~~");
		G_AUTO_DIM_LEVEL = 254;  // egg needs dimmer level
		//strcpy(scroll_text_array, "^^^^HAPPY EASTER^^^^");
		//strcpy(scroll_text_array, "^^^^WESTMONT ROCKS^^^^");



		strcpy(scroll_text_array, "####MERRY CHRISTMAS####");
		//strcpy(scroll_text_array, "~~~~HAPPY LABOR DAY~~~~");
		//strcpy(scroll_text_array, "~~~~WELCOME PAUL and BARBARA~~~~");
		stringSize = strlen(scroll_text_array);

		//Serial.print(F("S7: 4  : stringSize="));
		//Serial.println(stringSize);
		//Serial.print(F("scroll_text_array="));
		//Serial.println(scroll_text_array);



		SCROLL_TEXT(scroll_text_array, stringSize, 1, 2, -1, banner, 0, 2, 0);

		BT_DELAY(300);

		G_AUTO_DIM_LEVEL = previous_AUTO_DIM_LEVEL;  // restore default auto dim level

		CLEAR_ALL_LEDS();
	}


	//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	if (show_num == 8)   // NEW YEAR ball dropping
	{
		byte hue_index = 0;
		byte rad = 3;  // radius
		byte skip = 0; // set to 1 to skip text display

		CLEAR_ALL_LEDS();

		//hues[MAX_HUES];



		for (int vert = 21 - rad; vert > rad; --vert)  // ball starts at top, ball drop
		{
			LINE(0, 21, 0, 0, 0);

			SPHERE(rad, 0, vert, hues[vert / 2]);
			LINE(0, vert, rad, vert, -1);  // white line though center of sphere
			LINE(0, vert - 1, rad, vert - 1, -1);  // white line though center of sphere

			SHOW_slow();

			BT_DELAY(200);

			if (vert != rad + 1)  // don't erase last sphere
			{
				SPHERE(rad, 0, vert, ERASE_IMAGE);
				LINE(0, vert, rad, vert, ERASE_IMAGE);  // white line though center of sphere
				LINE(0, vert - 1, rad, vert - 1, ERASE_IMAGE);  // white line though center of sphere
			}

		}

		//   generate moving lines when ball hits bottom
		for (byte repeat = 0; repeat < 4; ++repeat)
		{
			byte moving_line_count = 4;  // first time executing

			if (repeat > 0) { moving_line_count = 1; }  // greater than 1st time executing


			for (byte loop = 0; loop < moving_line_count; ++loop)  // repeat 
			{
				byte xs = 0;
				byte ys = 0;
				byte xe = 1;
				byte ye = 1;


				for (byte pos = 0; pos < 20; ++pos)
				{

					xs = xs + 1;
					ys = ys + 1;
					xe = xe + 1;
					ye = ye + 1;

					//	byte post_hue = hues[(MAX_HUES - pos % 3) / 2];
					byte post_hue = hues[pos % 3];

					LINE(0, 21, 0, 0, post_hue);  // vertical multi color line

					//1st set
					LINE(21 - xs, 21 - ys, 21 - xe, 21 - ye, hues[MAX_HUES - (pos / 2)]);
					LINE(xs, 21 - ys, xe, 21 - ye, hues[pos % 5]);
					LINE(xs, ys, xe, ye, hues[pos / 2]);

					// 2nd set
					LINE(21 - xs - 1, 21 - ys - 1, 21 - xe - 1, 21 - ye - 1, hues[MAX_HUES - (pos % 4)]);
					LINE(xs - 1, 21 - ys - 1, xe - 1, 21 - ye - 1, hues[pos % 6]);
					LINE(xs - 1, ys - 1, xe - 1, ye - 1, hues[pos / 2]);




					SPHERE(rad, 0, rad + 1, hues[MAX_HUES - (pos / 2)]);
					LINE(0, rad, rad, rad, -1);  // white line though center of sphere

					SHOW_slow();


					// erase

					// 1st set
					LINE(21 - xs, 21 - ys, 21 - xe, 21 - ye, ERASE_IMAGE);
					LINE(xs, 21 - ys, xe, 21 - ye, ERASE_IMAGE);
					LINE(xs, ys, xe, ye, ERASE_IMAGE);

					// 2nd set
					LINE(21 - xs - 1, 21 - ys - 1, 21 - xe - 1, 21 - ye - 1, ERASE_IMAGE);
					LINE(xs - 1, 21 - ys - 1, xe - 1, 21 - ye - 1, ERASE_IMAGE);
					LINE(xs - 1, ys - 1, xe - 1, ye - 1, ERASE_IMAGE);

					SPHERE(rad, 0, rad + 1, hues[MAX_HUES - (pos / 2)]);
					LINE(0, rad, rad, rad + 1, -1);  // white line though center of sphere
					LINE(0, rad, rad, rad, -1);  // white line though center of sphere


					SHOW_slow();

					//BT_DELAY(30);

				}
			}


			// get ready for TEXT
			LINE(0, 21, 0, 0, 171);  // vertical blue
			SHOW_slow();



			if (skip == 0)  // skip is set to 1 to skip TEXT display...for testing
			{
				if (repeat == 0)  // do first time only, TEXT display
				{

					// ****  SHOW TEXT   ****

					G_special_char_select = 1;
					byte previous_AUTO_DIM_LEVEL = G_AUTO_DIM_LEVEL;

					byte banner = 0;   // no banner

					G_AUTO_DIM_LEVEL = 250;  // center needs dimmer level, was 254

					strcpy(scroll_text_array, "***2024***");

					stringSize = strlen(scroll_text_array);

					byte speed = 1;

					SCROLL_TEXT(scroll_text_array, stringSize, 1, speed, -1, banner, 0, 2, 0);

					strcpy(scroll_text_array, "~~~HAPPY NEW YEAR~~~");


					stringSize = strlen(scroll_text_array);

					banner = 4;

					SCROLL_TEXT(scroll_text_array, stringSize, 1, speed, -1, banner, 0, 2, 0);

					//BT_DELAY(300);

					G_AUTO_DIM_LEVEL = previous_AUTO_DIM_LEVEL;  // restore default auto dim level

					CLEAR_ALL_LEDS();
				}
			}
		}





		//   ***  fire works ****
		for (int rep = 0; rep < 3; ++rep)
		{
			//if (rep > 0)  // no need for first 
			{
				for (int vert = rad + 1; vert < 21 - rad; ++vert)  // ball starts moving to top
				{
					LINE(0, 21, 0, 0, 0);

					if (vert < 20 - rad)
					{
						if (vert == 19 - rad)
						{
							SPHERE(rad + 1, 0, vert, hues[vert / 2]); // bigger radius
							LINE(0, vert, rad, vert, -1);  // white line though center of sphere
							LINE(0, vert - 1, rad, vert - 1, -1);  // white line though center of sphere
						}
						else
						{
							SPHERE(rad, 0, vert, hues[vert / 2]);  // normal radius
							LINE(0, vert, rad, vert, -1);  // white line though center of sphere
							LINE(0, vert - 1, rad, vert - 1, -1);  // white line though center of sphere
						}
					}
					else  // last sphere is white and bigger
					{
						SPHERE(rad + 2, 0, vert, -1); // white
						LINE(0, vert, rad, vert, -1);  // white line though center of sphere
						LINE(0, vert - 1, rad, vert - 1, -1);  // white line though center of sphere
					}

					SHOW_slow();

					BT_DELAY(50);

					SPHERE(rad, 0, vert, ERASE_IMAGE);
					LINE(0, vert, rad, vert, ERASE_IMAGE);  // white line though center of sphere
					LINE(0, vert - 1, rad, vert - 1, ERASE_IMAGE);  // white line though center of sphere


				}
			}





			//if (rep > 0)  // shoot rotket after ball explodes
			//{
			//	for (int f = 30; f < 35; ++f)   // fire works rocket
			//	{
			//		LOAD_BMP(f);
			//		LINE(0, 21, 0, 0, 42);  // vertical yellow line
			//		SHOW_slow();
			//		BT_DELAY(50);
			//	}
			//}


			//for (int rep = 0; rep < 3; ++rep)
			{
				for (int f = 35; f <= 39; ++f)   // fire work
				{
					for (int rep2 = 0; rep2 < 6; ++rep2)
					{
						LOAD_BMP(f);

						//ROTATE_COLORS(rep2 % 3 );

						LINE(0, 21, 0, 0, 0);  // vertical red line
						//G_bmp_num = f;
						//STAR_FLOAT(1, 2, 1, 4, NUM_LEDS);

						SHOW_slow();
						CLEAR_ALL_LEDS();
						LINE(0, 21, 0, 0, 42);  // vertical yellow line
						SHOW_slow();
					}


					//delay(100);
				}
			}

			BT_DELAY(500);
		}


		///////////////////////Additional footage taken fom P2S15  //////////////////////////////
		Serial.println(F("++++++PROD1: show 8 : additonal footage START"));

		FastLED.clear();

#define BOUNCES_PER_IMAGE 3  // number of time each image type will bounce between each image

		byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
		byte image_kind = 0;  //0=use stored image kind,  kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle, 7=ZG_ZAG
		byte total_increments = 3;  // number of images created between the two base sets, was 5
		int time_between_frames = 1000;
		byte bounce_cycles = 2;  // 2



		//////////////  FOR TEST ONLY  ///////////////////

		//		// 1st line : horizontal
		//XE[0] = 21;
		//XS[0] = 0;
		//YE[0] = 11;
		//YS[0] = 11;
		//HUE_IMAGE[0] = 0;

		//// 2nd line : verticle
		//XS1[0] = 11;  // starting X
		//XE1[0] = 11;  // ending x  , or radius if circle
		//YS1[0] = 0;  // starting y
		//YE1[0] = 21;  // ending y , or radius if circle
		//HUE_IMAGE1[0] = 171;  // blue


		///////////////////////// above for test only //////////////////




		/////////// BANK 0 ///////////////////
		///////// zig_zag bottom

		TWEEN_IMAGE_START[0].IMAGE_KIND = 7;
		TWEEN_IMAGE_START[0].XS = 0;
		TWEEN_IMAGE_START[0].YS = 0;
		TWEEN_IMAGE_START[0].XE = 21;
		TWEEN_IMAGE_START[0].YE = 0;
		TWEEN_IMAGE_START[0].HUE = 171;
		TWEEN_IMAGE_START[0].DATA1 = 4;   // peaks
		TWEEN_IMAGE_START[0].DATA2 = 4;  // amplitude

		TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
		TWEEN_IMAGE_START[1].XS = 0;
		TWEEN_IMAGE_START[1].YS = 0;
		TWEEN_IMAGE_START[1].XE = 0;
		TWEEN_IMAGE_START[1].YE = 21;
		TWEEN_IMAGE_START[1].HUE = 42;  // yellow
		TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
		TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
		TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



		/////////////////////////

		/////////// BANK 1 ///////////////////



		TWEEN_IMAGE_END[0].IMAGE_KIND = 7;  //zig_zag
		TWEEN_IMAGE_END[0].XS = 0;
		TWEEN_IMAGE_END[0].YS = 15;
		TWEEN_IMAGE_END[0].XE = 11;
		TWEEN_IMAGE_END[0].YE = 15;
		TWEEN_IMAGE_END[0].HUE = 0;
		TWEEN_IMAGE_END[0].DATA1 = 2;   // peaks
		TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude

		TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
		TWEEN_IMAGE_END[1].XS = 0;
		TWEEN_IMAGE_END[1].YS = 0;
		TWEEN_IMAGE_END[1].XE = 0;
		TWEEN_IMAGE_END[1].YE = 21;
		TWEEN_IMAGE_END[1].HUE = 42;
		TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
		TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
		TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow

		////////




		////////

		image_kind = 0;  // use stored image kind

		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 11 : just before bounce ....."));

		FastLED.clear();

		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)
		{
			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}


			//if ((bounce % BOUNCES_PER_IMAGE) == 0)  // only change image every 5'th bounce
			//{
			//	++image_kind;

			//	if (image_kind > NUMBER_OF_IMAGE_TYPES)  // currently only 1 to 4 is valid
			//	{
			//		image_kind = 1;  // reset
			//	}

			//}

			//Serial.print(F("---->PROD2: show 11 : image_kind="));
			//Serial.println(image_kind) ;

			Serial.println(F("++++++PROD1: show 8: direction = forward"));

			// now generate images that transition between these two images
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				//FastLED.clear();


				TWEEN(image_kind, number_of_images, total_increments, increment, STARTING_IMAGE_HUE, 1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}

			FastLED.clear();

			Serial.println(F("++++++PROD1: show 8: direction = *reverse*"));

			// reverse direction
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				//FastLED.clear();



				TWEEN(image_kind, number_of_images, total_increments, increment, ENDING_IMAGE_HUE, -1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}

		}

		//FastLED.clear();

		//Serial.println(F("++++++PROD1: show 8: at END bounce &&&&&&&&&&&&&&&"));



		/////////////////////////////////////////  additional footage taken from P2S17  ///////////////////////////////////


		Serial.println(F("++++++additional footage  :  PROD1: show 17 portion : start"));
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);

		FastLED.clear();
		SHOW_slow();

		double peaks = 5;
		double amplitude = 5;
		byte hue = 171;


		// horizontal
		int xs = 0;
		int ys = 0;
		int xe = 21;
		int ye;

		byte jump = 3;
		peaks = 7;


		peaks = 4;

		//tree structure
		for (byte ye = 0; ye < 22; ye = ye + jump)
		{
			hue = hues[ye + 1];

			//FastLED.clear();
			SPIKES(xs, ye, xe, ye, peaks, amplitude, 1, hue, hue); // generate a zig zag given the axis, amplitude and number of peaks
			SHOW_slow();
			BT_DELAY(100);

			xe = xe - jump;

			if (xe < 1) { xe = 1; }

		}




		///////////////////////////////////////////////////////////////


		BT_DELAY(4000);  // delay between shows to allow smooth film ending for a pretty display

	}


	//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	if (show_num == 9)   // FLOATING boxs 
	{

		CAL_SPIN2(NUM_LEDS);  // find the maximum number of blanks for STAR FLOAT ... prevents flashing
		for (int n = 0; n < 3; ++n)
		{

			G_bmp_num = 22;
			STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);

			G_bmp_num = 23;
			STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);

			DC_CHECK_AND_DO();

			G_bmp_num = 24;
			STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);

			G_bmp_num = 25;
			STAR_FLOAT(1, 5, 1, 5, NUM_LEDS);
		}
	}



	//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	if ((show_num == 10) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))   //proceedural lines 
	{

		//FastLED.clear();  // set to black all LEDs..
		HALL_SYNC2();

		byte xs = 0;
		byte ys = 11;
		byte BT_received = 0;

		byte hue = 0; // red
		unsigned long initial_hall_count = READ_HALL_COUNTS();

		byte xe = 0;

		for (byte ye = 0; ye <= 21; ++ye)
		{

			//if (G_BT_connected_flag != 1)  // allow for quick abort
			//{
			CLEAR_ALL_LEDS();
			initial_hall_count = G_Hall_counts;
			++xe;

			while (initial_hall_count == G_Hall_counts)
			{
				LINE(xs, 11, xe, ye, hue);
				LINE(xs, 11, xe, 21 - ye, hue);
				HUE_CYCLE_VERT(0, 3, 0);  // change the colors each time 
				BT_received = SHOW_slow();

				if (BT_received == 1) { break; }


				LINE(xs, 11, xe, ye, 999);  // erase previous line
				LINE(xs, 11, xe, 21 - ye, 999);  // erase previous line
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
			}
			//}
		}


	}

	//////////////////////////////////
	if ((show_num == 11) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))   //proceedural lines 
	{


		byte xs = 0;
		byte ys = 11;
		byte xe = 21;

		byte hue = 0; // red
		unsigned long initial_hall_count = READ_HALL_COUNTS();

		byte BT_received = 0;



		for (byte ye = 0; ye <= 21; ++ye)
		{

			CLEAR_ALL_LEDS();
			initial_hall_count = G_Hall_counts;

			while (initial_hall_count == G_Hall_counts)
			{
				LINE(xs, 11, xe, ye, hue);
				LINE(xs, 11, xe, 21 - ye, hue);
				HUE_CYCLE_VERT(0, 3, 0);  // change the colors each time 
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }


				LINE(xs, 11, xe, ye, 999);  // erase previous line
				LINE(xs, 11, xe, 21 - ye, 999);  // erase previous line
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
			}

		}

	}

	//SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
	if ((show_num == 12) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))   //  // expanding sphere with lines
	{

		//FastLED.clear();  // set to black all LEDs..
			//HALL_MEASURE2();  // find G_max_flashes
		unsigned long start_count = G_Hall_counts;
		byte BT_received = 0;

		//SHOW_slow();

		byte radius = 5;
		byte x_center = 0;
		byte y_center = 11;
		byte hue = 171;  // blue
		byte forever = 1;

		//HALL_SYNC2();
		//HUE_CYCLE_VERT(0, 2, 1);  // reset HUE

		for (radius = 1; radius < 11; ++radius)
		{
			//	if (G_BT_connected_flag != 1)  // allow for quick abort
			//	{
			while (start_count == G_Hall_counts)
			{
				CLEAR_ALL_LEDS();
				SPHERE(radius, x_center, y_center, hue);
				HUE_CYCLE_VERT(0, 2, 0);  // change the colors each time 
				if (radius == 10) { hue = 171; }  // blue
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
				SPHERE(radius, x_center, y_center, 999);  // erase sphere
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }

			}
			start_count = G_Hall_counts;
			//}
		}

	}

	///////////////////////

	//if ((show_num == 11) && (G_Hall_sync == 1))   //  // expanding sphere no line
	if (show_num == 13)    //  // expanding sphere no line
	{
		//unsigned long start_count = G_Hall_counts;

		Serial.println(F("------------>> prod 1: show 11"));
		Serial.println("");

		//SHOW_slow();

		byte radius = 5;
		byte x_center = 0;
		byte y_center = 11;
		byte hue = 171;  // blue
		byte forever = 1;
		byte BT_received = 0;
		byte repeats = 3;  // number of times to repeat this show

		for (byte loop = 0; loop < repeats; ++loop)
		{
			for (radius = 1; radius < 11; ++radius)
			{
				CLEAR_ALL_LEDS();
				SPHERE(radius, x_center, y_center, hue);
				HUE_CYCLE_VERT(0, 2, 0);  // change the colors each time 
				if (radius == 10) { hue = 171; }  // blue
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
				BT_DELAY(100);
			}
		}


		Serial.println(F("------------>> prod 1: show 11: -->END"));
		Serial.println("");
	}

	///////////////////////////////////////////////
	if ((show_num == 14) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))   //  // expanding sphere with lines
	{

		unsigned long start_count = G_Hall_counts;

		// ----------- create a SPIRAL --------------
		int delta_y = 5;  // controls how many arms to the spiral
		int prev_ye = 21; // keep track of previous value of ye
		int ye = 21;
		byte x_center = 0;
		byte y_center = 11;
		byte BT_received = 0;

		//if (delta_y < 1) { delta_y = 1; }

		HALL_SYNC2();

		for (int repeats = 0; repeats < 30; ++repeats)
		{
			start_count = G_Hall_counts;

			while (start_count == G_Hall_counts)
			{

				LINE(0, 11, 21, prev_ye, 999); // clear the previous line
				LINE(0, 11, 21, ye, 0);
				HUE_CYCLE_VERT(0, 2, 0);  // change the colors each time 
				prev_ye = ye;
				ye = ye - delta_y;
				if (ye < 0) { ye = 21; }
				SPHERE(10, x_center, y_center, 171);  // blue sphere in the center
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }

			}

		}


		CLEAR_ALL_LEDS();
		SHOW_slow();

	}

	///////////////////////////////////////
	if (show_num == 15)   // random STAR moded LEDs
	{

		int num_on = 0;
		int max_num_lights = 20;
		int dly = 0;
		int max_reps = 100;
		byte BT_received = 0;

		for (int reps = 0; reps < max_reps; ++reps)
		{
			FastLED.clear();
			num_on = 0;

			for (int y = 0; y < 22; ++y)  // scan Y direction
			{

				if (y == 11) { num_on = 0; }  // do this to insure top of panel also has lights

				for (int x = 0; x < 22; ++x) // scan x
				{
					int adr = XY_ADR(x, y);
					int adr2 = modify_adr(0, 0, adr);


					int rn = random(0, 10);
					if ((rn == 1) && (num_on < max_num_lights))  // turn on LED
					{
						G_hue_select = random(0, MAX_HUES);   //  panel will show a different color
						leds1[adr] = CHSV(hues[G_hue_select], 255, 255);

						G_hue_select = random(0, MAX_HUES);   //  panel will show a different color
						leds2[adr2] = CHSV(hues[G_hue_select], 255, 255);

						G_hue_select = random(0, MAX_HUES);   //  panel will show a different color
						leds3[adr] = CHSV(hues[G_hue_select], 255, 255);

						G_hue_select = random(0, MAX_HUES);   //  panel will show a different color
						leds4[adr2] = CHSV(hues[G_hue_select], 255, 255);

						++num_on;
					}

				}

			}
			BT_received = SHOW_slow();
			if (BT_received == 1) { break; }


			if (reps > max_reps - 20)  // add delays toward the end of the show
			{
				dly = dly + (reps / 30);
				BT_DELAY(dly);
			}



			//G_show_num = 6;

		}


	}

	//////////////////////////////////////////////////////////////////////////////////

	if (show_num == 16)   // Fireworks and Happy New Year
	{


		// ready for a show

	}

	//////////////////////////////////////////////////

	if (show_num == 17)   // moving rainbow
	{

		//G_bmp_num = 26;
		//STAR_FLOAT(4, 5, 4, 5);


		for (int reps = 0; reps < 4; ++reps)
		{
			for (int n = 26; n < 30; ++n)
			{
				LOAD_SHOW_BMP(n);
				BT_DELAY(200);
			}
			for (int n = 29; n > 25; --n)
			{
				LOAD_SHOW_BMP(n);
				BT_DELAY(200);
			}
		}
		//G_show_num = 8;
	}

	///////////////////////////////////////////////////////





	///////////////////////////////////////////////////////


	//if (show_num == 17)   // test interjected
	//{

	//	LOAD_SHOW_BMP(41);
	//	delay(1000);
	//}


	/////////////////////////////////////////////////
	if (show_num == 18)  // variable depth ringed images
	{
		int img = 54;
		int img2 = 58;
		int max_depth = 9;
		int increment = 3;
		int duration = 20;


		for (int n = 1; n < max_depth; n = n + increment)
		{
			BT_interrupt = RING_with_IMAGE(img, 0, duration, 2, n, 1);

			if (BT_interrupt > 0)
			{
				return 1;
			}
		}

		img = 56;
		for (int n = 1; n < max_depth; n = n + increment)
		{
			BT_interrupt = RING_with_IMAGE(img, 0, duration, 2, n, 1);

			if (BT_interrupt > 0)
			{
				return 1;
			}
		}

		img = 57;
		img2 = 58;
		for (int n = 1; n < max_depth; n = n + increment)
		{
			BT_interrupt = RING_with_IMAGE(img, img2, duration, 2, n, 1);

			if (BT_interrupt > 0)
			{
				return 1;
			}
		}


		/////////
		for (int n = 1; n < max_depth; n = n + 2 * increment)
		{
			BT_interrupt = RING_with_IMAGE(img, 0, duration, 2, n, 3);

			if (BT_interrupt > 0)
			{
				return 1;
			}
		}

		img = 56;
		for (int n = 1; n < max_depth; n = n + 2 * increment)
		{
			BT_interrupt = RING_with_IMAGE(img, 0, duration + 20, 2, n, 4);

			if (BT_interrupt > 0)
			{
				return 1;
			}
		}

		//img = 57;
		//img2 = 58;
		//for (int n = 1; n < max_depth; n = n + increment)
		//{
		//	RING_with_IMAGE(img, img2, duration, 2, n, 5);
		//}



	}

	////////////////////////////////////////////////////////////////////////////////
	if (show_num == 19)   // use saved images: enter PLAY SAVES MODE
		//if ((show_num == 17) && (digitalRead(HEAD_COM) == 0) && (G_Hall_sync == 1))   // use saved images: enter PLAY SAVES MODE
	{

		byte saved_images_flag = 0;
		byte number_of_random_images = 5;

		++G_TIMES_SAVED_IMAGES_SHOWN;



		// check that there are saved images
		//for (byte n = 0; n < maximum_number_of_SAVED_images; ++n)
		for (byte n = 1; n < maximum_number_of_SAVED_images + 1; ++n)  // 12/26/23
		{
			if (G_SAVED[n] == 1)
			{
				saved_images_flag = 1;
			}

		}

		// this prevents the same saved images to be shown no more than MAX_TIMES_CREATE_MODED_SAVED_IMAGES_SHOWN_IN_NORMAL_SHOW
		if (G_TIMES_SAVED_IMAGES_SHOWN > MAX_TIMES_CREATE_MODED_SAVED_IMAGES_SHOWN_IN_NORMAL_SHOW)
		{
			saved_images_flag = 0;
		}


		if (saved_images_flag == 0)  // create random images if none are saved or saved images have been shown maximum number of times
		{


			for (byte n = 1; n < number_of_random_images + 1; ++n)
			{
				switch (n) {
				case 1:
					CREATE_RANDOM_IMAGES(1, 6);  // random lines
					break;
				case 2:
					CREATE_RANDOM_IMAGES(4, 6);  // random triangles
					break;
				case 3:
					CREATE_RANDOM_IMAGES(2, 6);  // random circles
					break;
				case 4:
					CREATE_RANDOM_IMAGES(3, 6);  // random rectangle
					break;
				case 5:
					CREATE_RANDOM_IMAGES(4, 6);  // random triangles
					break;

				default:
					CREATE_RANDOM_IMAGES(3, 6);  // random rectangle
					break;
				}

				//if (n < 3)
				//{
				//	CREATE_RANDOM_IMAGE(1, 6);  // random lines
				//}
				//if (n == 3)
				//{
				//	CREATE_RANDOM_IMAGE(2, 6);  // random circles
				//}

				//if (n > 3)
				//{
				//	CREATE_RANDOM_IMAGE(3, 6);  // random rectangle
				//}


				G_SAVED[n] = 2;  // flag random generated image with the 2
				//G_SAVED[n] = 1;  

				for (int adr = 0; adr < NUM_LEDS; ++adr)  // save LEDs
				{
					//	leds_background[n] = leds1[n];
					leds_saved[n][adr] = leds1[adr];
				}
			}
		}


		//if (saved_images_flag == 1)  // only enter PLAY_SAVES_SHOW if there are saved images
		//{
		G_PLAY_SAVES_MODE_ON = 1;
		G_exit_PLAY_SAVES_MODE = 1; // flag PLAY SAVES MODE to exit after the show

		PLAY_SAVES_SHOW(0);

		G_exit_PLAY_SAVES_MODE = 0;

		MODIFY_GUI2(3);  // turn off play saves switch
		MODIFY_GUI3(3);  // turn off play saves switch

		if (saved_images_flag == 0)  // erase previous created random images
		{

			//for (byte n = 0; n < number_of_random_images; ++n)
			for (byte n = 1; n < number_of_random_images + 1; ++n)  // 12/26/23
			{
				G_SAVED[n] = 0;

			}
		}


		//}

		//LOAD_NEXT_SAVED_IMAGE(1);  // load first valid save image for next SHOW

		//int cycled_back = 0;

		//Serial.println(F("DO_SHOW: show=17"));
		//Serial.print(F("G_active_PSS_image="));
		//Serial.println(G_active_PSS_image);
		//Serial.println("");

		//
		//while ((cycled_back == 0) && (G_active_PSS_image>0))
		//{
		//	
		//		SHOW_slow();
		//		BT_DELAY(300);

		//		for (int n = 0; n < 22; ++n)
		//		{
		//			ROLL_VERT(1);
		//			SHOW_slow();
		//			BT_DELAY(50);
		//		}

		//		for (int n = 0; n < 44; ++n)
		//		{
		//			ROLL_HOZ(1);
		//			SHOW_slow();
		//			BT_DELAY(50);
		//		}

		//		cycled_back = LOAD_NEXT_SAVED_IMAGE(0);

		//		Serial.println(F("in show=17"));
		//		Serial.print(F("G_active_PSS_image="));
		//		Serial.println(G_active_PSS_image);
		//		Serial.print(F("cycled_back="));
		//		Serial.println(cycled_back);
		//		Serial.println("");

		//}
	}

	/////////////////////////////////////////////////
	if ((show_num == 20) && (digitalRead(HEAD_COM) == 0) && (G_Hall_sync == 1))  // move images up and down in SHOW_fast() using effect #7
	{


		int duration = 45;

		BT_interrupt = RING_with_IMAGE(1, 0, duration, 2, 9, 7);
		if (BT_interrupt > 0) { return 1; }

		CLEAR_ALL_LEDS();
		//CREATE_RANDOM_IMAGE(1, 6);  // random line

		BT_interrupt = RING_with_IMAGE(16, 0, duration, 2, 9, 7);
		if (BT_interrupt > 0) { return 1; }

		CLEAR_ALL_LEDS();
		CREATE_RANDOM_IMAGES(2, 6);  // random circle



		BT_interrupt = RING_with_IMAGE(55, 0, duration, 2, 9, 7);
		if (BT_interrupt > 0) { return 1; }

		CLEAR_ALL_LEDS();
		CREATE_RANDOM_IMAGES(1, 6);  // random line



		BT_interrupt = RING_with_IMAGE(59, 20, duration, 2, 9, 7);
		if (BT_interrupt > 0) { return 1; }

		CLEAR_ALL_LEDS();
		CREATE_RANDOM_IMAGES(1, 6);  // random line



		BT_interrupt = RING_with_IMAGE(19, 20, duration, 2, 9, 7);
		if (BT_interrupt > 0) { return 1; }


	}

	/////////////////////////////////////////////////////
	if (show_num == 21)  // proceedural V up and V down with sphere
	{
		int x_target = (NUM_COLUMNS - 1);
		int y_target = NUM_ROWS / 2;
		int hue = 0;
		int hue_increment = 15;

		byte BT_received = 0;


		CLEAR_ALL_LEDS();

		for (byte repeats = 0; repeats < 8; ++repeats)  // number of times show repeats
		{
			for (int y = 0; y < NUM_ROWS; ++y)
			{
				LINE(0, y, x_target, y_target, 1);  // red line
				LINE(0, NUM_ROWS - y - 1, x_target, y_target, 171);  // blue line


				hue = hue + hue_increment;

				if (hue > 255)
				{
					hue = 0;
				}

				if ((y > 0) && (y < NUM_ROWS / 2))
				{
					SPHERE(y, 0, y_target, hue);  // hue sphere
				}

				if (y > NUM_ROWS / 2)
				{
					SPHERE(NUM_ROWS - y, 0, y_target, hue);  // yellow sphere
				}

				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
				delay(50);

				LINE(0, y, x_target, y_target, 999);  // erase red line
				LINE(0, NUM_ROWS - y - 1, x_target, y_target, 999);  // erase blue line

				if ((y > 0) && (y < NUM_ROWS / 2))
				{
					SPHERE(y, 0, y_target, 999);  // erase hue sphere
				}
				if (y > NUM_ROWS / 2)
				{
					SPHERE(NUM_ROWS - y, 0, y_target, 999);  // erase yellow sphere
				}
			}
		}

	}


	/////////////////////////////////////////////////////
	if (show_num == 22)  // beach ball
	{
		// NOTE: Beach ball expands and contracts on HALL counts. Color stripes change during rotation.
		// The rotation of the ball is held static by keeping the maximum number of SHOW_slow() less than G_max_flashes.
		// The remaining time is used to sychronize to the HALL sensor (at end of the code).

		if ((G_Hall_sync != 0) && (digitalRead(HEAD_COM) == 0))
		{

			int x_target = (NUM_COLUMNS - 1);
			int y_target = 0;
			int previous_y_target = 0;
			int hue = 0;
			//int hue_increment = 15;
			int hue_index = -1;

			unsigned long sync = READ_HALL_COUNTS();  // 
			//int new_count = 0; 

			int HUES[4] = { 0, 83 , 171, 42 }; // red, green, blue, yellow
			int number_of_HUES = 4;
			byte bin = 0;

			byte BT_received = 0;



			HALL_MEASURE2(NUM_LEDS);  // find G_max_flashes
			if (G_max_flashes % 2 != 0) // make even
			{
				--G_max_flashes;

			}

			for (byte repeats = 0; repeats < 5; ++repeats)  // number of times show repeats
			{



				for (int y = 1; y < NUM_ROWS / 2; ++y)
				{

					//	int y = 5;  // for test only
					y_target = (2 * y);



					hue_index = -1;

					sync = READ_HALL_COUNTS();

					bin = 0;

					while (bin < G_max_flashes - 4)
					{



						++hue_index;

						if (hue_index >= number_of_HUES)
						{
							hue_index = 0;
						}

						hue = HUES[hue_index];

						SPHERE(y, 0, NUM_ROWS / 2, hue);  // hue sphere
						LINE(0, NUM_ROWS / 2, NUM_COLUMNS - 1, previous_y_target, 999);  // erase purple line
						++bin;  // 1st SHOW_slow
						BT_received = SHOW_slow();
						if (BT_received == 1) { break; }

						SPHERE(y, 0, NUM_ROWS / 2, 999);  // erase hue sphere
						LINE(0, NUM_ROWS / 2, NUM_COLUMNS - 1, y_target, 0);  // red line
						previous_y_target = y_target;
						++bin; // 2nd SHOW_slow
						BT_received = SHOW_slow();
						if (BT_received == 1) { break; }


					}

					while (sync == READ_HALL_COUNTS())  // sychronize:  this catches what spin time remains after the above
					{
					}
				}
			}
		}
	}





	/////////////////////////////////////////////////////
	if (show_num == 23)  // BOUNCE X
	{

		int tadr = GET_XY_ADR(11, 11);

		SET_SLOW();
		CLEAR_ALL_LEDS();
		SHOW_slow();

		//leds1[tadr].r = 255;  // 
		//leds1[tadr].g = 0;
		//leds1[tadr].b = 0;

		//leds3[tadr].r = 255;  // 
		//leds3[tadr].g = 0;
		//leds3[tadr].b = 0;

		//tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		//
		//leds2[tadr].r = 255;  // 
		//leds2[tadr].g = 0;  // 
		//leds2[tadr].b = 0;  // 

		//leds4[tadr].r = 255;  // 
		//leds4[tadr].g = 0;  // 
		//leds4[tadr].b = 0;  // 



		for (int repeats = 0; repeats < 2; ++repeats)
		{
			LOAD_BMP(62);
			SET_BOUNCE_ARRAY(1);


			for (int reps = 0; reps < 44; ++reps)
			{
				//BOUNCE(1, 18, 5);
				BOUNCE_X(1, 5, 17);
				SHOW_slow();
				BT_DELAY(40);
			}

			LOAD_BMP(61);
			SET_BOUNCE_ARRAY(1);

			for (int reps = 0; reps < 22; ++reps)
			{
				//BOUNCE(1, 18, 5);
				BOUNCE_X(1, 11, 0);
				SHOW_slow();
				BT_DELAY(40);
			}


			LOAD_BMP(59);
			SET_BOUNCE_ARRAY(1);

			for (int reps = 0; reps < 22; ++reps)
			{
				//BOUNCE(1, 18, 5);
				BOUNCE_X(1, 11, 0);
				SHOW_slow();
				BT_DELAY(40);
			}
		}

	}

	/////////////////////////////////////////////////////
	if (show_num == 24)  // BOUNCE Y
	{

		int tadr = GET_XY_ADR(11, 11);

		SET_SLOW();
		CLEAR_ALL_LEDS();
		SHOW_slow();

		byte BT_received = 0;


		//leds1[tadr].r = 255;  // 
		//leds1[tadr].g = 0;
		//leds1[tadr].b = 0;

		//leds3[tadr].r = 255;  // 
		//leds3[tadr].g = 0;
		//leds3[tadr].b = 0;

		//tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		//
		//leds2[tadr].r = 255;  // 
		//leds2[tadr].g = 0;  // 
		//leds2[tadr].b = 0;  // 

		//leds4[tadr].r = 255;  // 
		//leds4[tadr].g = 0;  // 
		//leds4[tadr].b = 0;  // 



		for (int repeats = 0; repeats < 2; ++repeats)
		{


			LOAD_BMP(60);
			SET_BOUNCE_ARRAY(1);
			//SET_BOUNCE_ARRAY(-1);

			for (int reps = 0; reps < 22; ++reps)
			{
				//BOUNCE(1, 18, 5);
				BOUNCE_Y(1, 11, 0);
				//BOUNCE(1, 0, 0);

				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
				BT_DELAY(40);
			}


			LOAD_BMP(61);
			SET_BOUNCE_ARRAY(1);
			//SET_BOUNCE_ARRAY(-1);

			for (int reps = 0; reps < 22; ++reps)
			{
				//BOUNCE(1, 18, 5);
				BOUNCE_Y(1, 11, 0);
				//BOUNCE(1, 0, 0);

				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
				BT_DELAY(40);
			}


			LOAD_BMP(59);
			SET_BOUNCE_ARRAY(1);
			//SET_BOUNCE_ARRAY(-1);

			for (int reps = 0; reps < 22; ++reps)
			{
				//BOUNCE(1, 18, 5);
				BOUNCE_Y(1, 11, 0);
				//BOUNCE(1, 0, 0);

				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
				BT_DELAY(40);
			}
		}

	}




	/////////////////////////////////////////////////////////////////////////////////////////
	if (show_num == 25)   // moving spheres and rings
	{

		int hue_increment = 25;
		int hue = 0;
		int hue2 = 50;
		//int repeats = 10;


		CLEAR_ALL_LEDS();
		//SPHERE(1, 0, 18, 0);  // red sphere
		//SPHERE(4, 0, 11, 171);  // blue sphere
		//SPHERE(1, 0, 4, 0);  // red sphere

		//SHOW_slow();
		//delay(100);

		for (int deltaY = 0; deltaY < 6; ++deltaY)
		{
			hue = hue + hue_increment;
			if (hue > 255) { hue = 0; }

			hue2 = hue2 + 2 * hue_increment;
			if (hue2 > 255) { hue2 = 0; }



			LINE(0, 16 - deltaY, 10, 16 - deltaY, hue);  // ring
			LINE(0, 5 + deltaY, 10, 5 + deltaY, hue2);  // ring

			SPHERE(1, 0, 18, 0);  // red sphere
			SPHERE(4, 0, 11, 171);  // blue sphere
			SPHERE(1, 0, 4, 0);  // red sphere

			byte BT_received = 0;
			BT_received = SHOW_slow();
			if (BT_received == 1) { break; }
			BT_DELAY(100);

			LINE(0, 16 - deltaY, 10, 16 - deltaY, 999);  //erase ring
			LINE(0, 5 + deltaY, 10, 5 + deltaY, 999);  // erase ring

		}


		for (int deltaY = 0; deltaY < 8; ++deltaY)  // mover red spheres
		{



			SPHERE(1, 0, 18 - deltaY, 0);  // red sphere
			SPHERE(4, 0, 11, 171);  // blue sphere
			SPHERE(1, 0, 4 + deltaY, 0);  // red sphere

			LINE(0, 16 - 5, 10, 16 - 5, hue);  // ring
			LINE(0, 5 + 5, 10, 5 + 5, hue);  // ring


			byte BT_received = 0;
			BT_received = SHOW_slow();
			if (BT_received == 1) { break; }
			BT_DELAY(100);

			SPHERE(1, 0, 18 - deltaY, 999);  // red sphere
			SPHERE(1, 0, 4 + deltaY, 999);  // red sphere
		}


		for (int deltaX = 0; deltaX < 16; ++deltaX)  // move ring
		{

			LINE(deltaX, 16 - 5, deltaX + 6, 16 - 5, 85);  //green ring
			LINE(deltaX, 5 + 5, deltaX + 6, 5 + 5, 85);  //green ring


			SPHERE(1, 0, 18 - 7, 0);  // red sphere
			SPHERE(4, 0, 11, 171);  // blue sphere

			byte BT_received = 0;
			BT_received = SHOW_slow();
			if (BT_received == 1) { break; }
			BT_DELAY(100);

			LINE(deltaX, 16 - 5, deltaX + 6, 16 - 5, 999);  // ring
			LINE(deltaX, 5 + 5, deltaX + 6, 5 + 5, 999);  // ring
		}

	}

	/////////////////////////////////////////////////////////////////////////////////////////
	if (show_num == 26)   // moving spheres and rings
	{
		int hue_increment = 25;
		int hue = 0;
		int hue2 = 50;

		///////////////
		SPHERE(5, 0, 11, 0);  // red sphere
		SPHERE(7, 0, 11, 171);  // blue sphere
		//SPHERE(9, 0, 11, 128);  // aqua sphere

		for (int reps = 0; reps < 7; ++reps)
		{
			for (int xe = 16; xe < NUM_COLUMNS; ++xe)
			{
				hue = hue + hue_increment;
				if (hue > 255) { hue = 0; }

				hue2 = hue2 + 2 * hue_increment;
				if (hue2 > 255) { hue2 = 0; }

				SPHERE(1, 0, 11, hue2);  // small center sphere

				LINE(xe - 4, 10, xe, 10, hue);  // ring

				//hue = hue + hue_increment;
				//if (hue > 255) { hue = 0; }

				LINE(xe - 4, 11, xe, 11, hue);  // ring

				//hue = hue + hue_increment;
				//if (hue > 255) { hue = 0; }

				LINE(xe - 4, 12, xe, 12, hue);  //  ring

				byte BT_received = 0;
				BT_received = SHOW_slow();
				if (BT_received == 1) { break; }
				BT_DELAY(100);

				LINE(xe - 4, 10, xe, 10, 999);  // erase blue ring
				LINE(xe - 4, 11, xe, 11, 999);  // erase blue ring
				LINE(xe - 4, 12, xe, 12, 999);  // erase blue ring
			}
		}

		SET_BOUNCE_ARRAY_X(0, NUM_COLUMNS - 1, 0);
		SET_BOUNCE_ARRAY_X(0, 8, -1);

		for (int reps = 0; reps < 40; ++reps)
		{
			LINE(16 - 4, 10, 16, 10, 85);  // green ring
			LINE(16 - 4, 11, 16, 11, 85);
			LINE(16 - 4, 12, 16, 12, 85);

			ROLL_X(1, 8, 0);
			byte BT_received = 0;
			BT_received = SHOW_slow();
			if (BT_received == 1) { break; }
			BT_DELAY(100);
		}

	}


	////////////////////////////////////////////////
	if (show_num == 27)   // open
	{


	}






	//////////////////////******* LAST SHOW******** ////////////////////////////////////////
	if (show_num == 28)   // ******* LAST SHOW********      different image on each panel
	{
		/// 4 panel each different
		FastLED.clear();
		LOAD_BMP_PANEL(44, 1);
		LOAD_BMP_PANEL(45, 2);
		LOAD_BMP_PANEL(46, 3);
		LOAD_BMP_PANEL(47, 4);
		SHOW_slow();
		BT_DELAY(2000);

		FastLED.clear();
		LOAD_BMP_PANEL(44, 4);
		LOAD_BMP_PANEL(45, 3);
		LOAD_BMP_PANEL(46, 2);
		LOAD_BMP_PANEL(47, 1);
		SHOW_slow();
		BT_DELAY(2000);

		CLEAR_ALL_LEDS();
		SHOW_slow();

		G_special_char_select = 1;
		strcpy(scroll_text_array, "~~~~THANKS FOR WATCHING~~~~");
		stringSize = strlen(scroll_text_array);
		SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, -1, 3, 0, 2, 0);


		CLEAR_ALL_LEDS();
		SHOW_slow();

		//G_show_num = 1;  // re-start the show
		//show_num= 1;
	}


	if ((show_num == NUMBER_OF_PRODUCTION1_SHOWS) || (G_force_production_end == 1))
	{
		G_force_production_end = 0;
		G_show_num = 1;
		return 1;  // flag that production is complete
	}
	else
	{
		return 0;
	}


	///////////////////////////////////////////////////////

//		Serial.println(F("****   DO_SHOW: END DUMP "));
//		DUMP_LED_ARRAY(leds1, NUM_LEDS);

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
byte PRODUCTION_2()  // return 1 if PRODUCTION is complete otherwise return 0
{
	//if (G_Hall_sync == 0) { return 1; }  // only execute if HALL syncy enabled

#define NUMBER_OF_PRODUCTION2_SHOWS 20 // note: starting with show 1, 0 doesn't count

	//int number_of_shows = 100;       // number of SHOWs
	int show_num = 0;

	int stringSize = 0;
	int hue = -1;  // white
	byte BT_interrupt = 0;



	//CLEAR_ALL_LEDS();
	//HALL_SYNC2();
	//SHOW_slow();



	//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	if ((G_continuous_SPECIAL_mode == 0) && (G_continuous_SPECIAL_mode_was_ON == 1))
	{
		G_continuous_SPECIAL_mode_was_ON = 0;

		CLEAR_FAST_LEDS();

		SHOW_fast(1, 0);
	}


	// ********* old SHOW handler  

	//++G_show_num;
	//int rv=DC_RECEIVE_ARRAY();
	//int rv = 0;

	//G_show_num = 1;
	//DC_COMMAND_HANDLER();



	if (G_BT_message_flag == 0)
	{
		G_BT_message_flag = CHECK_BLUE_TOOTH();

		/*Serial.println("In DO_SHOW2 after CHECK_BLUE_TOOTH");
		Serial.print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= ");
		Serial.println(G_BT_message_flag);
		Serial.println("");*/
	}

	if (G_BT_message_flag == 1)
	{



		//int stringSize = strlen(text_array);
		Serial.println(F("In PRODUCTION2 after CHECK_BLUE_TOOTH"));
		Serial.print(F("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= "));
		Serial.println(G_BT_message_flag);
		Serial.println("");
		Serial.print(F("G_message= "));
		Serial.println(G_message);
		//Serial.print("stringSize= ");
		//Serial.println(stringSize);
		Serial.print(F("G_BT_command= "));
		Serial.println(G_BT_command);
		Serial.println("");

		/*SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0, 0);
		G_BT_message_flag = 0;*/


		BLUE_TOOTH_COMMAND_HANDLER(1);  // execute the BT command  ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
		//DC_COMMAND_HANDLER();  // need this if the BT COMMAND HANDLER calls TRANSFER2_SLOW which will transfer back a DON_COM command
		delay(50);


	}

	if (G_continuous_SPECIAL_mode == 1)
	{
		G_show_num = 255;
	}

	//if ((G_show_num > number_of_shows) || (G_show_num == 1))
	//{
	//	if ((G_show_num != 255) && (G_show_num != 254))  // 255 is a flag to show BT text_array
	//	{
	//		G_show_num = 1;
	//		HALL_MEASURE3(22);  //find G_max_bins
	//	}

	//}



	/////////////////////////////  THE SHOW ///////////////////////////


	//	HALL_MEASURE3(22);  //find G_max_bins

		// -------------->    get next show number  <--------------------------


	show_num = SHOW_HANDLER(NUMBER_OF_PRODUCTION2_SHOWS);  ////// SHOW HANDLER  ///////////


	if (SERIAL_MON == 1)
	{
		Serial.println("");
		Serial.println(F("------> PRODUCTION2 <------ "));
		Serial.print(F("******************************************* G_show_num= "));
		Serial.println(G_show_num);
		Serial.print(F("show_num= "));
		Serial.println(show_num);
		//Serial.print(F("-------->G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);
		Serial.println("");
	}

	if (show_num == 0)   // CREATE mode
	{
		unsigned long present_system_time = millis();
		unsigned long delta_time = present_system_time - G_CREATE_MODE_start_time;

		//Serial.println("");
		//Serial.println(F("--------->  DO_SHOW:"));
		//Serial.print(F(" G_CREATE_MODE_start_time="));
		//Serial.println(G_CREATE_MODE_start_time);
		//Serial.print(F(" delta_time="));
		//Serial.println(delta_time);
		//Serial.print(F(" G_executing_CREATE_mode="));
		//Serial.println(G_executing_CREATE_mode);
		//Serial.print(F(" G_PLAY_SAVES_MODE_ON="));
		//Serial.println(G_PLAY_SAVES_MODE_ON);
		//Serial.println("");

		if (G_PLAY_SAVES_MODE_ON == 0) //  not PLAY SAVES
		{

			if (((delta_time) > MAXIMUM_IDLE_CREATE_MODE_TIME))  // EXIT CREATE MODE and execute SHOW
			{
				// NOTE: G_CREATE_MODE_start_time is set in the BT command handler every time a BT command is called
				G_BT_command = 'L'; // turn off CREATE MODE and turn on SHOW

				//Serial.println("");
				//Serial.println(F("--------->  before BT command to exit CREATE MODE:"));
				//Serial.println("");

				BLUE_TOOTH_COMMAND_HANDLER(1);
				return 1;
			}

		}

		CREATE_MODE();
		//Serial.println(F("DO_SHOW: before DUMP after CREATE_MODE(): show_num=0"));
		//DUMP_LED_ARRAY(leds1, NUM_LEDS);

	}

	//////  SHOW 255...show BT text
	if (G_show_num == 255)
	{
		SHOW_255();

		//HALL_MEASURE3(22);

		////stringSize = strlen(text_array);

		//stringSize=ADD_SPECIAL_TEXT();  // add special image Text characters to text_array

		////stringSize = strlen(text_array);  // new string size
		//
		//SCROLL_TEXT(text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0);
		//BT_and_DC_CHECKandDO();
	}

	if (G_show_num == 254)  // works in conjunction with DC command 11
		// display G_SAVED image 
	{
		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");

		int stringSize = strlen(scroll_text_array);

		//HALL_MEASURE3(22);  //find G_max_bins
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 2, 0);
		G_special_char_select = 1;
		BT_and_DC_CHECKandDO();

	}


	////// /////////////Production 2: /////////////////////////////////////////////////////////////////////////////////
	////// /////////////Production 2: /////////////////////////////////////////////////////////////////////////////////
	if ((show_num == 1) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))   // stars
	{

		int saved_G_dim = G_dim;

		//	strcpy(scroll_text_array, "PRODUCTION 2 SHOW 1");
		//	stringSize = strlen(scroll_text_array);
		//	SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, 0, 1, 1, 0);


		byte show_loops = 300;  // number of times this show loops
		byte active_columns = 3;  // number of active columns
		int num_leds = active_columns * 22; // number of active LEDs

#define num_bitmaps_2Load 10   // number of inner bit maps to load
		byte bit_maps[num_bitmaps_2Load] = { 66,67,68,69,70,71,70,69,68,67 };
		byte bit_map_index = 0;

		int start_angle = 90;
		int stop_angle = 90;   // was 100 with 3
		byte start_radius = 21;
		byte stop_radius = 21;
		byte start_z = 0;  // up and down
		byte stop_z = 21;  // up and down
		byte depth = 3;
		static byte do_once = 0;
		byte blanks = 16; // number of flashes to ignore at the end to prevent over wrap, was 10, was 4, was 14
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command
		byte number_of_stars = 4;  // number of stars created

		SET_VAR(num_leds);

#define number_of_hues 7
		byte HUES[number_of_hues] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color


		int star_center = 150;
		int star_size = 25;
		int line_start = star_center - star_size;
		int line_end = star_center + star_size;

		byte star_size_increment = 5;   // sets how much a star grows and shrinks
		byte max_star_size = 25;
		byte min_star_size = 10;
		int direction = 1;




		//	cylin[0] = { start_radius,start_angle,start_z };  // top right 
		//	cylin[1] = { stop_radius,stop_angle,stop_z }; // top left


			//// create a star:: {radius, angle, z}
			//cylin[2] = { 14 ,50, 10 };
			//cylin[3] = { 21 ,50,5 };       //*		
			//cylin[5] = { 21 ,150,5 }; //<--
			//cylin[6] = { 21 ,150,10 };
			//cylin[7] = { 21 ,150,16 };     //*		
			//cylin[9] = { 21 ,50,16 }; //<--

			//cylin[4] = { 14 ,100,0 };
			//cylin[8] = { 21 ,100,21 };

			//if (do_once == 0)
		{
			//HALL_MEASURE2(num_leds);
			blanks = HALL_MEASURE2(num_leds) + 11;  // find G_max_flashes and blanks......G_max = 72 *.15= 10.8  :  10 + 11=21 :  72-->  .292  ~ .3 change in HALL_MEASURE and test
			do_once = 1;
		}

		HALL_SYNC2();

		byte tilt = 0;
		//byte anit_tilt = active_columns - tilt;
		byte anit_tilt = 0;



		byte hue1 = 0;
		byte hue2 = 1;
		byte hue3 = 2;
		byte hue4 = 3;

		byte coordinate_offset;
		int line_vert_start = 0;
		int line_vert_end = 21;



		for (byte sl = 0; sl < show_loops; ++sl)
		{
			//for (int tilt = 0; tilt < active_columns; ++tilt)
			{

				//if (0 == sl % 5 )  // increment every 25 show_loops
				//{
				//	++hue1;
				//	++hue2;
				//	++hue3;
				//	++hue4;
				//}

				//if (hue1 > 3) { hue1 = 0; }
				//if (hue2 > 3) { hue2 = 0; }
				//if (hue3 > 3) { hue3 = 0; }
				//if (hue4 > 3) { hue4 = 0; }


				//anit_tilt = active_columns - tilt;

				if (0 == sl % 2)  // change the star size every 2 show loops
				{
					star_size = star_size + direction * star_size_increment;

					if (star_size > max_star_size)
					{
						star_size = max_star_size;
						direction = -1 * direction;
						line_vert_start = 0;
						line_vert_end = 21;
					}

					if (star_size < min_star_size)
					{
						star_size = min_star_size;
						direction = -1 * direction;
						line_vert_start = 8;
						line_vert_end = 13;
					}

					line_vert_start = line_vert_start - direction;
					line_vert_end = line_vert_end + direction;

					if (line_vert_start < 0) { line_vert_start = 0; }
					if (line_vert_end > 21) { line_vert_end = 21; }


				}

				for (byte star_number = 0; star_number < number_of_stars; ++star_number)
				{
					byte coordinate_offset = star_number * 8; // 8=number of coordinates to create a star

					star_center = 280 - star_number * (280 / number_of_stars);
					line_start = star_center - star_size;
					line_end = star_center + star_size;



					// create stars:: {radius, angle, z}
					cylin[2 + coordinate_offset] = { 21 - tilt ,line_start, 10 };
					cylin[3 + coordinate_offset] = { 21 - tilt ,line_start,5 };       //*
					//cylin[4 + coordinate_offset] = { 21 - tilt ,star_center,0 };
					cylin[4 + coordinate_offset] = { 21 - tilt ,star_center,line_vert_start };  // vert bottom
					cylin[5 + coordinate_offset] = { 21 - tilt ,line_end,5 }; //<--
					cylin[6 + coordinate_offset] = { 21 - anit_tilt ,line_end,10 };
					cylin[7 + coordinate_offset] = { 21 - anit_tilt ,line_end,16 };     //*
					//cylin[8 + coordinate_offset] = { 21 - anit_tilt ,star_center,21 };  // vert top
					cylin[8 + coordinate_offset] = { 21 - anit_tilt ,star_center,line_vert_end };  // vert top
					cylin[9 + coordinate_offset] = { 21 - anit_tilt ,line_start,16 }; //<--
				}


				//cylin[2] = { 21 - tilt ,line_start, 10 };
				//cylin[3] = { 21 - tilt ,line_start,5 };       //*
				//cylin[4] = { 21 - tilt ,star_center,0 };
				//cylin[5] = { 21 - tilt ,line_end,5 }; //<--
				//cylin[6] = { 21 - anit_tilt ,line_end,10 };
				//cylin[7] = { 21 - anit_tilt ,line_end,16 };     //*
				//cylin[8] = { 21 - anit_tilt ,star_center,21 };
				//cylin[9] = { 21 - anit_tilt ,line_start,16 }; //<--


				//cylin[2] = { 14 ,50, 10 };
				//cylin[3] = { 21 ,50,5 };       //*		
				//cylin[5] = { 21 ,150,5 }; //<--
				//cylin[6] = { 21 ,150,10 };
				//cylin[7] = { 21 ,150,16 };     //*		
				//cylin[9] = { 21 ,50,16 }; //<--

				//cylin[4] = { 14 ,100,0 };
				//cylin[8] = { 21 ,100,21 };



				for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
				{
					for (byte star_number = 0; star_number < number_of_stars; ++star_number)
					{

						coordinate_offset = star_number * 8; // 8=number of coordinates to create a star

						FLASH_DRAW_CYLIN_CORDINATES(4 + coordinate_offset, 8 + coordinate_offset, flash, HUES[star_number], depth);  // blue, verticle
						FLASH_DRAW_CYLIN_CORDINATES(5 + coordinate_offset, 9 + coordinate_offset, flash, HUES[star_number], depth);  // purple top right to bottom left
						FLASH_DRAW_CYLIN_CORDINATES(2 + coordinate_offset, 6 + coordinate_offset, flash, HUES[star_number], depth);  // red , horizontal
						FLASH_DRAW_CYLIN_CORDINATES(3 + coordinate_offset, 7 + coordinate_offset, flash, HUES[star_number], depth);  // yellow, bottom right to top left
					}



					if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
					{
						G_dim = DIMMING_MAX_BRIGHTNESS;
					}


					BT_interrupt = SHOW_var(num_leds);
					//BT_interrupt = SHOW_var_no_dimming(num_leds);
					CLEAR_VAR_LEDS(num_leds);  // only clear the outter LESs
					//FastLED.clear();



					if (BT_interrupt != 0) { break; }

				}

				if (BT_interrupt != 0) { break; }

				FastLED.clear();  // remove all streaking during blanking

				// load inner image
				SET_SLOW();
				LOAD_BMP(bit_maps[bit_map_index]);
				G_dim = DIMMING_INNER;
				//DIM_SLOW_LEDS(G_dim);
				SHOW_slow();
				delay(1);   // this delay is necessary to prevent false data to the panels

				G_dim = saved_G_dim; // restore previous value
				//delay(100);   /// for testing only

				++bit_map_index;
				if (bit_map_index >= num_bitmaps_2Load) { bit_map_index = 0; }

				blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1
			}

			if (BT_interrupt != 0) { break; }
		}

		G_dim = saved_G_dim;  // restore previous value

	}


	///////  SHOW 2  /////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((show_num == 2) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // proceedural for verticle line widget
	{
#define GROUPS 3     // shape specific: note book 12/15/22 back page
#define VERTICLE_LINES 6  // shape specific: note book 12/15/22 back page

		byte HUES[VERTICLE_LINES + 1] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

		//strcpy(scroll_text_array, "SHOW 2");
		///stringSize = strlen(scroll_text_array);
		//SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, 0, 1, 1, 0);


		byte active_columns = 8;  // number of active columns
		int num_leds = active_columns * 22; // number of active LEDs

		byte depth = 2;
		static byte do_once = 0;
		byte blanks; // number of flashes to ignore at the end to prevent over wrap, was 4
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command

		int saved_G_dim = G_dim;


		//SET_VAR(num_leds);

		//if (do_once == 0)
		//{
		//	HALL_MEASURE2(num_leds);  // find G_max_flashes
		//	do_once = 1;
		//}


		byte dr = 0;

		byte show_loops = 2;  // number of times this show loops

		//Serial.print(F("G_max_flashes "));
		//Serial.println(G_max_flashes);
		//Serial.println("");

		byte additional_columns = 7;


		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}




		//G_dim = 0;
		//DIM_SLOW_LEDS(0);  // no dimming


		for (active_columns = 7; active_columns < NUM_COLUMNS; active_columns = active_columns + additional_columns)
		{

			num_leds = active_columns * 22; // number of active LEDs
			SET_VAR(num_leds);
			blanks = HALL_MEASURE2(num_leds) + 1;  // find G_max_flashes

			////NOTE: try setting blanks to a low value to test automatic blanks feature
			//if (active_columns == 7) { blanks = 2; }   // for test only
			//if (active_columns == 14) { blanks = 0; }   // for test only
			//if (active_columns == 21) { blanks = 0; }   // for test only


		//Serial.print(F("active_columns= "));
		//Serial.println(active_columns);
		//Serial.print(F("G_max_flashes= "));
		//Serial.println(G_max_flashes);
		//Serial.print(F("blanks= "));
		//Serial.println(blanks);
		//Serial.println("");




			for (byte sl = 0; sl < show_loops; ++sl)
			{
				dr = 0;

				for (int tilt = 0; tilt < 2 * active_columns; ++tilt)
				{

					if (tilt >= active_columns)
					{
						--dr;
					}
					else
					{
						++dr;
					}

					//Serial.print(F("tilt= "));
					//Serial.println(tilt);
					//Serial.print(F("dr= "));
					//Serial.println(dr);
					//Serial.println("");

					// these must be integers otherwise I get blooming at extreems
					int rad0 = 21 - dr;  // top
					int rad1 = (22 - active_columns) + dr;  // middle
					int rad2 = rad0;   // bottom




					/////////////// guards  ////////////////////////
					//rad0 = GUARD(rad0, active_columns);  // insure radius is in range
					//rad1 = GUARD(rad1, active_columns);  // insure radius is in range
					//rad2 = GUARD(rad2, active_columns);  // insure radius is in range
					////////////////////////////////////////////////////////

					//Serial.print(F("rad0= "));
					//Serial.println(rad0);
					//Serial.print(F("rad1= "));
					//Serial.println(rad1);
					//Serial.print(F("dr= "));
					//Serial.println(dr);
					//Serial.println("");



					byte RADIUS[GROUPS] = { rad0, rad1, rad2 };  // radius for each group
					int ANGLE[GROUPS] = { 45,45,45 };  // starting angle for each group
					byte DA[GROUPS] = { 45,45,45 }; // delta angle for each group 
					byte Z[GROUPS] = { 21,10,0 };  // Z for each group


					// the below coordinates describe 10 verticle line segments: group 0=top, group 1=middle, group 2= bottom
					for (byte n = 0; n < VERTICLE_LINES; ++n)  // generate shape coordinates
					{
						for (byte group = 0; group < GROUPS; ++group)
						{
							cylin[group + 3 * n].radius = RADIUS[group];

							cylin[group + 3 * n].angle = ANGLE[group] + n * DA[group];

							cylin[group + 3 * n].z = Z[group];
						}
					}


					for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
					{

						FLASH_DRAW_CYLIN_CORDINATES(0, 1, flash, HUES[0], depth);  //red
						FLASH_DRAW_CYLIN_CORDINATES(1, 2, flash, HUES[0], depth);

						FLASH_DRAW_CYLIN_CORDINATES(3, 4, flash, HUES[1], depth);  // green
						FLASH_DRAW_CYLIN_CORDINATES(4, 5, flash, HUES[1], depth);

						FLASH_DRAW_CYLIN_CORDINATES(6, 7, flash, HUES[2], depth);  // blue
						FLASH_DRAW_CYLIN_CORDINATES(7, 8, flash, HUES[2], depth);

						FLASH_DRAW_CYLIN_CORDINATES(9, 10, flash, HUES[3], depth);   // yellow
						FLASH_DRAW_CYLIN_CORDINATES(10, 11, flash, HUES[3], depth);

						FLASH_DRAW_CYLIN_CORDINATES(12, 13, flash, HUES[4], depth);   // purple
						FLASH_DRAW_CYLIN_CORDINATES(13, 14, flash, HUES[4], depth);

						FLASH_DRAW_CYLIN_CORDINATES(15, 16, flash, HUES[5], depth);   // aqua
						FLASH_DRAW_CYLIN_CORDINATES(16, 17, flash, HUES[5], depth);


						FLASH_DRAW_CYLIN_CORDINATES(0, 15, flash, HUES[6], depth);    // top ring  , orangish
						FLASH_DRAW_CYLIN_CORDINATES(2, 17, flash, HUES[6], depth);    // bottom ring  , orangish

						BT_interrupt = SHOW_var(num_leds);
						//BT_interrupt = SHOW_var_no_dimming(num_leds);
						FastLED.clear();

						if (BT_interrupt != 0) { break; }

					}


					FastLED.clear();  // remove all streaking during blanking
					SHOW_var(num_leds);

					blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1

					if (BT_interrupt != 0) { break; }

				}
				if (BT_interrupt != 0) { break; }
			}
			if (BT_interrupt != 0) { break; }
		}

		G_dim = saved_G_dim;  // restore dimming
	}


	///////  SHOW 3  ////////////////////////////////////////////////////////

	if ((show_num == 3) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // proceedural for verticle line widget
	{
#define GROUPS 3     // shape specific: note book 12/15/22 back page
#define VERTICLE_LINES 6  // shape specific: note book 12/15/22 back page...was 6
		byte depth = 8;

		int angle_bound_max = 250; // the maximum allowed angle for angle_g#
		int angle_bound_min = 10;  // the minimum allowed angle for angle_g#

		byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

		//strcpy(scroll_text_array, "SHOW 2");
		///stringSize = strlen(scroll_text_array);
		//SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, 0, 1, 1, 0);


		byte active_columns = 8;  // number of active columns
		int num_leds = active_columns * NUM_ROWS; // number of active LEDs


		static byte do_once = 0;
		byte blanks = 10; // number of flashes to ignore at the end to prevent over wrap, was 5
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command

		int saved_G_dim = G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}

		//SET_VAR(num_leds);

		//if (do_once == 0)
		//{
		//	HALL_MEASURE2(num_leds);  // find G_max_flashes
		//	do_once = 1;
		//}


		byte dr = 0;

		byte show_loops = 3;  // number of times this show loops

		//Serial.print(F("G_max_flashes "));
		//Serial.println(G_max_flashes);
		//Serial.println("");

		//byte additional_columns = 7;  // sets the number of additional columns to make active each loop


		//for (active_columns = 8; active_columns <= NUM_COLUMNS; active_columns = active_columns + additional_columns)
		{

			//	num_leds = active_columns * 22; // number of active LEDs

			SET_VAR(num_leds);
			HALL_MEASURE2(num_leds);  // find G_max_flashes

			//Serial.print(F("G_max_flashes= "));
			//Serial.println(G_max_flashes);
			//Serial.println("");


			HALL_SYNC2();


			for (byte sl = 0; sl < show_loops; ++sl)
			{

				int angle_direction = -1;
				int angle_g2 = 0;  // group 2 angle
				int angle_deflection = 45;   // + and - around starting angle
				byte angle_increment = 10;
				int angle_start = 45;


				for (int angle = 5; angle < 4 * angle_deflection; angle = angle + angle_increment)
				{
					if (angle <= 2 * angle_deflection)
					{
						angle_direction = 1;
						angle_g2 = angle;
					}
					else
					{
						angle_direction = -1;
						angle_g2 = angle_g2 - angle_increment;
					}

					if (angle_g2 > angle_bound_max)
					{
						angle_g2 = angle_bound_max;

					}

					if (angle_g2 < angle_bound_min)
					{
						angle_g2 = angle_bound_min;

					}



					// these must be integers otherwise I get blooming at extreems
					int rad0 = 21;  // top
					int rad1 = (22 - active_columns);  // middle
					int rad2 = rad0;   // bottom


					/////////////// guards  ////////////////////////
					//rad0 = GUARD(rad0, active_columns);  // insure radius is in range
					//rad1 = GUARD(rad1, active_columns);  // insure radius is in range
					//rad2 = GUARD(rad2, active_columns);  // insure radius is in range
					////////////////////////////////////////////////////////

					//Serial.print(F("rad0= "));
					//Serial.println(rad0);
					//Serial.print(F("rad1= "));
					//Serial.println(rad1);
					//Serial.print(F("dr= "));
					//Serial.println(dr);
					//Serial.println("");



					byte RADIUS[GROUPS] = { rad0, rad1, rad2 };  // radius for each group
					int ANGLE[GROUPS] = { 45,angle_g2,45 };  // starting angle for each group
					byte DA[GROUPS] = { 45,45,45 }; // delta angle for each group 
					byte Z[GROUPS] = { 21,10,0 };  // Z for each group


					// the below coordinates describe 10 verticle line segments: group 0=top, group 1=middle, group 2= bottom
					for (byte n = 0; n < VERTICLE_LINES; ++n)  // generate shape coordinates
					{
						for (byte group = 0; group < GROUPS; ++group)
						{
							cylin[group + 3 * n].radius = RADIUS[group];

							cylin[group + 3 * n].angle = ANGLE[group] + n * DA[group];

							cylin[group + 3 * n].z = Z[group];
						}
					}


					//HALL_SYNC2();

					for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
					{

						FLASH_DRAW_CYLIN_CORDINATES(0, 1, flash, HUES[0], depth);  //red
						FLASH_DRAW_CYLIN_CORDINATES(1, 2, flash, HUES[0], depth);

						FLASH_DRAW_CYLIN_CORDINATES(3, 4, flash, HUES[1], depth);  // green
						FLASH_DRAW_CYLIN_CORDINATES(4, 5, flash, HUES[1], depth);

						FLASH_DRAW_CYLIN_CORDINATES(6, 7, flash, HUES[2], depth);  // blue
						FLASH_DRAW_CYLIN_CORDINATES(7, 8, flash, HUES[2], depth);

						FLASH_DRAW_CYLIN_CORDINATES(9, 10, flash, HUES[3], depth);   // yellow
						FLASH_DRAW_CYLIN_CORDINATES(10, 11, flash, HUES[3], depth);

						FLASH_DRAW_CYLIN_CORDINATES(12, 13, flash, HUES[4], depth);   // purple
						FLASH_DRAW_CYLIN_CORDINATES(13, 14, flash, HUES[4], depth);

						FLASH_DRAW_CYLIN_CORDINATES(15, 16, flash, HUES[5], depth);   // aqua
						FLASH_DRAW_CYLIN_CORDINATES(16, 17, flash, HUES[5], depth);


						FLASH_DRAW_CYLIN_CORDINATES(0, 15, flash, HUES[6], depth);    // top ring  , orangish
						FLASH_DRAW_CYLIN_CORDINATES(2, 17, flash, HUES[6], depth);    // bottom ring  , orangish
						FLASH_DRAW_CYLIN_CORDINATES(1, 16, flash, 171, depth);    // middle ring  , blue

						BT_interrupt = SHOW_var(num_leds);
						//delayMicroseconds(500);  
						FastLED.clear();

						if (BT_interrupt != 0) { break; }

					}
					FastLED.clear();  // remove all streaking during blanking
					SHOW_var(num_leds);
					blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1

					if (BT_interrupt != 0) { break; }
				}
				if (BT_interrupt != 0) { break; }
			}

		}


		G_dim = saved_G_dim;  // restore dimming


	}

	//////////////////////////////////////////  SHOW 4
	if ((show_num == 4) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // proceedural for two objects rotating in different directions. 
	{
#define GROUPS 3     // shape specific: note book 12/15/22 back page
#define VERTICLE_LINES 7  // shape specific: note book 12/15/22 back page

		byte show_loops = 2;  // number of times this show loops

		byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

		//strcpy(scroll_text_array, "SHOW 2");
		///stringSize = strlen(scroll_text_array);
		//SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, 0, 1, 1, 0);


		byte active_columns = 16;  // number of active columns
		int num_leds = active_columns * 22; // number of active LEDs
		int rotation_increment = 10; // number of degrees rotation to do each time
		int rotation_ccw = 0; // amount of counter clockwise rotation

		byte depth = 3;
		static byte do_once = 0;
		byte blanks = 3; // number of flashes to ignore at the end to prevent over wrap, was 4
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command


		int saved_G_dim = G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}

		//SET_VAR(num_leds);

		//if (do_once == 0)
		//{
		//	HALL_MEASURE2(num_leds);  // find G_max_flashes
		//	do_once = 1;
		//}





		//Serial.print(F("G_max_flashes "));
		//Serial.println(G_max_flashes);
		//Serial.println("");

		byte additional_columns = 7;


		//for (active_columns = 7; active_columns < NUM_COLUMNS; active_columns = active_columns + additional_columns)
		{

			num_leds = active_columns * 22; // number of active LEDs
			SET_VAR(num_leds);
			blanks = HALL_MEASURE2(num_leds) + 2;  // find G_max_flashes , 2 extra because of extra computational delay



			//Serial.print(F("G_max_flashes= "));
			//Serial.println(G_max_flashes);
			//Serial.println("");




			for (byte sl = 0; sl < show_loops; ++sl)
			{



				for (int rotation = 0; rotation < 360; rotation = rotation + rotation_increment)
				{

					rotation_ccw = 360 - rotation;

					//Serial.print(F("tilt= "));
					//Serial.println(tilt);
					//Serial.print(F("dr= "));
					//Serial.println(dr);
					//Serial.println("");

					// these must be integers otherwise I get blooming at extreems
					int rad0 = 21 - additional_columns;  // top
					int rad1 = 21;  // middle
					int rad2 = 21 - additional_columns;   // bottom

					int rad3 = 21 - active_columns;  // top
					int rad4 = 21 - additional_columns;  // middle
					int rad5 = 21 - active_columns;   // bottom




					/////////////// guards  ////////////////////////
					//rad0 = GUARD(rad0, active_columns);  // insure radius is in range
					//rad1 = GUARD(rad1, active_columns);  // insure radius is in range
					//rad2 = GUARD(rad2, active_columns);  // insure radius is in range
					////////////////////////////////////////////////////////

					//Serial.print(F("rad0= "));
					//Serial.println(rad0);
					//Serial.print(F("rad1= "));
					//Serial.println(rad1);
					//Serial.print(F("dr= "));
					//Serial.println(dr);
					//Serial.println("");


					// define outter structure
					byte RADIUS[GROUPS] = { rad0, rad1, rad2 };  // radius for each group
					int ANGLE[GROUPS] = { rotation,rotation,rotation };  // starting angle for each group
					byte DA[GROUPS] = { 50,50,50 }; // delta angle for each group 
					byte Z[GROUPS] = { 21,10,0 };  // Z for each group


					// now define inner structure
					byte RADIUS2[GROUPS] = { rad3, rad4, rad5 };  // radius for each group
					int ANGLE2[GROUPS] = { rotation_ccw,rotation_ccw,rotation_ccw };  // starting angle for each group
					byte DA2[GROUPS] = { 50,50,50 }; // delta angle for each group 
					byte Z2[GROUPS] = { 15,10,6 };  // Z for each group


					// the below coordinates describe 10 verticle line segments: group 0=top, group 1=middle, group 2= bottom
					for (byte n = 0; n < VERTICLE_LINES; ++n)  // generate shape coordinates
					{
						// outter structure
						for (byte group = 0; group < GROUPS; ++group)
						{
							cylin[group + 3 * n].radius = RADIUS[group];

							cylin[group + 3 * n].angle = ANGLE[group] + n * DA[group];

							cylin[group + 3 * n].z = Z[group];
						}

						byte offset = 21;

						// inner structure
						for (byte group = 0; group < GROUPS; ++group)  // new structure coordinates start at cylin[21] and end at cylin(41)
						{
							cylin[offset + group + 3 * n].radius = RADIUS2[group];

							cylin[offset + group + 3 * n].angle = ANGLE2[group] + n * DA2[group];

							cylin[offset + group + 3 * n].z = Z2[group];
						}
					}


					// {radius, angle, z} 
					// define coordinates for full top and bottom circles for outter structure
					cylin[42] = { 21 - additional_columns,0,21 };  // top circle start...was 36
					cylin[43] = { 21 - additional_columns,359,21 };  // top circle end
					cylin[44] = { 21 - additional_columns,0,0 };  // bottom circle start
					cylin[45] = { 21 - additional_columns,359,0 };  // bottom circle end 

					// define coordinates for full top and bottom circles for inner structure
					cylin[46] = { 22 - active_columns,0,15 };  // top circle start...was 36
					cylin[47] = { 22 - active_columns,359,15 };  // top circle end
					cylin[48] = { 22 - active_columns,0,6 };  // bottom circle start
					cylin[49] = { 22 - active_columns,359,6 };  // bottom circle end 

					//HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

					for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
					{
						// outter structure
						FLASH_DRAW_CYLIN_CORDINATES(0, 1, flash, HUES[2], 1);  //red
						FLASH_DRAW_CYLIN_CORDINATES(1, 2, flash, HUES[2], 1);

						FLASH_DRAW_CYLIN_CORDINATES(3, 4, flash, HUES[0], 1);  // green
						FLASH_DRAW_CYLIN_CORDINATES(4, 5, flash, HUES[0], 1);

						FLASH_DRAW_CYLIN_CORDINATES(6, 7, flash, HUES[0], 1);  // blue
						FLASH_DRAW_CYLIN_CORDINATES(7, 8, flash, HUES[0], 1);

						FLASH_DRAW_CYLIN_CORDINATES(9, 10, flash, HUES[0], 1);   // yellow
						FLASH_DRAW_CYLIN_CORDINATES(10, 11, flash, HUES[0], 1);

						FLASH_DRAW_CYLIN_CORDINATES(12, 13, flash, HUES[2], 1);   // purple
						FLASH_DRAW_CYLIN_CORDINATES(13, 14, flash, HUES[2], 1);

						FLASH_DRAW_CYLIN_CORDINATES(15, 16, flash, HUES[0], 1);   // aqua
						FLASH_DRAW_CYLIN_CORDINATES(16, 17, flash, HUES[0], 1);

						FLASH_DRAW_CYLIN_CORDINATES(18, 19, flash, HUES[0], 1);  // blue
						FLASH_DRAW_CYLIN_CORDINATES(19, 20, flash, HUES[0], 1);

						FLASH_DRAW_CYLIN_CORDINATES(42, 43, flash, 0, 2);    // top ring  , red
						FLASH_DRAW_CYLIN_CORDINATES(44, 45, flash, 0, 2);    // bottom ring  , red

						// inner structure
						FLASH_DRAW_CYLIN_CORDINATES(21, 22, flash, HUES[4], depth);  //red
						FLASH_DRAW_CYLIN_CORDINATES(22, 23, flash, HUES[4], depth);

						FLASH_DRAW_CYLIN_CORDINATES(24, 25, flash, HUES[3], depth);  // green
						FLASH_DRAW_CYLIN_CORDINATES(25, 26, flash, HUES[3], depth);

						FLASH_DRAW_CYLIN_CORDINATES(27, 28, flash, HUES[3], depth);  // blue
						FLASH_DRAW_CYLIN_CORDINATES(28, 29, flash, HUES[3], depth);

						FLASH_DRAW_CYLIN_CORDINATES(30, 31, flash, HUES[3], depth);   // yellow
						FLASH_DRAW_CYLIN_CORDINATES(31, 32, flash, HUES[3], depth);

						FLASH_DRAW_CYLIN_CORDINATES(33, 34, flash, HUES[4], depth);   // purple
						FLASH_DRAW_CYLIN_CORDINATES(34, 35, flash, HUES[4], depth);

						FLASH_DRAW_CYLIN_CORDINATES(36, 37, flash, HUES[3], depth);   // aqua
						FLASH_DRAW_CYLIN_CORDINATES(37, 38, flash, HUES[3], depth);

						FLASH_DRAW_CYLIN_CORDINATES(39, 40, flash, HUES[3], depth);  // blue
						FLASH_DRAW_CYLIN_CORDINATES(40, 41, flash, HUES[3], depth);

						FLASH_DRAW_CYLIN_CORDINATES(46, 47, flash, 171, depth);    // top ring  , blue
						FLASH_DRAW_CYLIN_CORDINATES(48, 49, flash, 171, depth);    // bottom ring  , blue



						BT_interrupt = SHOW_var(num_leds);
						FastLED.clear();

						if (BT_interrupt != 0) { break; }

					}
					FastLED.clear();  // remove all streaking during blanking
					SHOW_var(num_leds);
					blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1

					if (BT_interrupt != 0) { break; }
				}
				if (BT_interrupt != 0) { break; }
			}

		}

		G_dim = saved_G_dim;  // restore dimming
	}

	//////////////////////////////////////////  SHOW 5 
	if ((show_num == 5) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // proceedural for two radial lines rotating in different directions. 
	{

		byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

		//strcpy(scroll_text_array, "SHOW 2");
		///stringSize = strlen(scroll_text_array);
		//SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, 0, 1, 1, 0);


		byte active_columns = 22;  // number of active columns
		int num_leds = active_columns * 22; // number of active LEDs
		int rotation_increment = 10; // number of degrees rotation to do each time
		int rotation_ccw = 0; // amount of counter clockwise rotation

		byte depth = 3;
		static byte do_once = 0;
		int blanks; // number of flashes to ignore at the end to prevent over wrap, was 5
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command

		//float time_per_flash;  
		//float time_per_show_flash;
		//byte flash_count = 0;
		//byte do_one_time = 0;

		byte show_loops = 3;  // number of times this show loops

		int saved_G_dim = G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}


		///////////////////////////////////

		num_leds = active_columns * 22; // number of active LEDs
		SET_VAR(num_leds);
		//time_per_flash = HALL_MEASURE4(num_leds)  ;  // find G_max_flashes and time interval
		HALL_MEASURE2(num_leds);  // find G_max_flashes

		blanks = 2;  // this is fine tuned and needed to be increased because of inner structure, don't use the return from HALL_MEASURE2

		//G_max_flashes = G_max_flashes - blanks; 

	//Serial.print(F("G_max_flashes= "));
	//Serial.println(G_max_flashes);
	//Serial.println("");

		for (byte sl = 0; sl < show_loops; ++sl)
		{

			for (int rotation = 0; rotation < 360; rotation = rotation + rotation_increment)
			{

				//rotation = 90;   /// test only************

				rotation_ccw = 360 - rotation;

				// {radius, angle, Z}

				// these are the outter structure
				cylin[0] = { 0,45 + rotation,0 };  //inner bottom 1
				cylin[1] = { 21,45 + rotation,21 }; // outter top 1
				cylin[2] = { 0,225 + rotation,0 };  // inner bottom 2
				cylin[3] = { 21,225 + rotation,21 }; // inner top 2

				cylin[4] = { 0,90 + rotation_ccw,21 };  //inner top 3
				cylin[5] = { 21,90 + rotation_ccw,0 }; // outter bottom 3
				cylin[6] = { 0,270 + rotation_ccw,21 };  // inner bottom 4
				cylin[7] = { 21,270 + rotation_ccw,0 }; // inner top 4

				// inner structure
				byte delta_height = 3;
				byte center = 11;
				byte radius_inner = 5;


				// these are for the inner structure
				cylin[8] = { 0,0 + rotation,center - delta_height };  //inner bottom 1
				cylin[9] = { radius_inner,0 + rotation,center + delta_height }; // outter top 1
				cylin[10] = { 0,180 + rotation,center - delta_height };  // inner bottom 2
				cylin[11] = { radius_inner,180 + rotation,center + delta_height }; // inner top 2

				cylin[12] = { 0,45 + rotation_ccw,center + delta_height };  //inner top 3
				cylin[13] = { radius_inner,45 + rotation_ccw,center - delta_height }; // outter bottom 3
				cylin[14] = { 0,225 + rotation_ccw,center + delta_height };  // inner bottom 4
				cylin[15] = { radius_inner,225 + rotation_ccw,center - delta_height }; // inner top 4

				//time_per_show_flash = float(millis()); 

				for (byte flash = 0; flash <= G_max_flashes - blanks; ++flash)
					//for (byte flash = 0; flash <= G_max_flashes; ++flash)
				{
					//	++flash_count;

						// bottom to top
					FLASH_DRAW_CYLIN_CORDINATES(0, 1, flash, HUES[0], 1);  //0
					FLASH_DRAW_CYLIN_CORDINATES(2, 3, flash, HUES[0], 1);  //1

					// top to bottom
					FLASH_DRAW_CYLIN_CORDINATES(4, 5, flash, HUES[2], 1);   //2
					FLASH_DRAW_CYLIN_CORDINATES(6, 7, flash, HUES[2], 1);  //3 was HUES[2]

					// inner structure : bottom to top
					FLASH_DRAW_CYLIN_CORDINATES(8, 9, flash, HUES[5], 1);  //0
					FLASH_DRAW_CYLIN_CORDINATES(10, 11, flash, HUES[5], 1);  //1

					//  inner structure : top to bottom
					FLASH_DRAW_CYLIN_CORDINATES(12, 13, flash, HUES[3], 1);   //2
					FLASH_DRAW_CYLIN_CORDINATES(14, 15, flash, HUES[3], 1);  //3 was HUES[2]


					//BT_interrupt = SHOW_var_no_dimming(num_leds); // display a variable number of LEDs with no dimming from G_dim
					BT_interrupt = SHOW_var(num_leds);
					FastLED.clear();

					if (BT_interrupt != 0) { break; }

				}

				FastLED.clear();  // remove all streaking during blanking
				SHOW_var(num_leds);

				blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1, locate at end to finish , needed here to insure CCW is consistent
				if (BT_interrupt != 0) { break; }
			}
			if (BT_interrupt != 0) { break; }
		}

		G_dim = saved_G_dim;  // restore dimming

	}



	////////////////////////////////////////
	if ((show_num == 6) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // oddly moving outter radial lines
	{

#define NUMBER_OF_BOTTOM_VERTICIES 6

		byte show_loops = 100;  // number of times this show loops

		byte active_columns = 2;  // number of active columns
		int num_leds = active_columns * 22; // number of active LEDs

		byte depth = 2;

		byte blanks = 5; // number of flashes to ignore at the end to prevent over wrap, was 4
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command

		byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

		int angle_increment = 350 / NUMBER_OF_BOTTOM_VERTICIES;

		int saved_G_dim = G_dim;



		// create inner image
		SET_SLOW();
		FastLED.clear();
		LINE(0, 0, 10, 10, 171);  // bottom blue...outter
		LINE(0, 21, 11, 11, 171); // top magenta...outter
		LINE(0, 5, 5, 10, 0);  // bottom blue  .. inner
		LINE(0, 16, 5, 11, 0); // top magenta  .. inner
		CIRCLE(3, 0, 11, 42);  // yellow center
		G_dim = DIMMING_INNER;

		SHOW_slow();
		SAVE_BACKGROUND();

		G_dim = saved_G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}

		num_leds = active_columns * 22; // number of active LEDs
		SET_VAR(num_leds);
		blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes


		// {radius, angle, Z}  // 80 verticies total
		cylin[0] = { NUM_COLUMNS, 180,21 };  //target top  ********
		//cylin[0] = { NUM_COLUMNS - active_columns, 180,21 };  //target top  ********

		for (int n = 1; n < NUMBER_OF_BOTTOM_VERTICIES + 1; ++n)  // generate bottom verticies
		{

			cylin[n] = { 21, n * angle_increment, 0 }; // {radius, angle, Z}  
		}


		int rotation_top_increment = 20; // how many degrees to move the top vertix
		int angle_top_start = 180; // starting angle for top point
		int angle_top = angle_top_start; // how much to move the top vertix
		int direction = 1;

		for (byte sl = 0; sl < show_loops; ++sl)
		{
			//angle_top = angle_top_start + (direction * sl * rotation_top_increment); 
			angle_top = angle_top + (direction * rotation_top_increment);

			if (angle_top > 350)
			{
				angle_top = 350;
				direction = -1 * direction;   // reverse direction
			}

			if (angle_top < 0)
			{
				angle_top = 0;
				direction = -1 * direction;   // reverse direction
			}

			//Serial.print(F("angle_top= "));
			//Serial.println(angle_top);
			//Serial.print(F("direction= "));
			//Serial.println(direction);
			//Serial.print(F("sl= "));
			//Serial.println(sl);
			//Serial.println("");


				// {radius, angle, Z}  // 80 verticies total
				//cylin[0] = { NUM_COLUMNS - active_columns, angle_top,21 };  //target top  ********
			cylin[0] = { NUM_COLUMNS, angle_top,21 };  //target top  ********


			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{

				LOAD_BACKGROUND();
				for (int n = 0; n < NUMBER_OF_BOTTOM_VERTICIES; ++n)
				{
					FLASH_DRAW_CYLIN_CORDINATES(0, n + 1, flash, HUES[n], depth);
				}


				//BT_interrupt = SHOW_var_no_dimming(num_leds); // display a variable number of LEDs with no dimming from G_dim
				BT_interrupt = SHOW_var(num_leds);
				FastLED.clear();

				if (BT_interrupt != 0) { break; }

			}
			FastLED.clear();  // remove all streaking during blanking
			SHOW_var(num_leds);

			blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1
			if (BT_interrupt != 0) { break; }
		}

		G_dim = saved_G_dim;  // restore dimming
	}




	///////////////////////////////////////////////////////////////////////////////////////
	if ((show_num == 7) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // floating cube
	{
		byte show_loops = 100;  // number of times this show loops


		byte depth = 1;
		byte blanks = 10; // number of flashes to ignore at the end to prevent over wrap, was 4
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command
		byte HUES[10] = { 0,85, 171, 42, 213, 128, 35, 66, 88, 33 };   // red, green, blue, yellow, purple, aqua,  orangish 

		byte L = 20; // half the length of the square expressed as a delta angle 
		byte LB = 20; // half the length of the square expressed as a delta angle, was 30
		byte W = 5;  // half the width of the square 
		byte dR = 8; // delta radius, was 10
		int CENTER = 70; //angle for center of square, was 90

		byte L2 = 20; // half the length of the square expressed as a delta angle 
		byte LB2 = 20; // half the length of the square expressed as a delta angle 
		byte W2 = 5;  // half the width of the square 
		byte dR2 = 8; // delta radius, was 10
		int CENTER2 = 170; //angle for center of square, was 170

		byte L3 = 20; // half the length of the square expressed as a delta angle 
		byte LB3 = 20; // half the length of the square expressed as a delta angle 
		byte W3 = 5;  // half the width of the square 
		byte dR3 = 8; // delta radius, was 10
		int CENTER3 = 270; //angle for center of square, 

		byte active_columns = dR;  // number of active columns
		int num_leds = active_columns * 22; // number of active LEDs

		int saved_G_dim = G_dim;

		// clear out last center image
		SET_SLOW();
		FastLED.clear();

		// generate an inner image
		//LINE(0, 21, dR, 11, 128);
		//LINE(0, 0, dR, 11, 128);
		LINE(0, 21, dR, 18, 0);  // cap
		LINE(0, 0, dR, 4, 0);   // cap
		LINE(0, 0, 0, 21, 0);  // axle
		CIRCLE(3, 0, 11, 171);
		G_dim = DIMMING_INNER;
		SHOW_slow();

		G_dim = saved_G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}

		num_leds = active_columns * 22; // number of active LEDs
		SET_VAR(num_leds);
		blanks = HALL_MEASURE2(num_leds) + 2;  // find G_max_flashes

		blanks = 10;

		//Serial.println(F("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^SHOW 7^^^^^^^^^"));		
		//Serial.print(F("blanks= "));
		//Serial.println(blanks);
		//Serial.println("");

		// {radius, angle, Z}  // 80 verticies total

		///// front of square1
		cylin[0] = { 21, CENTER - L, 10 + W };  //top right
		cylin[1] = { 21, CENTER - L,10 - W };  //bottom right
		cylin[2] = { 21, CENTER + L,10 - W };  //bottom left
		cylin[3] = { 21, CENTER + L,10 + W };  //top left

		//cylin[2] = { 21, CENTER + L,9 };  //bottom left   FOR TEST ONLY
		//cylin[3] = { 21, CENTER + L,11};  //top left      FOR TEST ONLY

		// back of square1
		cylin[4] = { 21 - dR, CENTER - LB, 10 + W };  //top right
		cylin[5] = { 21 - dR, CENTER - LB,10 - W };  //bottom right
		cylin[6] = { 21 - dR, CENTER + LB,10 - W };  //bottom left
		cylin[7] = { 21 - dR, CENTER + LB,10 + W };  //top left


		///// front of square2
		cylin[8] = { 21, CENTER2 - L2, 10 + W2 };  //top right
		cylin[9] = { 21, CENTER2 - L2,10 - W2 };  //bottom right
		cylin[10] = { 21, CENTER2 + L2,10 - W2 };  //bottom left
		cylin[11] = { 21, CENTER2 + L2,10 + W2 };  //top left

		// back of square2
		cylin[12] = { 21 - dR2, CENTER2 - LB2, 10 + W2 };  //top right
		cylin[13] = { 21 - dR2, CENTER2 - LB2,10 - W2 };  //bottom right
		cylin[14] = { 21 - dR2, CENTER2 + LB2,10 - W2 };  //bottom left
		cylin[15] = { 21 - dR2, CENTER2 + LB2,10 + W2 };  //top left


		///// front of square3
		cylin[16] = { 21, CENTER3 - L3, 10 + W3 };  //top right
		cylin[17] = { 21, CENTER3 - L3,10 - W3 };  //bottom right
		cylin[18] = { 21, CENTER3 + L3,10 - W3 };  //bottom left
		cylin[19] = { 21, CENTER3 + L3,10 + W3 };  //top left

		// back of square3
		cylin[20] = { 21 - dR3, CENTER3 - LB3, 10 + W3 };  //top right
		cylin[21] = { 21 - dR3, CENTER3 - LB3,10 - W3 };  //bottom right
		cylin[22] = { 21 - dR3, CENTER3 + LB3,10 - W3 };  //bottom left
		cylin[23] = { 21 - dR3, CENTER3 + LB3,10 + W3 };  //top left



		int angle_bullet = 0;
		//cylin[24] = { 21 - 4, angle_bullet, 11 }; 
		//cylin[25] = { 21 - 4, angle_bullet+10, 11 };


		HALL_SYNC2();

		byte hue_inc = 0;

		for (byte sl = 0; sl < show_loops; ++sl)
		{

			byte hue_flag = sl % 10;
			byte bullet_flag = sl % 2;


			if (hue_flag == 0)
			{
				++hue_inc;
			}

			if (bullet_flag == 0)
			{
				angle_bullet = angle_bullet + 40;
			}

			if (hue_inc > 6) { hue_inc = 0; }

			if (angle_bullet >= 360) { angle_bullet = 0; }


			// {radius, angle, Z}  // 80 verticies total
				// traversing bullet
			cylin[24] = { 21 - 4, angle_bullet, 1 };
			cylin[25] = { 21 - 4, angle_bullet + 40, 1 };
			cylin[26] = { 21 - 4, angle_bullet, 0 };
			cylin[27] = { 21 - 4, angle_bullet + 40, 0 };

			cylin[28] = { 21 - 4, 360 - angle_bullet, 21 };
			cylin[29] = { 21 - 4, 360 - angle_bullet + 40, 21 };
			cylin[30] = { 21 - 4, 360 - angle_bullet, 20 };
			cylin[31] = { 21 - 4, 360 - angle_bullet + 40, 20 };



			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{

				//LOAD_BACKGROUND();


				/////////////////// cube 1

				//// front square1
				FLASH_DRAW_CYLIN_CORDINATES(0, 1, flash, HUES[0 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(1, 2, flash, HUES[0 + hue_inc], depth); // horizontal line    
				FLASH_DRAW_CYLIN_CORDINATES(2, 3, flash, HUES[0 + hue_inc], depth); // **** ****
				FLASH_DRAW_CYLIN_CORDINATES(3, 0, flash, HUES[0 + hue_inc], depth);

				////// back square1
				FLASH_DRAW_CYLIN_CORDINATES(4, 5, flash, HUES[0 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(5, 6, flash, HUES[0 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(6, 7, flash, HUES[0 + hue_inc], depth);   //
				FLASH_DRAW_CYLIN_CORDINATES(7, 4, flash, HUES[0 + hue_inc], depth);  // horizontal line


				//// connectors between squares1
				FLASH_DRAW_CYLIN_CORDINATES(4, 0, flash, HUES[0 + hue_inc], depth); // ++++
				FLASH_DRAW_CYLIN_CORDINATES(5, 1, flash, HUES[0 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(6, 2, flash, HUES[0 + hue_inc], depth);  //
				FLASH_DRAW_CYLIN_CORDINATES(7, 3, flash, HUES[0 + hue_inc], depth);  // -----


				/////////////////////////// cube 2
				//////	// front square2
				FLASH_DRAW_CYLIN_CORDINATES(8, 9, flash, HUES[1 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(9, 10, flash, HUES[1 + hue_inc], depth); // horizontal line    
				FLASH_DRAW_CYLIN_CORDINATES(10, 11, flash, HUES[1 + hue_inc], depth); // **** ****
				FLASH_DRAW_CYLIN_CORDINATES(11, 8, flash, HUES[1 + hue_inc], depth);

				////// back square2
				FLASH_DRAW_CYLIN_CORDINATES(12, 13, flash, HUES[1 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(13, 14, flash, HUES[1 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(14, 15, flash, HUES[1 + hue_inc], depth);   //
				FLASH_DRAW_CYLIN_CORDINATES(15, 12, flash, HUES[1 + hue_inc], depth);  // horizontal line


				////// connectors between squares2
				FLASH_DRAW_CYLIN_CORDINATES(8, 12, flash, HUES[1 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(9, 13, flash, HUES[1 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(10, 14, flash, HUES[1 + hue_inc], depth);  //
				FLASH_DRAW_CYLIN_CORDINATES(11, 15, flash, HUES[1 + hue_inc], depth);  //


				/////////////////////////// cube 3
				//////	// front square3
				FLASH_DRAW_CYLIN_CORDINATES(16, 17, flash, HUES[2 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(17, 18, flash, HUES[2 + hue_inc], depth); // horizontal line    
				FLASH_DRAW_CYLIN_CORDINATES(18, 19, flash, HUES[2 + hue_inc], depth); // **** ****
				FLASH_DRAW_CYLIN_CORDINATES(19, 16, flash, HUES[2 + hue_inc], depth);

				////// back square3
				FLASH_DRAW_CYLIN_CORDINATES(20, 21, flash, HUES[2 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(21, 22, flash, HUES[2 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(22, 23, flash, HUES[2 + hue_inc], depth);   //
				FLASH_DRAW_CYLIN_CORDINATES(23, 20, flash, HUES[2 + hue_inc], depth);  // horizontal line


				////// connectors between squares3
				FLASH_DRAW_CYLIN_CORDINATES(16, 20, flash, HUES[2 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(17, 21, flash, HUES[2 + hue_inc], depth);
				FLASH_DRAW_CYLIN_CORDINATES(18, 22, flash, HUES[2 + hue_inc], depth);  //
				FLASH_DRAW_CYLIN_CORDINATES(19, 23, flash, HUES[2 + hue_inc], depth);  //


				/// draw bottom bullet
				FLASH_DRAW_CYLIN_CORDINATES(24, 25, flash, -1, 4);
				FLASH_DRAW_CYLIN_CORDINATES(26, 27, flash, -1, 4);

				/// draw top bullet
				FLASH_DRAW_CYLIN_CORDINATES(28, 29, flash, -1, 4);
				FLASH_DRAW_CYLIN_CORDINATES(30, 31, flash, -1, 4);

				BT_interrupt = SHOW_var(num_leds); // display a variable number of LEDs with no dimming from G_dim

				FastLED.clear();

				if (BT_interrupt != 0) { break; }

			}
			FastLED.clear();  // remove all streaking during blanking
			SHOW_var(num_leds); // display a variable number of LEDs with no dimming from G_dim
			if (BT_interrupt != 0) { break; }
			blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1

		}
		G_dim = saved_G_dim;  // restore dimming
	}


	////////////////////////////////////////
	if ((show_num == 8) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // inner and outter spirals
	{

#define NUMBER_OF_BOTTOM_VERTICIES 6

		byte show_loops = 100;  // number of times this show loops

		byte active_columns = 6;  // number of active columns, was 2
		int num_leds = active_columns * 22; // number of active LEDs

		byte depth = 1;

		byte blanks = 6; // number of flashes to ignore at the end to prevent over wrap, was 4
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command

		byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

		int angle_increment = 350 / NUMBER_OF_BOTTOM_VERTICIES;

		int saved_G_dim = G_dim;



		// create inner image
		SET_SLOW();
		FastLED.clear();
		LOAD_BMP(44);
		//LINE(0, 0, 10, 10, 171);  // bottom blue...outter
		//LINE(0, 21, 11, 11, 171); // top magenta...outter
		//LINE(0, 5, 5, 10, 0);  // bottom blue  .. inner
		//LINE(0, 16, 5, 11, 0); // top magenta  .. inner
		//CIRCLE(3, 0, 11, 42);  // yellow center
		G_dim = DIMMING_INNER;
		SHOW_slow();
		SAVE_BACKGROUND();

		G_dim = saved_G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}

		num_leds = active_columns * 22; // number of active LEDs
		SET_VAR(num_leds);
		blanks = HALL_MEASURE2(num_leds) + 1;  // find G_max_flashes

		byte bot_target_index = NUMBER_OF_BOTTOM_VERTICIES + 1;

		// {radius, angle, Z}  // 80 verticies total
		cylin[0] = { NUM_COLUMNS - 1, 180,21 };  //target top  for outter spirals********
		cylin[bot_target_index] = { NUM_COLUMNS - active_columns, 180,0 };  //target bottom for inner spirals  ********



		for (int n = 1; n <= NUMBER_OF_BOTTOM_VERTICIES; ++n)  // generate bottom and top verticies
		{

			cylin[n] = { 21, n * angle_increment, 0 }; // bottom // {radius, angle, Z}  
			cylin[n + bot_target_index] = { NUM_COLUMNS - active_columns, n * angle_increment, 21 }; // top // {radius, angle, Z}  // inner spirals
		}


		int rotation_top_increment = 20; // how many degrees to move the top vertix
		int angle_top_start = 180; // starting angle for top point
		int angle_top = angle_top_start; // how much to move the top vertix
		int direction = 1;

		int HUE_inner = 0;
		int HUE_inner_increment = 1;
		int HUE_inner_direction = 1;

		int HUE_outter = 255;
		int HUE_outter_increment = 2;
		int HUE_outter_direction = -1;

		for (byte sl = 0; sl < show_loops; ++sl)
		{
			//angle_top = angle_top_start + (direction * sl * rotation_top_increment); 
			angle_top = angle_top + (direction * rotation_top_increment);

			if (angle_top > 350)
			{
				angle_top = 350;
				direction = -1 * direction;   // reverse direction
			}

			if (angle_top < 0)
			{
				angle_top = 0;
				direction = -1 * direction;   // reverse direction
			}

			//Serial.print(F("angle_top= "));
			//Serial.println(angle_top);
			//Serial.print(F("direction= "));
			//Serial.println(direction);
			//Serial.print(F("sl= "));
			//Serial.println(sl);
			//Serial.println("");


			// {radius, angle, Z}  // 80 verticies total

			cylin[0] = { NUM_COLUMNS, angle_top,21 };  //target top  ********
			cylin[bot_target_index] = { NUM_COLUMNS - active_columns, 360 - angle_top,0 };  //target bottom  ********

			//cylin[0] = { NUM_COLUMNS, angle_top,11 };  //target top  ********
			//cylin[bot_target_index] = { NUM_COLUMNS , 360 - angle_top,11 };  //target bottom  ********


			/////////
			//HUE_inner = HUE_inner + (HUE_inner_direction*HUE_inner_increment);

			//if (HUE_inner > 255)
			//{
			//	HUE_inner = 255;
			//	HUE_inner_direction = -1 * HUE_inner_direction;  // flip change in HUE direction
			//}
			//if (HUE_inner < 0)
			//{
			//	HUE_inner = 0;
			//	HUE_inner_direction = -1 * HUE_inner_direction;  // flip change in HUE direction
			//}

			//////////
			//HUE_outter = HUE_outter + (HUE_outter_direction*HUE_outter_increment);

			//if (HUE_outter > 255)
			//{
			//	HUE_outter = 255;
			//	HUE_outter_direction = -1 * HUE_outter_direction;  // flip change in HUE direction
			//}
			//if (HUE_outter < 0)
			//{
			//	HUE_outter = 0;
			//	HUE_outter_direction = -1 * HUE_outter_direction;  // flip change in HUE direction
			//}


			////////////////////
			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{

				//LOAD_BACKGROUND();

				///////
				HUE_inner = HUE_inner + (HUE_inner_direction * HUE_inner_increment);

				if (HUE_inner > 255)
				{
					HUE_inner = 255;
					HUE_inner_direction = -1 * HUE_inner_direction;  // flip change in HUE direction
				}
				if (HUE_inner < 0)
				{
					HUE_inner = 0;
					HUE_inner_direction = -1 * HUE_inner_direction;  // flip change in HUE direction
				}

				////////
				HUE_outter = HUE_outter + (HUE_outter_direction * HUE_outter_increment);

				if (HUE_outter > 255)
				{
					HUE_outter = 255;
					HUE_outter_direction = -1 * HUE_outter_direction;  // flip change in HUE direction
				}
				if (HUE_outter < 0)
				{
					HUE_outter = 0;
					HUE_outter_direction = -1 * HUE_outter_direction;  // flip change in HUE direction
				}

				for (int n = 0; n < NUMBER_OF_BOTTOM_VERTICIES; ++n)
				{
					FLASH_DRAW_CYLIN_CORDINATES(0, n + 1, flash, HUE_outter, depth);  // outter
					FLASH_DRAW_CYLIN_CORDINATES(bot_target_index, n + bot_target_index + 1, flash, HUE_inner, depth);  // inner
				}

				BT_interrupt = SHOW_var(num_leds);
				FastLED.clear();

				if (BT_interrupt != 0) { break; }

			}
			FastLED.clear();  // remove all streaking during blanking
			SHOW_var(num_leds);
			if (BT_interrupt != 0) { break; }
			blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1

		}

		G_dim = saved_G_dim;  // restore dimming
	}


	////////////////////////////////////////
	if ((show_num == 9) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))  // for VIDEO
	{

		//	byte DEMO2SHOW = 1;   // 1 or 2

		//	byte show_loops = 125;  // number of times this show loops

		//	byte active_columns = 1;  // number of active columns, was 2

		//	//active_columns = 22;   // test only


		//	int num_leds = active_columns * 22; // number of active LEDs

		//	byte depth = 1;

		//	byte blanks = 6; // number of flashes to ignore at the end to prevent over wrap, was 4
		//	byte BT_interrupt = 0;  // equals 1 if interrupted by BT command

		//	byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color

		//	

		//	int saved_G_dim = G_dim;
		//	byte hue_index = 0;


		//	// create inner image
		//	SET_SLOW();
		//	FastLED.clear();


		//	//// create inner image
		//	//SET_SLOW();
		//	//FastLED.clear();
		//	//LOAD_BMP(44);
		//	////LINE(0, 0, 10, 10, 171);  // bottom blue...outter
		//	////LINE(0, 21, 11, 11, 171); // top magenta...outter
		//	////LINE(0, 5, 5, 10, 0);  // bottom blue  .. inner
		//	////LINE(0, 16, 5, 11, 0); // top magenta  .. inner
		//	////CIRCLE(3, 0, 11, 42);  // yellow center
		//	//G_dim = DIMMING_INNER;
		//	//SHOW_slow();
		//	//SAVE_BACKGROUND();

		//	G_dim = saved_G_dim;

		//	if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		//	{
		//		G_dim = DIMMING_MAX_BRIGHTNESS;
		//	}

		//	num_leds = active_columns * 22; // number of active LEDs
		//	SET_VAR(num_leds);
		//	blanks = HALL_MEASURE2(num_leds) + 1;  // find G_max_flashes

		//	byte top_radius = 21; 

		////	top_radius = 16;     // test only

		//	// {radius, angle, Z}  // 80 verticies total
		//	cylin[0] = { 21, 90, 0 };
		//	cylin[1] = { top_radius, 225, 21 };

		//	cylin[2] = { 21,70,0 };
		//	cylin[3] = { 1, 70 , 0 };

		//	byte resolution_loops = 25;  // # of show loops displaying a particular resolution

		//	for (byte sl = 0; sl < show_loops; ++sl)
		//	{
		//	
		//		if ((0 == sl % resolution_loops)&&(sl >0))
		//		{
		//			active_columns = active_columns + 5;

		//			if (active_columns > 22) { active_columns = 1; }

		//			top_radius = top_radius - 5; 

		//		//	top_radius = 16;     // test only
		//			
		//			if (DEMO2SHOW == 2)
		//			{
		//				cylin[1] = { top_radius, 225, 21 };
		//			}

		//		//	active_columns = 22;   // test only
		//			
		//			// {radius, angle, Z}  // 80 verticies total 
		//			cylin[3] = { 22 - active_columns, 70 , 0 };
		//			
		//			num_leds = active_columns * 22; // number of active LEDs
		//			SET_VAR(num_leds);
		//			blanks = HALL_MEASURE2(num_leds) + 1;  // find G_max_flashes

		//			++hue_index;
		//			
		//		}

		//		////////////////////
		//		for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
		//		{

		//			
		//				FLASH_DRAW_CYLIN_CORDINATES(0, 1, flash, HUES[hue_index], depth);  

		//				FLASH_DRAW_CYLIN_CORDINATES(2, 3, flash, HUES[6], depth);  // bar
		//				
		//			

		//			BT_interrupt = SHOW_var(num_leds);
		//			FastLED.clear();

		//			if (BT_interrupt != 0) { break; }

		//		}
		//		FastLED.clear();  // remove all streaking during blanking
		//		SHOW_var(num_leds);
		//		if (BT_interrupt != 0) { break; }
		//		blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1

		//	}

		//	G_dim = saved_G_dim;  // restore dimming
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////  NON-cylindrical coordinate shows      //////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if (show_num == 10)   //ZIG-ZAG   ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 10 : start"));

		FastLED.clear();

		double peaks = 5;
		double amplitude = 5;
		byte hue = 171;

		// horizontal
		//byte xs = 0;
		//byte ys = 10;
		//byte xe = 21;
		//byte ye = 10;


		// vertical
		//byte xs = 10;
		//byte ys = 0;
		//byte xe = 10;
		//byte ye = 21;

		//diagnol
		//byte xs = 0;
		//byte ys = 0;
		//byte xe = 21;
		//byte ye = 21;

		///////////////////////

		//	// horizontal
		//byte xs = 5;
		//byte ys = 10;
		//byte xe = 21;
		//byte ye = 10;


		//ZIG_ZAG(xs, ys, xe, ye, peaks, amplitude, hue); // generate a zig zag given the axis, amplitude and number of peaks

		//SHOW_slow();
		//BT_DELAY(100);

		//while (0 == 0)
		//{
		//	// wait

		//}

		// horizontal
		int xs = 0;
		int ys = 0;
		int xe = 21;
		int ye;

		byte jump = 3;
		peaks = 7;

		// create tree like zig zag moving up
		//for (byte ye = 0; ye < 22; ye=ye+jump)
		//{
		//	hue = hues[ye+1];
		//	
		//	//FastLED.clear();
		//	ZIG_ZAG(xs, ys, xe, ye, peaks, amplitude, hue); // generate a zig zag given the axis, amplitude and number of peaks
		//	SHOW_slow();
		//	BT_DELAY(100);

		//	--peaks;
		//	if (peaks < 1) { peaks = 1; }

		//}

		int hue_index;

		peaks = 4;

		for (int bounces = 0; bounces < 2; ++bounces)
		{

			for (int hue_cycle = 0; hue_cycle < MAX_HUES; ++hue_cycle)
			{
				xe = 21;

				//tree structure
				for (byte ye = 0; ye < 22; ye = ye + jump)
				{
					hue_index = (ye + hue_cycle) % MAX_HUES;  // use MOD to prevent exceeding maximum number of hues

					hue = hues[hue_index];

					//FastLED.clear();
					ZIG_ZAG(xs, ye, xe, ye, peaks, amplitude, hue); // generate a zig zag given the axis, amplitude and number of peaks
					SHOW_slow();
					BT_DELAY(50);

					xe = xe - jump;

					if (xe < 1) { xe = 1; }

					//	--peaks;
					//if (peaks < 1) { peaks = 1; }

				}

				BT_DELAY(50);
			}
		}

		//BT_DELAY(200);

		//for (int n = 0; n < 100; ++n)
		//{
		//	HUE_CYCLE_VERT(0, 2, 0);
		//	SHOW_slow();
		//	BT_DELAY(50);
		//}

		//BT_DELAY(5000);

		FastLED.clear();

		peaks = 4;

		xe = 11;

		// levetating multiple horizontal disks
		for (byte ye = 0; ye < 22; ye = ye + jump)
		{


			hue = hues[ye + 1];

			//FastLED.clear();
			ZIG_ZAG(xs, ys, xe, ye, peaks, amplitude, hue); // generate a zig zag given the axis, amplitude and number of peaks
			SHOW_slow();
			BT_DELAY(100);

			//	--peaks;
			if (peaks < 1) { peaks = 1; }

		}

		BT_DELAY(5000);


		FastLED.clear();


		///////////////////////
		peaks = 4;

		xs = 0;
		ys = 0;
		ye = 21;
		amplitude = 5;

		////////////// verticle zig-zags////////////////

		for (int bounce = 0; bounce < 3; ++bounce)
		{
			for (int hue_cycle = 0; hue_cycle < MAX_HUES; hue_cycle = hue_cycle + 2)
			{
				for (byte xe = 0; xe < 22; xe = xe + jump)
				{

					hue_index = (xe + hue_cycle) % MAX_HUES;  // use MOD to prevent exceeding maximum number of hues

					hue = hues[hue_index];

					//hue = hues[xe + 1];

					//FastLED.clear();
					ZIG_ZAG(xe, ys, xe, ye, peaks, amplitude, hue); // generate a zig zag given the axis, amplitude and number of peaks
					SHOW_slow();
					BT_DELAY(50);

					//	--peaks;
					if (peaks < 1) { peaks = 1; }

				}

				if (hue_cycle == 0) { BT_DELAY(1500); }  // hold the first image a bit longer
			}
		}
		//BT_DELAY(5000);


	}


	////////////////////////////////////////////////////////////////////////
	if (show_num == 11)   // TWEEN non-random translating lines   ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 11 : start"));

		FastLED.clear();

#define BOUNCES_PER_IMAGE 2  // number of time each image type will bounce between each image bank before a new image type is used

		byte number_of_images = 3;  // number of  images to create for each base set...no more than 10
		byte image_kind = 1;  // kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle
		byte total_increments = 8;  // number of images created between the two base sets, was 5
		int time_between_frames = 200;
		//	byte bounce_cycles = NUMBER_OF_IMAGE_TYPES* BOUNCES_PER_IMAGE;  // number of total_increments  imgage banks cycle back and forth , was 5

		byte bounce_cycles = BOUNCES_PER_IMAGE;  // number of total_increments  imgage banks cycle back and forth , was 5



		//////////////  FOR TEST ONLY  ///////////////////

		//		// 1st line : horizontal
		//XE[0] = 21;
		//XS[0] = 0;
		//YE[0] = 11;
		//YS[0] = 11;
		//HUE_IMAGE[0] = 0;

		//// 2nd line : verticle
		//XS1[0] = 11;  // starting X
		//XE1[0] = 11;  // ending x  , or radius if circle
		//YS1[0] = 0;  // starting y
		//YE1[0] = 21;  // ending y , or radius if circle
		//HUE_IMAGE1[0] = 171;  // blue


		///////////////////////// above for test only //////////////////

		FastLED.clear();


		/////////// BANK 0 ///////////////////
		///////// V up

		TWEEN_IMAGE_START[0].IMAGE_KIND = 0;
		TWEEN_IMAGE_START[0].XS = 0;
		TWEEN_IMAGE_START[0].YS = 0;
		TWEEN_IMAGE_START[0].XE = 21;
		TWEEN_IMAGE_START[0].YE = 21;
		TWEEN_IMAGE_START[0].HUE = 0;


		////////

		///////// V down

		TWEEN_IMAGE_START[1].IMAGE_KIND = 0;
		TWEEN_IMAGE_START[1].XS = 0;
		TWEEN_IMAGE_START[1].YS = 21;
		TWEEN_IMAGE_START[1].XE = 11;
		TWEEN_IMAGE_START[1].YE = 11;
		TWEEN_IMAGE_START[1].HUE = 171;
		////////


		///////// small center circle

		TWEEN_IMAGE_START[2].IMAGE_KIND = 0;
		TWEEN_IMAGE_START[2].XS = 0;
		TWEEN_IMAGE_START[2].YS = 11;
		TWEEN_IMAGE_START[2].XE = 5;
		TWEEN_IMAGE_START[2].YE = 5;
		TWEEN_IMAGE_START[2].HUE = 85;


		////////

		//////////////////////////
		/////////////////////////

		/////////// BANK 1 ///////////////////

		TWEEN_IMAGE_END[0].IMAGE_KIND = 0;  //open
		TWEEN_IMAGE_END[0].XS = 0;
		TWEEN_IMAGE_END[0].YS = 11;
		TWEEN_IMAGE_END[0].XE = 0;
		TWEEN_IMAGE_END[0].YE = 0;
		TWEEN_IMAGE_END[0].HUE = 0;

		////////

		///////// V down
		TWEEN_IMAGE_END[1].IMAGE_KIND = 0;  //open
		TWEEN_IMAGE_END[1].XS = 0;
		TWEEN_IMAGE_END[1].YS = 0;
		TWEEN_IMAGE_END[1].XE = 11;
		TWEEN_IMAGE_END[1].YE = 11;
		TWEEN_IMAGE_END[1].HUE = 171;
		////////

		//	///////// large center circle
		TWEEN_IMAGE_END[2].IMAGE_KIND = 2;  //circle
		TWEEN_IMAGE_END[2].XS = 15;
		TWEEN_IMAGE_END[2].YS = 15;
		TWEEN_IMAGE_END[2].XE = 0;
		TWEEN_IMAGE_END[2].YE = 11;
		TWEEN_IMAGE_END[2].HUE = 85;


		////////

		image_kind = 0;
		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 11 : just before bounce ....."));

		for (image_kind = 1; image_kind < 8; ++image_kind)
		{
			for (byte bounce = 0; bounce < bounce_cycles; ++bounce)
			{
				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}



				//if ((bounce % BOUNCES_PER_IMAGE) == 0)  // only change image every 5'th bounce
				//{
				//	++image_kind;

				//	if (image_kind > 7)  // currently only 1 to 9 is valid..exclude 8 and 9
				//	{
				//		image_kind = 1;  // reset
				//	}

				//}

				//Serial.print(F("---->PROD2: show 11 : image_kind="));
				//Serial.println(image_kind) ;

				// now generate images that transition between these two images
				for (byte increment = 0; increment <= total_increments; ++increment)
				{
					FastLED.clear();


					TWEEN(image_kind, number_of_images, total_increments, increment, 2000, 1);

					SHOW_slow();
					BT_DELAY(time_between_frames);

					if (G_interceeded_flag == 1)  // next show forced so exit
					{
						break;
					}

				}


				// reverse direction
				for (byte increment = 0; increment <= total_increments; ++increment)
				{
					FastLED.clear();



					TWEEN(image_kind, number_of_images, total_increments, increment, 2000, -1);

					SHOW_slow();
					BT_DELAY(time_between_frames);

					if (G_interceeded_flag == 1)  // next show forced so exit
					{
						break;
					}
				}

			}
		}

		//Serial.println(F("++++++PROD2: show 11 : at END bounce &&&&&&&&&&&&&&&"));



	}

	////////////////////////////////////////////////////////////////////////

	if (show_num == 12)   // TWEEN:  line tweening to circle   ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 12 : start"));

		FastLED.clear();

#define BOUNCES_PER_IMAGE 2  // number of time each image type will bounce between each image bank before a new image type is used

		byte number_of_images = 2;  // number of  images to create for each base set...no more than 10...was 3
		byte image_kind = 1;  // kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle
		byte total_increments = 8;  // number of images created between the two base sets, was 5
		int time_between_frames = 200;
		//byte bounce_cycles = NUMBER_OF_IMAGE_TYPES * BOUNCES_PER_IMAGE;  // number of total_increments  imgage banks cycle back and forth , was 5
		byte bounce_cycles = 5;  // number of total_increments  imgage banks cycle back and forth , was 5




		//////////////  FOR TEST ONLY  ///////////////////

		//		// 1st line : horizontal
		//XE[0] = 21;
		//XS[0] = 0;
		//YE[0] = 11;
		//YS[0] = 11;
		//HUE_IMAGE[0] = 0;

		//// 2nd line : verticle
		//XS1[0] = 11;  // starting X
		//XE1[0] = 11;  // ending x  , or radius if circle
		//YS1[0] = 0;  // starting y
		//YE1[0] = 21;  // ending y , or radius if circle
		//HUE_IMAGE1[0] = 171;  // blue


		///////////////////////// above for test only //////////////////

		FastLED.clear();


		/////////// BANK 0 ///////////////////

		TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  //line
		TWEEN_IMAGE_START[0].XS = 0;
		TWEEN_IMAGE_START[0].YS = 0;
		TWEEN_IMAGE_START[0].XE = 21;
		TWEEN_IMAGE_START[0].YE = 21;
		TWEEN_IMAGE_START[0].HUE = 0;
		////////

				///////// circle

		TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  // circle
		TWEEN_IMAGE_START[1].XS = 0;
		TWEEN_IMAGE_START[1].YS = 11;
		TWEEN_IMAGE_START[1].XE = 2;
		TWEEN_IMAGE_START[1].YE = 2;
		TWEEN_IMAGE_START[1].HUE = 75;  // green
		////////


		/////////////////////////

		/////////// BANK 1 ///////////////////

			/////////  circle
		TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
		TWEEN_IMAGE_END[0].XS = 0;
		TWEEN_IMAGE_END[0].YS = 11;
		TWEEN_IMAGE_END[0].XE = 2;  // radius
		TWEEN_IMAGE_END[0].YE = 2;
		TWEEN_IMAGE_END[0].HUE = 171;  // blue


		////////

		//			///////// triangle  .. was circle

		TWEEN_IMAGE_END[1].IMAGE_KIND = 4;  //triangle
		TWEEN_IMAGE_END[1].XS = 0;
		TWEEN_IMAGE_END[1].YS = 11;
		TWEEN_IMAGE_END[1].XE = 8;
		TWEEN_IMAGE_END[1].YE = 8;
		TWEEN_IMAGE_END[1].HUE = 171;  // blue

		////////



		image_kind = 0;  // let GENERATE_TWEEN recover image type from BANK
		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 11 : just before bounce ....."));

		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)
		{
			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}

			//if ((bounce % BOUNCES_PER_IMAGE) == 0)  // only change image every 5'th bounce
			//{
			//	++image_kind;

			//	if (image_kind > NUMBER_OF_IMAGE_TYPES)  // currently only 1 to 4 is valid
			//	{
			//		image_kind = 1;  // reset
			//	}

			//}

			//Serial.print(F("---->PROD2: show 11 : image_kind="));
			//Serial.println(image_kind) ;

			// now generate images that transition between these two images
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();


				TWEEN(image_kind, number_of_images, total_increments, increment, 2000, 1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}


			// reverse direction
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();



				TWEEN(image_kind, number_of_images, total_increments, increment, 2000, -1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}

		}

		Serial.println(F("++++++PROD2: show 12 : at END &&&&&&&&&&&&&&&"));

	}

	////////////////////////////////////////////////////////////////////////
	if (show_num == 13)   // TWEEN:  tweening between more than 2 images
	{

		Serial.println(F("++++++PROD2: show 13 : start"));

		FastLED.clear();

#define BOUNCES_PER_IMAGE 2  // number of time each image type will bounce between each image bank before a new image type is used

		byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
		byte image_kind = 2;  // kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle
		byte total_increments = 8;  // number of images created between the two base sets, was 5
		int time_between_frames = 100;
		byte bounce_cycles = BOUNCES_PER_IMAGE;  // number of total_increments  imgage banks cycle back and forth , was 5

		//byte xs;
		//byte xe;
		//byte ys;
		//byte ye;
		//byte image_bank;
		//byte image_number;




		//////////////  FOR TEST ONLY  ///////////////////

		//		// 1st line : horizontal
		//XE[0] = 21;
		//XS[0] = 0;
		//YE[0] = 11;
		//YS[0] = 11;
		//HUE_IMAGE[0] = 0;

		//// 2nd line : verticle
		//XS1[0] = 11;  // starting X
		//XE1[0] = 11;  // ending x  , or radius if circle
		//YS1[0] = 0;  // starting y
		//YE1[0] = 21;  // ending y , or radius if circle
		//HUE_IMAGE1[0] = 171;  // blue


		///////////////////////// above for test only //////////////////

		FastLED.clear();


		///////////// BANK 0 ///////////////////



		//for (byte increment = 0; increment < 8; ++increment)
		//{

		//	byte xt = X_TRANSLATE(2, 8, 8, increment);

		//	Serial.print(F("increment= "));
		//	Serial.println(increment);
		//	Serial.print(F("xt= "));
		//	Serial.println(xt);
		//}




		image_kind = 0;  // let GENERATE_TWEEN recover image type from structure
		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 11 : just before bounce ....."));

		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)
		{
			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}


			///////// circle
			TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  //circle
			TWEEN_IMAGE_START[0].XS = 0;
			TWEEN_IMAGE_START[0].YS = 11;
			TWEEN_IMAGE_START[0].XE = 2;  // radius
			TWEEN_IMAGE_START[0].YE = 2;
			TWEEN_IMAGE_START[0].HUE = 75;  // green

			TWEEN_IMAGE_START[1].IMAGE_KIND = 6;  //HOZ_V with swap BE
			TWEEN_IMAGE_START[1].XS = 11;
			TWEEN_IMAGE_START[1].YS = 11;
			TWEEN_IMAGE_START[1].XE = 0;
			TWEEN_IMAGE_START[1].YE = 0;
			TWEEN_IMAGE_START[1].HUE = 0;  // red


			////////


			/////////// BANK 1 ///////////////////

			TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
			TWEEN_IMAGE_END[0].XS = 0;
			TWEEN_IMAGE_END[0].YS = 11;
			TWEEN_IMAGE_END[0].XE = 8;
			TWEEN_IMAGE_END[0].YE = 8;
			TWEEN_IMAGE_END[0].HUE = 171;  // blue

			TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  //HOZ_V with swap BE
			TWEEN_IMAGE_END[1].XS = 11;
			TWEEN_IMAGE_END[1].YS = 11;
			TWEEN_IMAGE_END[1].XE = 0;
			TWEEN_IMAGE_END[1].YE = 11;
			TWEEN_IMAGE_END[1].HUE = 0;  // red



			////////

			// now generate images that transition between these two images
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();


				TWEEN(image_kind, number_of_images, total_increments, increment, 2000, 1);  // image 0 to image 1

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}



			///////// circle

			TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  //circle
			TWEEN_IMAGE_START[0].XS = 0;
			TWEEN_IMAGE_START[0].YS = 11;
			TWEEN_IMAGE_START[0].XE = 8;  // radius
			TWEEN_IMAGE_START[0].YE = 8;
			TWEEN_IMAGE_START[0].HUE = 171;  // blue


			TWEEN_IMAGE_START[1] = TWEEN_IMAGE_END[1];
			////////


			// Introduce a 3rd image that image 1 will tween to: BANK 0
			///////// circle ... define a new image for image 1 to tween to .. this is effective image 2
			TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
			TWEEN_IMAGE_END[0].XS = 5;  // move center
			TWEEN_IMAGE_END[0].YS = 11;
			TWEEN_IMAGE_END[0].XE = 5;
			TWEEN_IMAGE_END[0].YE = 5;
			TWEEN_IMAGE_END[0].HUE = 42;  // yellow

			TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  //HOZ_V with swap BE
			TWEEN_IMAGE_END[1].XS = 8;
			TWEEN_IMAGE_END[1].YS = 0;
			TWEEN_IMAGE_END[1].XE = 0;
			TWEEN_IMAGE_END[1].YE = 5;
			TWEEN_IMAGE_END[1].HUE = 0;  // red
			////////


			// reverse direction
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();



				TWEEN(image_kind, number_of_images, total_increments, increment, 2000, 1);   // image 1 to effective image 2...at the end of the tween we will be at image 2

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}

			///////// circle ... define a new image for image 1 to tween to .. this is effective image 2

			TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  //circle
			TWEEN_IMAGE_START[0].XS = 5;  // move center
			TWEEN_IMAGE_START[0].YS = 11;
			TWEEN_IMAGE_START[0].XE = 5;  // radius
			TWEEN_IMAGE_START[0].YE = 5;
			TWEEN_IMAGE_START[0].HUE = 42;  // yellow

			TWEEN_IMAGE_START[1] = TWEEN_IMAGE_END[1];
			////////

		///////// circle

			TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
			TWEEN_IMAGE_END[0].XS = 0;  // move center
			TWEEN_IMAGE_END[0].YS = 11;
			TWEEN_IMAGE_END[0].XE = 2;
			TWEEN_IMAGE_END[0].YE = 2;
			TWEEN_IMAGE_END[0].HUE = 75;  // green


			TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  //HOZ_V with swap BE
			TWEEN_IMAGE_END[1].XS = 0;
			TWEEN_IMAGE_END[1].YS = 21;
			TWEEN_IMAGE_END[1].XE = 5;
			TWEEN_IMAGE_END[1].YE = 11;
			TWEEN_IMAGE_END[1].HUE = 0;  // red
			////////




			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();


				TWEEN(image_kind, number_of_images, total_increments, increment, 2000, 1);  // image 0 to image 1

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}


		}

		Serial.println(F("++++++PROD2: show 13 : at END &&&&&&&&&&&&&&&"));


	}

	////////////////////////////////////////////////////////////////////////
	if (show_num == 14)   //TWEEN:   test HOZ_V   ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 14 : start"));

		FastLED.clear();

#define BOUNCES_PER_IMAGE 2  // number of time each image type will bounce between each image bank before a new image type is used

		byte number_of_images = 2;  // number of  images to create for each base set...no more than 10...was 3
		byte image_kind = 5;  // kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V
		byte total_increments = 8;  // number of images created between the two base sets, was 5
		int time_between_frames = 100;
		byte bounce_cycles = BOUNCES_PER_IMAGE;  // number of total_increments  imgage banks cycle back and forth , was 5

		byte xs;
		byte xe;
		byte ys;
		byte ye;
		byte image_bank;
		byte image_number;




		//////////////  FOR TEST ONLY  ///////////////////

		//		// 1st line : horizontal
		//XE[0] = 21;
		//XS[0] = 0;
		//YE[0] = 11;
		//YS[0] = 11;
		//HUE_IMAGE[0] = 0;

		//// 2nd line : verticle
		//XS1[0] = 11;  // starting X
		//XE1[0] = 11;  // ending x  , or radius if circle
		//YS1[0] = 0;  // starting y
		//YE1[0] = 21;  // ending y , or radius if circle
		//HUE_IMAGE1[0] = 171;  // blue


		///////////////////////// above for test only //////////////////

		FastLED.clear();


		///////////-------------> BANK 0 ///////////////////

				/////////  HOZ_V  


		TWEEN_IMAGE_START[0].IMAGE_KIND = 5;   // HOZ_V
		TWEEN_IMAGE_START[0].XS = 0;
		TWEEN_IMAGE_START[0].YS = 11;
		TWEEN_IMAGE_START[0].XE = 11;
		TWEEN_IMAGE_START[0].YE = 11;
		TWEEN_IMAGE_START[0].HUE = 171;


		////////


			/////////////


		TWEEN_IMAGE_START[1].IMAGE_KIND = 6;   // HOZ_V with swap be
		TWEEN_IMAGE_START[1].XS = 0;
		TWEEN_IMAGE_START[1].YS = 0;
		TWEEN_IMAGE_START[1].XE = 11;
		TWEEN_IMAGE_START[1].YE = 11;
		TWEEN_IMAGE_START[1].HUE = 171;




		/////////// FOR TEST ONLY  ///////////////
		//image_number = 0;
		//image_bank = 0;
		//image_kind = 5;  // HOZ_V
		//xs = 0;
		//ys = 0;
		//xe = 11;
		//ye = 11;
		//hue = 0;  // red

		//byte swap_SE_flag = 1; 


		//FastLED.clear();
		//HOZ_V(xs, ys, xe, ye, swap_SE_flag, hue);
		//SHOW_slow();

		//while (0 == 0)
		//{
		//	// endless

		//}







		///////////----------------> BANK 1 ///////////////////

	///////// V up
		//image_number = 0;
		//image_bank = 1;
		//image_kind = 5;  // HOZ_V
		//xs = 0;
		//ys = 11;
		//xe = 11;
		//ye = 21;
		//hue = 0;  // red

		//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

		TWEEN_IMAGE_END[0].IMAGE_KIND = 5;  // HOZ_V
		TWEEN_IMAGE_END[0].XS = 0;  // move center
		TWEEN_IMAGE_END[0].YS = 11;
		TWEEN_IMAGE_END[0].XE = 11;
		TWEEN_IMAGE_END[0].YE = 21;
		TWEEN_IMAGE_END[0].HUE = 0;
		////////

			/////////////
		//image_number = 1;
		//image_bank = 1;
		//image_kind = 6;  // HOZ_V with swap SE
		//xs = 0;
		//ys = 11;
		//xe = 11;
		//ye = 11;
		//hue = 171;  // blue

		//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

		TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  // HOZ_V with swap SE
		TWEEN_IMAGE_END[1].XS = 0;  // move center
		TWEEN_IMAGE_END[1].YS = 11;
		TWEEN_IMAGE_END[1].XE = 11;
		TWEEN_IMAGE_END[1].YE = 11;
		TWEEN_IMAGE_END[1].HUE = 171;

		image_kind = 0;  // let GENERATE_TWEEN recover image type from BANK
		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 11 : just before bounce ....."));

		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)
		{
			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}

			//if ((bounce % BOUNCES_PER_IMAGE) == 0)  // only change image every 3rd bounce
			//{
			//	++image_kind;

			//	//image_kind = 6;

			//	//if (image_kind > NUMBER_OF_IMAGE_TYPES)  // currently only 1 to 6 is valid
			//	if (image_kind > 6)  // currently only 1 to 6 is valid
			//	{
			//		//image_kind = 1;  // reset
			//		image_kind = 5;  // reset
			//	}

			//}

			//Serial.print(F("---->PROD2: show 11 : image_kind="));
			//Serial.println(image_kind) ;

			// now generate images that transition between these two images
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();


				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, 1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}

			///// now tween image 1 horizontally rather than vertically  //////




			// reverse direction
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();



				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, -1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}




			/////////////
			//image_number = 1;
			//image_bank = 0;
			//image_kind = 6;  // HOZ_V with swap SE
			//xs = 0;
			//ys = 0;
			//xe = 11;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_START[1].IMAGE_KIND = 6;   // HOZ_V with swap be
			TWEEN_IMAGE_START[1].XS = 0;
			TWEEN_IMAGE_START[1].YS = 0;
			TWEEN_IMAGE_START[1].XE = 11;
			TWEEN_IMAGE_START[1].YE = 11;
			TWEEN_IMAGE_START[1].HUE = 171;

			/////////////
			//image_number = 1;
			//image_bank = 1;
			//image_kind = 6;  // HOZ_V with swap SE
			//xs = 0;
			//ys = 0;
			//xe = 0;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  // HOZ_V with swap SE
			TWEEN_IMAGE_END[1].XS = 0;
			TWEEN_IMAGE_END[1].YS = 0;
			TWEEN_IMAGE_END[1].XE = 0;
			TWEEN_IMAGE_END[1].YE = 11;
			TWEEN_IMAGE_END[1].HUE = 171;

			image_kind = 0;  // let GENERATE_TWEEN recover image type from BANK


			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();


				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, 1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}

			// reverse direction
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();



				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, -1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}


			/////////////
			//image_number = 1;
			//image_bank = 0;
			//image_kind = 6;  // HOZ_V with swap be
			//xs = 0;
			//ys = 0;
			//xe = 11;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_START[1].IMAGE_KIND = 6;   // HOZ_V with swap be
			TWEEN_IMAGE_START[1].XS = 0;
			TWEEN_IMAGE_START[1].YS = 0;
			TWEEN_IMAGE_START[1].XE = 11;
			TWEEN_IMAGE_START[1].YE = 11;
			TWEEN_IMAGE_START[1].HUE = 171;

			/////////////
			//image_number = 1;
			//image_bank = 1;
			//image_kind = 6;  // HOZ_V with swap SE
			//xs = 0;
			//ys = 11;
			//xe = 11;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  // HOZ_V with swap SE
			TWEEN_IMAGE_END[1].XS = 0;
			TWEEN_IMAGE_END[1].YS = 11;
			TWEEN_IMAGE_END[1].XE = 11;
			TWEEN_IMAGE_END[1].YE = 11;
			TWEEN_IMAGE_END[1].HUE = 171;


			image_kind = 0;  // let GENERATE_TWEEN recover image type from BANK

		}

		//Serial.println(F("++++++PROD2: show 11 : at END bounce &&&&&&&&&&&&&&&"));

	}

	////////////////////////////////////////////////////////////////////////
	if (show_num == 15)   // TWEEN ZIG_ZAG   ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 15 : start"));

		FastLED.clear();

#define BOUNCES_PER_IMAGE 3  // number of time each image type will bounce between each image

		byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
		byte image_kind = 0;  //0=use stored image kind,  kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle, 7=ZG_ZAG
		byte total_increments = 3;  // number of images created between the two base sets, was 5
		int time_between_frames = 1000;
		byte bounce_cycles = 2;  // 



		//////////////  FOR TEST ONLY  ///////////////////

		//		// 1st line : horizontal
		//XE[0] = 21;
		//XS[0] = 0;
		//YE[0] = 11;
		//YS[0] = 11;
		//HUE_IMAGE[0] = 0;

		//// 2nd line : verticle
		//XS1[0] = 11;  // starting X
		//XE1[0] = 11;  // ending x  , or radius if circle
		//YS1[0] = 0;  // starting y
		//YE1[0] = 21;  // ending y , or radius if circle
		//HUE_IMAGE1[0] = 171;  // blue


		///////////////////////// above for test only //////////////////




		/////////// BANK 0 ///////////////////
		///////// zig_zag bottom

		TWEEN_IMAGE_START[0].IMAGE_KIND = 7;
		TWEEN_IMAGE_START[0].XS = 0;
		TWEEN_IMAGE_START[0].YS = 0;
		TWEEN_IMAGE_START[0].XE = 21;
		TWEEN_IMAGE_START[0].YE = 0;
		TWEEN_IMAGE_START[0].HUE = 171;
		TWEEN_IMAGE_START[0].DATA1 = 4;   // peaks
		TWEEN_IMAGE_START[0].DATA2 = 4;  // amplitude

		TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
		TWEEN_IMAGE_START[1].XS = 0;
		TWEEN_IMAGE_START[1].YS = 0;
		TWEEN_IMAGE_START[1].XE = 0;
		TWEEN_IMAGE_START[1].YE = 21;
		TWEEN_IMAGE_START[1].HUE = 42;  // yellow
		TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
		TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
		TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



		/////////////////////////

		/////////// BANK 1 ///////////////////



		TWEEN_IMAGE_END[0].IMAGE_KIND = 7;  //zig_zag
		TWEEN_IMAGE_END[0].XS = 0;
		TWEEN_IMAGE_END[0].YS = 15;
		TWEEN_IMAGE_END[0].XE = 11;
		TWEEN_IMAGE_END[0].YE = 15;
		TWEEN_IMAGE_END[0].HUE = 0;
		TWEEN_IMAGE_END[0].DATA1 = 2;   // peaks
		TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude

		TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
		TWEEN_IMAGE_END[1].XS = 0;
		TWEEN_IMAGE_END[1].YS = 0;
		TWEEN_IMAGE_END[1].XE = 0;
		TWEEN_IMAGE_END[1].YE = 21;
		TWEEN_IMAGE_END[1].HUE = 42;
		TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
		TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
		TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow

		////////




		////////

		image_kind = 0;  // use stored image kind

		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 11 : just before bounce ....."));

		FastLED.clear();

		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)
		{
			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}


			//if ((bounce % BOUNCES_PER_IMAGE) == 0)  // only change image every 5'th bounce
			//{
			//	++image_kind;

			//	if (image_kind > NUMBER_OF_IMAGE_TYPES)  // currently only 1 to 4 is valid
			//	{
			//		image_kind = 1;  // reset
			//	}

			//}

			//Serial.print(F("---->PROD2: show 11 : image_kind="));
			//Serial.println(image_kind) ;

			Serial.println(F("++++++PROD2: show 15 : direction = forward"));

			// now generate images that transition between these two images
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				//FastLED.clear();


				TWEEN(image_kind, number_of_images, total_increments, increment, STARTING_IMAGE_HUE, 1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}

			FastLED.clear();

			Serial.println(F("++++++PROD2: show 15 : direction = *reverse*"));

			// reverse direction
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				//FastLED.clear();



				TWEEN(image_kind, number_of_images, total_increments, increment, ENDING_IMAGE_HUE, -1);

				SHOW_slow();
				BT_DELAY(time_between_frames);

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}
			}

		}

		//FastLED.clear();

		Serial.println(F("++++++PROD2: show 15 : at END bounce &&&&&&&&&&&&&&&"));



	}

	//////////////////////
	if (show_num == 16)   // TWEEN SPIKES   ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 16 : start"));

		//#define ERASE_IMAGE 999 
		//#define BLEND_START_END_HUE 1000
		//#define STARTING_IMAGE_HUE 2000
		//#define ENDING_IMAGE_HUE 3000

		FastLED.clear();

#define BOUNCES_PER_IMAGE 3  // number of time each image type will bounce between each image

		byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
		byte image_kind = 0;  //0=use stored image kind,  kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle, 7=ZG_ZAG
		byte total_increments = 8;  // number of images created between the two base sets, was 5
		int time_between_frames = 200;
		byte bounce_cycles = 2;  // 



		//////////////  FOR TEST ONLY  ///////////////////

		//int xs = 0;
		//int ys = 0;
		//int xe = 21;
		//int ye = 21;
		//byte number_of_spikes = 4;
		//double amplitude = -5;
		//byte mode = 0;
		//int hue_axis = 171;  // blue
		//int hue_spikes = 0;  // red

		//SPIKES(xs, ys, xe, ye, number_of_spikes, amplitude, mode, hue_axis, hue_spikes);  // generate a line with spikes at regular intervals

		//SHOW_slow();

		//while (0 == 0) 
		//{
		//	///endless loop 
		//}


		///////////////////////// above for test only //////////////////




		/////////// START  ///////////////////
		///////// spikes

		TWEEN_IMAGE_START[0].IMAGE_KIND = 8;  // spikes with axis
		TWEEN_IMAGE_START[0].XS = 0;
		TWEEN_IMAGE_START[0].YS = 0;
		TWEEN_IMAGE_START[0].XE = 11;
		TWEEN_IMAGE_START[0].YE = 11;
		TWEEN_IMAGE_START[0].HUE = 171;  // axis hue
		TWEEN_IMAGE_START[0].DATA1 = 5;   // peaks
		TWEEN_IMAGE_START[0].DATA2 = 10;  // amplitude
		TWEEN_IMAGE_START[0].DATA3 = 0;  // spike hue  


		TWEEN_IMAGE_START[1].IMAGE_KIND = 4;  // spikes with axis
		TWEEN_IMAGE_START[1].XS = 0;
		TWEEN_IMAGE_START[1].YS = 0;
		TWEEN_IMAGE_START[1].XE = 21;
		TWEEN_IMAGE_START[1].YE = 21;
		TWEEN_IMAGE_START[1].HUE = 42;  // axis hue  yellow
		TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
		TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
		TWEEN_IMAGE_START[1].DATA3 = 128;  // spike hue aqua


		/////////////////////////

		/////////// END ///////////////////

		TWEEN_IMAGE_END[0].IMAGE_KIND = 8;  //spike with axis
		TWEEN_IMAGE_END[0].XS = 0;
		TWEEN_IMAGE_END[0].YS = 21;
		TWEEN_IMAGE_END[0].XE = 11;
		TWEEN_IMAGE_END[0].YE = 11;
		TWEEN_IMAGE_END[0].HUE = 0;
		TWEEN_IMAGE_END[0].DATA1 = 5;   // peaks
		TWEEN_IMAGE_END[0].DATA2 = -10;  // amplitude
		TWEEN_IMAGE_END[0].DATA3 = 171;  // spike hue = yellow

		TWEEN_IMAGE_END[1].IMAGE_KIND = 4;  //spike with axis
		TWEEN_IMAGE_END[1].XS = 21;
		TWEEN_IMAGE_END[1].YS = 0;
		TWEEN_IMAGE_END[1].XE = 0;
		TWEEN_IMAGE_END[1].YE = 21;
		TWEEN_IMAGE_END[1].HUE = 128;
		TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
		TWEEN_IMAGE_END[1].DATA2 = -5;  // amplitude
		TWEEN_IMAGE_END[1].DATA3 = 42;  // spike hue = yellow


		////////




		////////

		image_kind = 0;  // use stored image kind

		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 11 : just before bounce ....."));

		FastLED.clear();

		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)
		{
			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}


			//if ((bounce % BOUNCES_PER_IMAGE) == 0)  // only change image every 5'th bounce
			//{
			//	++image_kind;

			//	if (image_kind > NUMBER_OF_IMAGE_TYPES)  // currently only 1 to 4 is valid
			//	{
			//		image_kind = 1;  // reset
			//	}

			//}

			//Serial.print(F("---->PROD2: show 11 : image_kind="));
			//Serial.println(image_kind) ;

			Serial.println(F("++++++PROD2: show 16: direction = forward"));

			// now generate images that transition between these two images
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();

				//hue = hues[increment];
				//TWEEN_IMAGE_START[0].DATA3 = hue;
				//TWEEN_IMAGE_END[0].DATA3 = hue;

				TWEEN(image_kind, number_of_images, total_increments, increment, STARTING_IMAGE_HUE, 1);

				SHOW_slow();
				BT_DELAY(time_between_frames);
				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}

			//FastLED.clear();

			Serial.println(F("++++++PROD2: show 16 : direction = *reverse*"));

			// reverse direction
			for (byte increment = 0; increment <= total_increments; ++increment)
			{
				FastLED.clear();

				//hue = hues[total_increments - increment];
				//TWEEN_IMAGE_START[0].DATA3 = hue;
				//TWEEN_IMAGE_END[0].DATA3 = hue;

				TWEEN(image_kind, number_of_images, total_increments, increment, ENDING_IMAGE_HUE, -1);

				SHOW_slow();
				BT_DELAY(time_between_frames);
				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}

		}

		//FastLED.clear();

		Serial.println(F("++++++PROD2: show 16 : at END &&&&&&&&&&&&&&&"));



	}

	/////////////////////////////////////////////////////////////////////////////////

	if (show_num == 17)  //SPIKES with trace   ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 17 : start"));
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);

		FastLED.clear();
		SHOW_slow();

		double peaks = 5;
		double amplitude = 5;
		byte hue = 171;


		// horizontal
		int xs = 0;
		int ys = 0;
		int xe = 21;
		int ye;

		byte jump = 4;  //3
		peaks = 7;


		peaks = 4;

		hue = 171;

		byte hue2 = 0;
		int direction = -1;

		//tree structure
		for (byte ye = 0; ye < 22; ye = ye + jump)
		{
			//hue = hues[ye + 1];

			//hue = hue + 2*ye; 

			//hue =  2 * ye;
			//hue2 = 171 +  ye;

			//if (ye > 10)
			//{
			//	hue2 = 0;
			//}

			//hue2 = 0;
			//hue = 171;

			//FastLED.clear();
			SPIKES(xs, ye, xe, ye, peaks, amplitude, 1, hue2, hue); // generate a zig zag given the axis, amplitude and number of peaks
			SHOW_slow();
			BT_DELAY(100);

			xe = xe + direction * 2 * jump;

			if (xe < 1)
			{
				direction = 1;
				xe = 1;

			}
			//if (xe < 1) { xe = 1; }

		}

		//Serial.println(F("++++++PROD2: show 17 : position 1"));
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);


		BT_DELAY(5000);

		//Serial.println(F("++++++PROD2: show 17 : position 2a"));
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);

		FastLED.clear();

		xs = 0;
		ys = 0;
		xe = 11;
		amplitude = 5;

		jump = 3;

		int hue_index = MAX_HUES - 1;

		peaks = 4;

		// levetating multiple horizontal disks
		for (byte ye = 0; ye < 22; ye = ye + jump)
		{
			//hue = hues[ye + 1];

			if ((ye % 3) == 0)
			{
				++amplitude;
				--hue_index;

				if (amplitude < 0) { amplitude = 0; }
				if (hue_index < 0) { hue_index = 0; }

				hue = hues[hue_index];
			}



			//Serial.println(F("++++++PROD2: show 17 : position 2b"));
			//Serial.print(F("G_sampling_period_us= "));
			//Serial.println(G_sampling_period_us);

			//FastLED.clear();
			SPIKES(xs, ys, xe, ye, peaks, amplitude, 1, hue, hue); // generate a zig zag given the axis, amplitude and number of peaks

			//Serial.println(F("++++++PROD2: show 17 : position 2c"));
			//Serial.print(F("G_sampling_period_us= "));
			//Serial.println(G_sampling_period_us);

			SHOW_slow();
			BT_DELAY(100);

			//	--peaks;
			if (peaks < 1) { peaks = 1; }

		}

		//Serial.println(F("++++++PROD2: show 17 : position 3"));
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);

		BT_DELAY(5000);

		//Serial.println(F("++++++PROD2: show 17 : position 4"));
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);

		FastLED.clear();


		///////////////////////
		//peaks = 4;

		//xs = 0;
		//ys = 0;
		//ye = 21;
		//amplitude = 5;

		//////////////// verticle zig-zags////////////////
		//for (byte xe = 0; xe < 22; xe = xe + jump)
		//{
		//	hue = hues[xe + 1];

		//	//FastLED.clear();
		//	SPIKES(xs, ye, xe, ye, peaks, amplitude, 1, hue, hue); // generate a zig zag given the axis, amplitude and number of peaks
		//	SHOW_slow();
		//	BT_DELAY(100);

		//	//	--peaks;
		//	if (peaks < 1) { peaks = 1; }

		//}

		//BT_DELAY(5000);

		//Serial.println(F("++++++PROD2: show 17 : at END &&&&&&&&&&&&&&&"));
		//Serial.print(F("G_sampling_period_us= "));
		//Serial.println(G_sampling_period_us);


	}

	/////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////
	if ((show_num == 18) && (G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))   //TWEEN:   test HOZ_V with FLASH drawing  ** a NON-cylindrical coordinate show  **
	{

		Serial.println(F("++++++PROD2: show 18 : start"));

		FastLED.clear();

#define BOUNCES_PER_IMAGE 20  // number of time each image type will bounce between each image bank before a new image type is used, was 10

		byte number_of_images = 2;  // number of  images to create for each base set...no more than 10...was 3
		byte image_kind = 5;  // kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V
		byte total_increments = 8;  // number of images created between the two base sets, was 5
		int time_between_frames = 100;
		byte bounce_cycles = BOUNCES_PER_IMAGE;  // number of total_increments  imgage banks cycle back and forth , was 5

		byte xs;
		byte xe;
		byte ys;
		byte ye;
		byte image_bank;
		byte image_number;

		byte increment = 0;
		byte number_of_flashes_when_LEDS_are_off = 2;

		int saved_G_dim = G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}



		//SET_VAR(NUM_LEDS);

		SET_SLOW();
		byte blanks = HALL_MEASURE2(NUM_LEDS) + 1;  // find G_max_flashes

		total_increments = G_max_flashes - blanks;

		//////////////  FOR TEST ONLY  ///////////////////

		//		// 1st line : horizontal
		//XE[0] = 21;
		//XS[0] = 0;
		//YE[0] = 11;
		//YS[0] = 11;
		//HUE_IMAGE[0] = 0;

		//// 2nd line : verticle
		//XS1[0] = 11;  // starting X
		//XE1[0] = 11;  // ending x  , or radius if circle
		//YS1[0] = 0;  // starting y
		//YE1[0] = 21;  // ending y , or radius if circle
		//HUE_IMAGE1[0] = 171;  // blue


		///////////////////////// above for test only //////////////////

		FastLED.clear();


		///////////-------------> BANK 0 ///////////////////

				/////////  HOZ_V  


		TWEEN_IMAGE_START[0].IMAGE_KIND = 5;   // HOZ_V
		TWEEN_IMAGE_START[0].XS = 0;
		TWEEN_IMAGE_START[0].YS = 11;
		TWEEN_IMAGE_START[0].XE = 11;
		TWEEN_IMAGE_START[0].YE = 11;
		TWEEN_IMAGE_START[0].HUE = 171;


		////////


			/////////////


		TWEEN_IMAGE_START[1].IMAGE_KIND = 6;   // HOZ_V with swap be
		TWEEN_IMAGE_START[1].XS = 0;
		TWEEN_IMAGE_START[1].YS = 0;
		TWEEN_IMAGE_START[1].XE = 11;
		TWEEN_IMAGE_START[1].YE = 11;
		TWEEN_IMAGE_START[1].HUE = 171;




		/////////// FOR TEST ONLY  ///////////////
		//image_number = 0;
		//image_bank = 0;
		//image_kind = 5;  // HOZ_V
		//xs = 0;
		//ys = 0;
		//xe = 11;
		//ye = 11;
		//hue = 0;  // red

		//byte swap_SE_flag = 1; 


		//FastLED.clear();
		//HOZ_V(xs, ys, xe, ye, swap_SE_flag, hue);
		//SHOW_slow();

		//while (0 == 0)
		//{
		//	// endless

		//}







		///////////----------------> BANK 1 ///////////////////

	///////// V up
		//image_number = 0;
		//image_bank = 1;
		//image_kind = 5;  // HOZ_V
		//xs = 0;
		//ys = 11;
		//xe = 11;
		//ye = 21;
		//hue = 0;  // red

		//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

		TWEEN_IMAGE_END[0].IMAGE_KIND = 5;  // HOZ_V
		TWEEN_IMAGE_END[0].XS = 0;  // move center
		TWEEN_IMAGE_END[0].YS = 11;
		TWEEN_IMAGE_END[0].XE = 11;
		TWEEN_IMAGE_END[0].YE = 21;
		TWEEN_IMAGE_END[0].HUE = 0;
		////////

			/////////////
		//image_number = 1;
		//image_bank = 1;
		//image_kind = 6;  // HOZ_V with swap SE
		//xs = 0;
		//ys = 11;
		//xe = 11;
		//ye = 11;
		//hue = 171;  // blue

		//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

		TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  // HOZ_V with swap SE
		TWEEN_IMAGE_END[1].XS = 0;  // move center
		TWEEN_IMAGE_END[1].YS = 11;
		TWEEN_IMAGE_END[1].XE = 11;
		TWEEN_IMAGE_END[1].YE = 11;
		TWEEN_IMAGE_END[1].HUE = 171;

		image_kind = 0;  // let GENERATE_TWEEN recover image type from BANK
		/////////////////////////// ***************** ///////////////////////////////////
		//Serial.println(F("++++++PROD2: show 17 : just before bounce ....."));

		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)  // number of times to execute show
		{
			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}

			FastLED.clear();
			SHOW_slow();

			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{


				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, 1);

				++increment;

				if (increment > total_increments)
				{
					increment = 0;
				}

				BT_interrupt = SHOW_var(NUM_LEDS);

				FastLED.clear();

				for (byte off = 0; off < number_of_flashes_when_LEDS_are_off; ++off)
				{
					++flash;

					BT_interrupt = SHOW_var(NUM_LEDS);
				}

				//if (BT_interrupt != 0) { break; }

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}


			//FastLED.clear();  // remove all streaking during blanking
			//SHOW_var(NUM_LEDS);

			blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1

			//if (BT_interrupt != 0) { break; }


			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}





			// now generate images that transition between these two images
			//for (byte increment = 0; increment <= total_increments; ++increment)
			//{
			//	FastLED.clear();


			//	TWEEN(image_kind, number_of_images, total_increments, increment, 1000, 1);

			//	SHOW_slow();
			//	BT_DELAY(time_between_frames);

			//	if (G_interceeded_flag == 1)  // next show forced so exit
			//	{
			//		break;
			//	}
			//}

			///// now tween image 1 horizontally rather than vertically  //////


			FastLED.clear();
			SHOW_slow();
			increment = 0;

			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{


				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, -1);

				++increment;

				if (increment > total_increments)
				{
					increment = 0;
				}

				BT_interrupt = SHOW_var(NUM_LEDS);

				FastLED.clear();

				for (byte off = 0; off < number_of_flashes_when_LEDS_are_off; ++off)
				{
					++flash;

					BT_interrupt = SHOW_var(NUM_LEDS);
				}

				//if (BT_interrupt != 0) { break; }

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}






			// reverse direction
			//for (byte increment = 0; increment <= total_increments; ++increment)
			//{
			//	FastLED.clear();



			//	TWEEN(image_kind, number_of_images, total_increments, increment, 1000, -1);

			//	SHOW_slow();
			//	BT_DELAY(time_between_frames);

			//	if (G_interceeded_flag == 1)  // next show forced so exit
			//	{
			//		break;
			//	}
			//}




			/////////////
			//image_number = 1;
			//image_bank = 0;
			//image_kind = 6;  // HOZ_V with swap SE
			//xs = 0;
			//ys = 0;
			//xe = 11;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_START[1].IMAGE_KIND = 6;   // HOZ_V with swap be
			TWEEN_IMAGE_START[1].XS = 0;
			TWEEN_IMAGE_START[1].YS = 0;
			TWEEN_IMAGE_START[1].XE = 11;
			TWEEN_IMAGE_START[1].YE = 11;
			TWEEN_IMAGE_START[1].HUE = 171;

			/////////////
			//image_number = 1;
			//image_bank = 1;
			//image_kind = 6;  // HOZ_V with swap SE
			//xs = 0;
			//ys = 0;
			//xe = 0;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  // HOZ_V with swap SE
			TWEEN_IMAGE_END[1].XS = 0;
			TWEEN_IMAGE_END[1].YS = 0;
			TWEEN_IMAGE_END[1].XE = 0;
			TWEEN_IMAGE_END[1].YE = 11;
			TWEEN_IMAGE_END[1].HUE = 171;

			image_kind = 0;  // let GENERATE_TWEEN recover image type from BANK


			FastLED.clear();
			SHOW_slow();
			increment = 0;

			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{


				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, 1);

				++increment;

				if (increment > total_increments)
				{
					increment = 0;
				}

				BT_interrupt = SHOW_var(NUM_LEDS);

				FastLED.clear();

				for (byte off = 0; off < number_of_flashes_when_LEDS_are_off; ++off)
				{
					++flash;

					BT_interrupt = SHOW_var(NUM_LEDS);
				}

				//if (BT_interrupt != 0) { break; }

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}



			//for (byte increment = 0; increment <= total_increments; ++increment)
			//{
			//	FastLED.clear();


			//	TWEEN(image_kind, number_of_images, total_increments, increment, 1000, 1);

			//	SHOW_slow();
			//	BT_DELAY(time_between_frames);

			//	if (G_interceeded_flag == 1)  // next show forced so exit
			//	{
			//		break;
			//	}
			//}


			FastLED.clear();
			SHOW_slow();
			increment = 0;

			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{


				TWEEN(image_kind, number_of_images, total_increments, increment, 1000, -1);

				++increment;

				if (increment > total_increments)
				{
					increment = 0;
				}

				BT_interrupt = SHOW_var(NUM_LEDS);

				FastLED.clear();

				for (byte off = 0; off < number_of_flashes_when_LEDS_are_off; ++off)
				{
					++flash;

					BT_interrupt = SHOW_var(NUM_LEDS);
				}

				//if (BT_interrupt != 0) { break; }

				if (G_interceeded_flag == 1)  // next show forced so exit
				{
					break;
				}

			}




			// reverse direction
			//for (byte increment = 0; increment <= total_increments; ++increment)
			//{
			//	FastLED.clear();



			//	TWEEN(image_kind, number_of_images, total_increments, increment, 1000, -1);

			//	SHOW_slow();
			//	BT_DELAY(time_between_frames);

			//	if (G_interceeded_flag == 1)  // next show forced so exit
			//	{
			//		break;
			//	}
			//}


			/////////////
			//image_number = 1;
			//image_bank = 0;
			//image_kind = 6;  // HOZ_V with swap be
			//xs = 0;
			//ys = 0;
			//xe = 11;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_START[1].IMAGE_KIND = 6;   // HOZ_V with swap be
			TWEEN_IMAGE_START[1].XS = 0;
			TWEEN_IMAGE_START[1].YS = 0;
			TWEEN_IMAGE_START[1].XE = 11;
			TWEEN_IMAGE_START[1].YE = 11;
			TWEEN_IMAGE_START[1].HUE = 171;

			/////////////
			//image_number = 1;
			//image_bank = 1;
			//image_kind = 6;  // HOZ_V with swap SE
			//xs = 0;
			//ys = 11;
			//xe = 11;
			//ye = 11;
			//hue = 171;  // blue

			//RECORD_IMAGE(image_kind, xs, ys, xe, ye, hue, image_bank, image_number);

			TWEEN_IMAGE_END[1].IMAGE_KIND = 6;  // HOZ_V with swap SE
			TWEEN_IMAGE_END[1].XS = 0;
			TWEEN_IMAGE_END[1].YS = 11;
			TWEEN_IMAGE_END[1].XE = 11;
			TWEEN_IMAGE_END[1].YE = 11;
			TWEEN_IMAGE_END[1].HUE = 171;


			image_kind = 0;  // let GENERATE_TWEEN recover image type from BANK

		}

		G_dim = saved_G_dim;  // restore dimming

		//Serial.println(F("++++++PROD2: show 11 : at END bounce &&&&&&&&&&&&&&&"));

		//G_show_num = 9;   // THIS IS FOR YOUTUBE VIDEO ONLY
		//show_num = 9;    // THIS IS FOR YOUTUBE VIDEO ONLY
	}

	/////////////////////////////////////////////////////////////

	if (show_num == 19)
	{

		//G_dim = 0;
		//G_dim_shape = 0;

		//byte tween_kind = 2;
		byte bounce_cycles = 40;

		/////////// START ///////////////////



		//if (IMPRINT_ONLY == 0)  // SKIP for now, use IMPRINT
		//{
		//	FastLED.clear();
		//}


		///for (byte hue = 0; hue < 256; hue = hue + 10)
		//byte forever = 1; 

		
		
			static byte print_once = 0;




			//////////////*************************** first genereate IMAGE  ****************************** //////////////////////////////////////

			static byte do_once = 1;

			if (do_once == 1)
			{
				FastLED.clear();
				do_once = 0;
			}

			int direction = 1;


			for (byte bounce = 0; bounce < bounce_cycles; ++bounce)  // number of times to execute show
			{
				printD("TEST 11: bounce="), bounce);
				SPACE

					static byte print_once_flag = 1;


				FastLED.clear();

				//if (bounce % 11 == 0)
				//{
				//	direction = -1 * direction;
				//}

				////////////////////////////////////////////////CREATE TWEEN  ////////////////////////////////////////////////////
				////////////////////////////////////////////////CREATE TWEEN  ////////////////////////////////////////////////////
				////////////////////////////////////////////////CREATE TWEEN  ////////////////////////////////////////////////////

				// hue_code = 0 to 255 will force hue; 999=ERASE image;  1000  = generate a weighted blend between start and end images;  2000=use hue from starting image, 3000=use hue from ending image

				// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
				// 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes

				if (bounce == 0)
				{
					TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  // circle
					TWEEN_IMAGE_START[0].XS = 0;  // center
					TWEEN_IMAGE_START[0].YS = 11;
					TWEEN_IMAGE_START[0].XE = 1;   // radius
					TWEEN_IMAGE_START[0].YE = 21;
					TWEEN_IMAGE_START[0].HUE = 85;
					TWEEN_IMAGE_START[0].DATA1 = 1;   // not used
					TWEEN_IMAGE_START[0].DATA2 = 2;  // not used
					TWEEN_IMAGE_START[0].DATA3 = 0;  // not used


					TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
					TWEEN_IMAGE_END[0].XS = 0;
					TWEEN_IMAGE_END[0].YS = 11;  // 10
					TWEEN_IMAGE_END[0].XE = 11; // radius
					TWEEN_IMAGE_END[0].YE = 21;
					TWEEN_IMAGE_END[0].HUE = 171;
					TWEEN_IMAGE_END[0].DATA1 = 3;   // not used
					TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude
					TWEEN_IMAGE_END[0].DATA3 = 0;  // amplitude

					////////////////


					///// SPIKE INFO  /////////////
					//double peaks_start = double(TWEEN_IMAGE_START[n].DATA1);   // number of peaks
					//double peaks_end = double(TWEEN_IMAGE_END[n].DATA1);   // number of peaks at finish

					//double amp_start = double(TWEEN_IMAGE_START[n].DATA2);   // starting amplitude
					//double amp_end = double(TWEEN_IMAGE_END[n].DATA2);   // ending amplitude

					//byte mode_s = 0;  // starting mode...for SPIKES
					//byte mode_e = 0;  // ending mode...for SPIKES



					TWEEN_IMAGE_START[1].IMAGE_KIND = 1;  //line
					TWEEN_IMAGE_START[1].XS = 0;
					TWEEN_IMAGE_START[1].YS = 11;
					TWEEN_IMAGE_START[1].XE = 21;
					TWEEN_IMAGE_START[1].YE = 21;
					TWEEN_IMAGE_START[1].HUE = 85;
					TWEEN_IMAGE_START[1].DATA1 = 5;   // peaks 
					TWEEN_IMAGE_START[1].DATA2 = 3;   // amplitude
					TWEEN_IMAGE_START[1].DATA3 = 45;  // spike color

					TWEEN_IMAGE_END[1].IMAGE_KIND = 1;  //line
					TWEEN_IMAGE_END[1].XS = 0;  //0
					TWEEN_IMAGE_END[1].YS = 11;  //21
					TWEEN_IMAGE_END[1].XE = 21;  //21
					TWEEN_IMAGE_END[1].YE = 0;  //1
					TWEEN_IMAGE_END[1].HUE = 0;
					TWEEN_IMAGE_END[1].DATA1 = 5;   // peaks  // not used
					TWEEN_IMAGE_END[1].DATA2 = 6;  // amplitude  // not used
					TWEEN_IMAGE_END[1].DATA3 = 45;  // spike color yello

					//////////////////////


					// make copy of original...note TWEEN...[9] and ...[8]   not used

					TWEEN_IMAGE_START[8] = TWEEN_IMAGE_START[0];   // circle beginning
					TWEEN_IMAGE_START[9] = TWEEN_IMAGE_START[1];   // line beginning
				}



				if (bounce == 10)  // extend tween 1 
				{
					TWEEN_IMAGE_START[1] = TWEEN_IMAGE_END[1];   // start extension where TWEEN ended

					TWEEN_IMAGE_END[1].IMAGE_KIND = 1;  //line
					TWEEN_IMAGE_END[1].XS = 11;  //0
					TWEEN_IMAGE_END[1].YS = 0;  //21
					TWEEN_IMAGE_END[1].XE = 11;  //21
					TWEEN_IMAGE_END[1].YE = 21;  //1
					TWEEN_IMAGE_END[1].HUE = 0;
					TWEEN_IMAGE_END[1].DATA1 = 5;   // peaks  // not used
					TWEEN_IMAGE_END[1].DATA2 = 6;  // amplitude  // not used
					TWEEN_IMAGE_END[1].DATA3 = 45;  // spike color yello

					////////////////////////////////////////////////

					TWEEN_IMAGE_START[0] = TWEEN_IMAGE_END[0];

					TWEEN_IMAGE_END[0] = TWEEN_IMAGE_START[8];


				}

				if (bounce == 20)
				{
					TWEEN_IMAGE_START[1] = TWEEN_IMAGE_END[1];
					TWEEN_IMAGE_END[1] = TWEEN_IMAGE_START[9];  // previously copied, saved = original TWEEN_IMAGE_END[1]

				}

				TWEEN(0, 2, 10, bounce % 10, 42, direction);  ///// TWEEN   ////////////////////////////

				DIM_SLOW_LEDS(G_dim);  // dim SLOW leds
				SAVE_TO_BUFFER(2);  // save generated display to buffer2


				//////////////*************************** now generate IMPRINT  ****************************** //////////////////////////////////////
				//////////////*************************** now generate IMPRINT  ****************************** //////////////////////////////////////
				//////////////*************************** now generate IMPRINT  ****************************** //////////////////////////////////////


			//	printD("reset_imprint_show ="), reset_imprint_show);




				/// INITIALIZATION of IMPRINT_SHOW
				byte imp_show = 8;
				byte num_instances = 4;  //8
				byte fill_depth = 1;  //0
				int hue_start = 0;
				int hue_end = 0;
				byte total_cycles = 5; //10
				byte delta_per_cycle = 3;  //3, each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines how far each instance of the shape moves per cycle
				byte distance_between_instances = 4; // each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines the distance between repeats of the shape
				float brightness_percentage = 100;

				static byte reset_imprint_show = 1;

				////////////********************************
				byte imp = 1;   // TEST ONLY to fix the imprint being used, otherwise they will cycle through all imprint types
				////////////********************************


				////////////********************************
				//dimming = dimming + 20;  // change dimming each loop , dimming is global
				byte dimming = 1;  // TEST only

				////////////********************************




				////////////////////////////////*********  IMPRINT_SHOW ********* /////////////////////////////////////

				if (reset_imprint_show == 1)
				{

					FastLED.clear();
				}

				reset_imprint_show = IMPRINT_SHOW(imp_show, hue_start, hue_end, total_cycles, delta_per_cycle, num_instances, distance_between_instances, fill_depth, brightness_percentage, reset_imprint_show);

				//reset = 0;

				//IMPRINT_SHOW(1, 0);

				///////////// for viewing IMPRINT alone  ///////////////////////////////////////


				//if (IMPRINT_ONLY == 1) // allow for showing the IMPRINT
				//{
				//	FastLED_clear();
				//	LOAD_FROM_BUFFER(1); // where imprint is stored

				//	//SHOW_slow(window);
				//	FastLED_show(window);  // no dimming
				//	delay(1000);

				//}

				///////////////////////////////////////////////////////////////////////////



				//if (IMPRINT_ONLY == 0)  // SKIP for now, use IMPRINT
				{
					//SAVE_TO_BUFFER(1);

					//G_dim = 0;
					//G_dim_shape = 0;

					//FastLED_clear();

					//////////////////////////////////////////////////////////////////////////





					/////////////////  NOW IMPRINT the BUFFER onto the IMAGE /////////////////////////
					// method =1: hue the imprint screen replaces hue of active screen pixels: IHUE
					// method =2: XOR the buffer onto  the active screen pixels: IXOR
					// method =3: AND the buffer and  the active screen pixels, leave buffer pixles: IAND_BUFFER  (i.e. leave the overlap buffer region with the buffer color)
					// method =4: AND the buffer and  the active screen pixels, leave screen pixles: IAND_SCREEN (i.e. leave the overlap buffer region with the screen pixles color)
					// method =5  AND the buffer and the active screen pixels, EXCLUDE the AND'd region from the active screen pixels (i.e. cut out the buffer region)

					//imp = 1;  // for test

					LOAD_FROM_BUFFER(2);  // stored image

					printD("IMPRINT kind:  imp="), imp);

					IMPRINT(imp);

					//++imp;  // global at level of main

					if (imp > 5)
					{
						imp = 1;
					}

					//////////////////////////////////////////////////////////////////////////////////

					//FastLED_show(window);

					//SHOW_slow(window);
					FastLED.show();  // no dimming
					BT_DELAY(100);

					//LINE(1, 10, 20, 10, 0);


					//int adr = XY_ADR(10, 10);
					//leds1[adr] = CHSV(0, 255, 255);  // 


					//leds1[0].r = 255;
				}
			}
		
	}

	/////////////////////////////////////////////////////////////

	if (show_num == 20)   //HUE IMPRINT show 2 =  //HUE IMPRINT show 1 = TEST 10 in MURGETROID_PC
	{

		Serial.println(F("++++++PROD2: show 20 : start"));

		/////used for IMPRINT_SHOW function  /////
		byte IMPRINT_ONLY = 0;  // set to 1 to only show IMPRINT,   set to  0 to only show IMPRINT and IMAGE

		byte imp = 1; // type of imprint to use
		byte imp_show = 8;  // defines which IMPRINT_SHOW to execute
		int hue_start = 0;  // sets the starting hue of the hue imprint
		int hue_end = 0;  // sets the ending hue of the hue imprint
		byte total_cycles = 10; // sets the duration of HUE cycling of a given show, hue transitions from hue_start to hue_end during this cycle
		byte delta_per_cycle = 3;  // each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines how far each instance of the shape moves per cycle
		byte num_instances = 8;  // number of instances of the shape used to hue imprint
		byte distance_between_instances = 4; // each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines the distance between repeats of the shape
		byte fill_depth = 1; // number of lines filled when using FILL_HOZ or FILL_VERT function in some of the shows, 0=1 line
		static byte reset_imprint_show = 0; // set to 1 to restore a given IMPRINT_SHOW back to cycle=0;
		int brightness_percentage = 100; // This is the percentage dimmer or brighter the IMPRINT will be relative to the current display brightness, 100=current brightness
		byte tween_kind = 4; 

		byte bounce_cycles = 40;

		static byte initizlize_once_flag = 1;  // will be set to 0 after initialization 

		if (IMPRINT_ONLY == 0)  // SKIP for now, use IMPRINT
		{
			
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////********************************* 1st generate IMAGE to use imprint on ************************************ /////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			FastLED.clear();
			//FastLED.show();

	// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
	// 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes


			TWEEN_IMAGE_START[0].IMAGE_KIND = tween_kind;  // line
			TWEEN_IMAGE_START[0].XS = 0;  // center
			TWEEN_IMAGE_START[0].YS = 11;
			TWEEN_IMAGE_START[0].XE = 0;   // radius
			TWEEN_IMAGE_START[0].YE = 21;
			TWEEN_IMAGE_START[0].HUE = 85;
			TWEEN_IMAGE_START[0].DATA1 = 1;   // not used
			TWEEN_IMAGE_START[0].DATA2 = 2;  // not used
			TWEEN_IMAGE_START[0].DATA3 = 0;  // not used


			TWEEN_IMAGE_END[0].IMAGE_KIND = tween_kind;  //line
			TWEEN_IMAGE_END[0].XS = 0;
			TWEEN_IMAGE_END[0].YS = 11;  // 10
			TWEEN_IMAGE_END[0].XE = 21; // radius
			TWEEN_IMAGE_END[0].YE = 21;
			TWEEN_IMAGE_END[0].HUE = 171;
			TWEEN_IMAGE_END[0].DATA1 = 3;   // not used
			TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude
			TWEEN_IMAGE_END[0].DATA3 = 0;  // amplitude

			////////////////


			TWEEN_IMAGE_START[1].IMAGE_KIND = tween_kind;  //line
			TWEEN_IMAGE_START[1].XS = 0;
			TWEEN_IMAGE_START[1].YS = 10;
			TWEEN_IMAGE_START[1].XE = 0;
			TWEEN_IMAGE_START[1].YE = 0;
			TWEEN_IMAGE_START[1].HUE = 171;
			TWEEN_IMAGE_START[1].DATA1 = 0;
			TWEEN_IMAGE_START[1].DATA2 = 0;
			TWEEN_IMAGE_START[1].DATA3 = 0;

			TWEEN_IMAGE_END[1].IMAGE_KIND = tween_kind;  //line
			TWEEN_IMAGE_END[1].XS = 0;  //0
			TWEEN_IMAGE_END[1].YS = 10;  //21
			TWEEN_IMAGE_END[1].XE = 21;  //21
			TWEEN_IMAGE_END[1].YE = 0;  //1
			TWEEN_IMAGE_END[1].HUE = 0;
			TWEEN_IMAGE_END[1].DATA1 = 0;   // peaks  // not used
			TWEEN_IMAGE_END[1].DATA2 = 0;  // amplitude  // not used
			TWEEN_IMAGE_END[1].DATA3 = 0;  // spike color yello

			//////////////////////

			TWEEN_IMAGE_START[2].IMAGE_KIND = tween_kind;  //line
			TWEEN_IMAGE_START[2].XS = 0;
			TWEEN_IMAGE_START[2].YS = 11;
			TWEEN_IMAGE_START[2].XE = 21;
			TWEEN_IMAGE_START[2].YE = 11;
			TWEEN_IMAGE_START[2].HUE = 171;
			TWEEN_IMAGE_START[2].DATA1 = 0;
			TWEEN_IMAGE_START[2].DATA2 = 0;
			TWEEN_IMAGE_START[2].DATA3 = 0;


			TWEEN_IMAGE_END[2].IMAGE_KIND = tween_kind;  //line
			TWEEN_IMAGE_END[2].XS = 0;  //0
			TWEEN_IMAGE_END[2].YS = 11;  //21
			TWEEN_IMAGE_END[2].XE = 0;  //21
			TWEEN_IMAGE_END[2].YE = 11;  //1
			TWEEN_IMAGE_END[2].HUE = 0;
			TWEEN_IMAGE_END[2].DATA1 = 0;   // peaks  // not used
			TWEEN_IMAGE_END[2].DATA2 = 0;  // amplitude  // not used
			TWEEN_IMAGE_END[2].DATA3 = 0;  // spike color yellow  // not used

			////////////////////////////

			TWEEN_IMAGE_START[3].IMAGE_KIND = tween_kind;  //line
			TWEEN_IMAGE_START[3].XS = 0;
			TWEEN_IMAGE_START[3].YS = 10;
			TWEEN_IMAGE_START[3].XE = 21;
			TWEEN_IMAGE_START[3].YE = 10;
			TWEEN_IMAGE_START[3].HUE = 171;
			TWEEN_IMAGE_START[3].DATA1 = 0;
			TWEEN_IMAGE_START[3].DATA2 = 0;
			TWEEN_IMAGE_START[3].DATA3 = 0;


			TWEEN_IMAGE_END[3].IMAGE_KIND = tween_kind;  //line
			TWEEN_IMAGE_END[3].XS = 0;  //0
			TWEEN_IMAGE_END[3].YS = 10;  //21
			TWEEN_IMAGE_END[3].XE = 0;  //21
			TWEEN_IMAGE_END[3].YE = 10;  //1
			TWEEN_IMAGE_END[3].HUE = 0;
			TWEEN_IMAGE_END[3].DATA1 = 0;   // peaks  // not used
			TWEEN_IMAGE_END[3].DATA2 = 0;  // amplitude  // not used
			TWEEN_IMAGE_END[3].DATA3 = 0;  // spike color yellow  // not used

			/////////////////////////

		
		}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////// NOW generate IMPRINT_SHOW  //////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// note: if VALUES[0]==1 then REPORT VALUES[#] to serial monitor
		//VALUES = {0, imp_show, hue_start, hue_end, total_cycles, delta_per_cycle, num_instances, distance_between_instances, fill_depth, brightness_percentage, reset_imprint_show, imp  };

		// *********  IMPRINT methods: V11  *************
// method =1: hue the imprint screen replaces hue of active screen pixels: IHUE
// method =2: XOR the buffer onto  the active screen pixels: IXOR
// method =3: AND the buffer and  the active screen pixels, leave buffer pixles: IAND_BUFFER  (i.e. leave the overlap buffer region with the buffer color)
// method =4: AND the buffer and  the active screen pixels, leave screen pixles: IAND_SCREEN (i.e. leave the overlap buffer region with the screen pixles color)
// method =5  AND the buffer and the active screen pixels, EXCLUDE the AND'd region from the active screen pixels (i.e. cut out the buffer region)


		// ********* IMPRINT SHOWS: V1 *****************
//if (imp_show == 1)  // verticle moving HOZ fill lines
//if (imp_show == 2)  // horizontal moving VERT fill lines
//if (imp_show == 3)  // stationary checker board
//if (imp_show == 4)  // vertical HUE gradient
//if (imp_show == 5)  // horizontal HUE gradient
//if (imp_show== 6)  //MIDDLE vertical HUE gradient
//if (imp_show == 7)  // UP and down trianle , hue varies with cycle : DON-->>need to add the changine HUE with cycle


		if (initizlize_once_flag == 1)
		{
			initizlize_once_flag = 0;

			VALUES[1] = imp_show;
			VALUES[2] = hue_start;
			VALUES[3] = hue_end;
			VALUES[4] = total_cycles;
			VALUES[5] = delta_per_cycle;
			VALUES[6] = num_instances;
			VALUES[7] = distance_between_instances;
			VALUES[8] = fill_depth;
			VALUES[9] = brightness_percentage;
			VALUES[10] = reset_imprint_show;

			VALUES[11] = imp;
			VALUES[12] = IMPRINT_ONLY;
		}
		else  // use previously initialized values
		{

			imp_show = VALUES[1];
			hue_start = VALUES[2];
			hue_end = VALUES[3];
			total_cycles = VALUES[4];
			delta_per_cycle = VALUES[5];
			num_instances = VALUES[6];
			distance_between_instances = VALUES[7];
			fill_depth = VALUES[8];
			brightness_percentage = VALUES[9];
			reset_imprint_show = VALUES[10];

			imp = VALUES[11];
			IMPRINT_ONLY = VALUES[12];

		}


		//int VALUES[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

		//IMPRINT_SHOW(byte imp, int hue_start, int hue_end, byte total_cycles, byte DELTA_PER_CYCLE, byte NUMBER_OF_INSTANCES, byte DISTANCE_BETWEEN_INSTANCES, byte FILL_DEPTH, float brightness_percentage, byte reset)
		//IMPRINT_SHOW(imp_show, hue_start, hue_end, total_cycles, delta_per_cycle, num_instances, distance_between_instances, fill_depth, dimming_imp,  reset_imprint_show);

		//byte hue_start_array[5] = { 0, 42,85,171,255 };
		//byte hue_end_array[5] = { 255, 128, 171 ,213 ,0 };
		//byte hue_index = 0;

		///////////////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////  BOUNCE  IMPRINTS /////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////
		//HALL_SYNC2();

		int direction = 1; 
		
		for (byte bounce = 0; bounce < bounce_cycles; ++bounce)  // number of times to execute show
		{
			//printD("P2S19: bounce="), bounce);
			//SPACE

			if (bounce % 11 == 0)
			{
				direction = -1 * direction;
			}

			FastLED.clear();
			//////////////////////////////////// TWEEN  ////////////////////////////////
			TWEEN(0, 3, 11, bounce%11, 171, direction);

			DIM_SLOW_LEDS(G_dim);  // dim SLOW leds
			SAVE_TO_BUFFER(2);  // save generated display to buffer2

			GET_VALUES();  // read the Serial Monitor for new values of VALUES[] array

			//// CHANGE HUE every 10th bounce
			//if (0 == bounce % 10)
			//{
			//	VALUES[2] = hue_start_array[hue_index];   // hue_start
			//	VALUES[3] = hue_end_array[hue_index];    // hue_end

			//	++hue_index;
			//	if (hue_index >= 5) { hue_index = 0; }

			//	reset_imprint_show = 1; 
			//}

			//// modify imprint_show
			//if (0 == bounce % 2)  
			//{
			//	VALUES[1] = 4;  // imprint_show...vertical hue
			//}
			//else
			//{
			//	VALUES[1] = 5;  // hoz hue
			//}

			if (G_interceeded_flag == 1)  // next show forced so exit
			{
				break;
			}




			/// INITIALIZATION of IMPRINT_SHOW
			//imp_show = 6;
			//num_instances = 8;  //8
			//distance_between_instances = 3;
			//fill_depth = 1;  //0
			//hue_start = 0;
			//hue_end = 255;
			//total_cycles = 10; //10
			//delta_per_cycle = 3;  //3, each IMPRINT_SHOW utilizes a shape (ex. a line, or FILL_HOZ), this defines how far each instance of the shape moves per cycle


			////////////********************************
			//imp = 1;   // TEST ONLY to fix the imprint being used, otherwise they will cycle through all imprint types
			////////////********************************


			////////////********************************
			//brightness_percentage = brightness_percentage + 20;  // change brightness of IMPRINT from 50% to 150% of the present display brightness

			//if (brightness_percentage > 150) { brightness_percentage = 50; }

			//brightness_percentage = 100;  // set imprint brightness the same as image brightness

			////////////********************************


			///////////// TEST ONLY  ///////////////
			//G_dim = 250;
			//brightness_percentage = 500;

			/////////////////////////////////////////


			////////////////////////////////*********  IMPRINT_SHOW ********* /////////////////////////////////////

			//VALUES[1] = (bounce % 7) + 1;  //modify imp_show 7 possible values



			if (VALUES[0] == 1)  // REPORT
			{

				// report imprint values
				REPORT_VALUES();

				VALUES[0] = 0;  // only update once
			}

			imp_show = VALUES[1];
			hue_start = VALUES[2];
			hue_end = VALUES[3];
			total_cycles = VALUES[4];
			delta_per_cycle = VALUES[5];
			num_instances = VALUES[6];
			distance_between_instances = VALUES[7];
			fill_depth = VALUES[8];
			brightness_percentage = VALUES[9];
			reset_imprint_show = VALUES[10];

			imp = VALUES[11];

			//SPACE
			//printD("hue_start= "), hue_start );
			//printD("hue_end= "), hue_end );
			//SPACE


			//%%%%%%%%%%%%%%%%%%%%%%%%%%%  IMPRINT_SHOW %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			// note: IMPRINT is saved to BUFFER1
			reset_imprint_show = IMPRINT_SHOW(imp_show, hue_start, hue_end, total_cycles, delta_per_cycle, num_instances, distance_between_instances, fill_depth, brightness_percentage, reset_imprint_show);
			//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


			//reset = 0;

			//IMPRINT_SHOW(1, 0);

			///////////// for viewing IMPRINT alone  ///////////////////////////////////////


			if (IMPRINT_ONLY == 1) // allow for showing the IMPRINT
			{

				FastLED.clear();
				LOAD_FROM_BUFFER(1); // where imprint is stored
				
				//SHOW_slow(window);
				FastLED.show();  // no dimming
				delay(1000);

			}

			///////////////////////////////////////////////////////////////////////////

#define DELAY_SEPERATION 30

			if (IMPRINT_ONLY == 0) // allow for showing the IMPRINT
			{

				LOAD_FROM_BUFFER(2);  // load back non-imprinted display
				//DIM_SLOW_LEDS(G_dim);  // dim SLOW leds

				IMPRINT(imp);

				FastLED.show();  // no dimming
				//delay(DELAY_SEPERATION);

				//FastLED.clear();
				//FastLED.show();  // no dimming
				//delay(2*DELAY_SEPERATION);

				//LOAD_FROM_BUFFER(2); // where main image is stored

				//FastLED.show();  // no dimming
				//delay(DELAY_SEPERATION);
				//
				//// final image is cleared
				//FastLED.clear();
				//FastLED.show();  // no dimming
				//delay(2*DELAY_SEPERATION);

				//++imp;  // global at level of main

				//if (imp > 5)
				//{
				//	imp = 1;
				//}

				VALUES[11] = imp;


			}
			
		}


	}


	/////////////////////////////////////////  end of PRODUCTION_2 shows  /////////////////////////////////////////////////////////////

	Serial.println(F("$$$$$$$  END of PRODUCTION 2 $$$$$$$$$$$"));
	Serial.print(F("G_force_production_end="));
	Serial.println(G_force_production_end);
	Serial.println("");


	if ((show_num == NUMBER_OF_PRODUCTION2_SHOWS) || (G_force_production_end == 1))
	{
		G_force_production_end = 0;
		//G_show_num = 1;
		G_show_num = 0;  // changed on 4/9/24 to allow repeat of show #1
		return 1;  // flag that production is complete
	}
	else
	{
		return 0;
	}


}


/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
byte PRODUCTION_3()   //////////// sound FFT work 
// return 1 when PRODUCTION is complete
{
	
	Serial.println(F("$$$$$$$$$$$$$$$$$$$$$$$$$$$$ START of PRODUCTION_3"));
	Serial.println("");

#define NUMBER_OF_PRODUCTION3_SHOWS 9  // 
#define SHOW_LOOPS_PRODUCTION3 60  // loops for each show

	//G_dim = 252;  // for debug only with hood off

	// note: width of each bin = sample rate/number of samples


	//int number_of_shows = 100;       // number of SHOWs
	int show_num = 0;

	int stringSize = 0;
	int hue = -1;  // white
	byte BT_interrupt = 0;



	//CLEAR_ALL_LEDS();
	//HALL_SYNC2();
	//SHOW_slow();


	if ((SERIAL_MON == 1) && ((G_DC_received_flag == 1) || (G_BT_message_flag == 1)))
	{
		//Serial.println("");
		//Serial.println(F("$$$$$$$$$$$$$$$$$$$$$$$$$$$$START of PRODUCTION_3"));
		//Serial.print(F("G_DC_received_flag= "));
		//Serial.println(G_DC_received_flag);
		//Serial.print(F("G_BT_message_flag= "));
		//Serial.println(G_BT_message_flag);
		//Serial.print(F("G_show_num= "));
		//Serial.println(G_show_num);
		//Serial.println("");


	}

	//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	if ((G_continuous_SPECIAL_mode == 0) && (G_continuous_SPECIAL_mode_was_ON == 1))
	{
		G_continuous_SPECIAL_mode_was_ON = 0;

		CLEAR_FAST_LEDS();

		SHOW_fast(1, 0);
	}


	// ********* old SHOW handler  

	//++G_show_num;
	//int rv=DC_RECEIVE_ARRAY();
	//int rv = 0;

	//G_show_num = 1;
	//DC_COMMAND_HANDLER();



	if (G_BT_message_flag == 0)
	{
		G_BT_message_flag = CHECK_BLUE_TOOTH();

		/*Serial.println("In DO_SHOW2 after CHECK_BLUE_TOOTH");
		Serial.print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= ");
		Serial.println(G_BT_message_flag);
		Serial.println("");*/
	}

	if ((G_BT_message_flag == 1) || (BT_interrupt == 1))
	{

		BT_interrupt = 0;  // clear

		//int stringSize = strlen(text_array);
		Serial.println(F("In DO_PRODUCTION_3 after CHECK_BLUE_TOOTH"));
		Serial.print(F("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= "));
		Serial.println(G_BT_message_flag);
		Serial.println("");
		Serial.print(F("G_message= "));
		Serial.println(G_message);
		//Serial.print("stringSize= ");
		//Serial.println(stringSize);
		Serial.print(F("G_BT_command= "));
		Serial.println(G_BT_command);
		Serial.println("");

		/*SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0, 0);
		G_BT_message_flag = 0;*/


		BLUE_TOOTH_COMMAND_HANDLER(1);  // execute the BT command  ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
		//DC_COMMAND_HANDLER();  // need this if the BT COMMAND HANDLER calls TRANSFER2_SLOW which will transfer back a DON_COM command
		delay(50);


	}

	if (G_continuous_SPECIAL_mode == 1)
	{
		G_show_num = 255;
	}

	//if ((G_show_num > number_of_shows) || (G_show_num == 1))
	//{
	//	if ((G_show_num != 255) && (G_show_num != 254))  // 255 is a flag to show BT text_array
	//	{
	//		G_show_num = 1;
	//		HALL_MEASURE3(22);  //find G_max_bins
	//	}

	//}



	/////////////////////////////  THE SHOWs ///////////////////////////

		// -------------->    get next show number  <--------------------------
	// NOTE: I need to keep the number of shows low to prevent delay in show handler



	show_num = SHOW_HANDLER(NUMBER_OF_PRODUCTION3_SHOWS);  ////// SHOW HANDLER  ///////////

	if (SERIAL_MON == 1)
	{
		Serial.println("");
		Serial.println(F("------> PRODUCTION_3 <------ "));
		Serial.print(F("******************************************* G_show_num= "));
		Serial.println(G_show_num);
		Serial.print(F("show_num= "));
		Serial.println(show_num);
		Serial.print(F("G_executing_CREATE_mode= "));
		Serial.println(G_executing_CREATE_mode);
		Serial.print(F("G_CREATE_mode= "));
		Serial.println(G_CREATE_mode);
		Serial.println("");
	}

	if (show_num == 0)   // CREATE mode
	{
		unsigned long present_system_time = millis();
		unsigned long delta_time = present_system_time - G_CREATE_MODE_start_time;

		//Serial.println("");
		//Serial.println(F("--------->  DO_SHOW:"));
		//Serial.print(F(" G_CREATE_MODE_start_time="));
		//Serial.println(G_CREATE_MODE_start_time);
		//Serial.print(F(" delta_time="));
		//Serial.println(delta_time);
		//Serial.print(F(" G_executing_CREATE_mode="));
		//Serial.println(G_executing_CREATE_mode);
		//Serial.print(F(" G_PLAY_SAVES_MODE_ON="));
		//Serial.println(G_PLAY_SAVES_MODE_ON);
		//Serial.println("");

		if (G_PLAY_SAVES_MODE_ON == 0) //  not PLAY SAVES
		{

			if (((delta_time) > MAXIMUM_IDLE_CREATE_MODE_TIME))  // EXIT CREATE MODE and execute SHOW
			{
				// NOTE: G_CREATE_MODE_start_time is set in the BT command handler every time a BT command is called
				G_BT_command = 'L'; // turn off CREATE MODE and turn on SHOW

				//Serial.println("");
				//Serial.println(F("--------->  before BT command to exit CREATE MODE:"));
				//Serial.println("");

				BLUE_TOOTH_COMMAND_HANDLER(1);
				return 1;
			}

		}

		CREATE_MODE();
		//Serial.println(F("DO_SHOW: before DUMP after CREATE_MODE(): show_num=0"));
		//DUMP_LED_ARRAY(leds1, NUM_LEDS);

	}

	//////  SHOW 255...show BT text
	if (G_show_num == 255)
	{
		SHOW_255();

		//HALL_MEASURE3(22);

		////stringSize = strlen(text_array);

		//stringSize=ADD_SPECIAL_TEXT();  // add special image Text characters to text_array

		////stringSize = strlen(text_array);  // new string size
		//
		//SCROLL_TEXT(text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0);
		//BT_and_DC_CHECKandDO();
	}

	if (G_show_num == 254)  // works in conjunction with DC command 11
		// display G_SAVED image 
	{
		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");

		int stringSize = strlen(scroll_text_array);

		//HALL_MEASURE3(22);  //find G_max_bins
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 2, 0);
		G_special_char_select = 1;
		BT_and_DC_CHECKandDO();

	}

	if (G_CREATE_mode == 0) // CREATE mode entered
	{
		//////// FFT setup ///////////////
		FastLED.clear();
	}

	//// Reset bandValues[]
	//for (int i = 0; i < NUM_BANDS; i++) {
	//	bandValues[i] = 0;
	//}

	//// Sample the audio pin
	//for (int i = 0; i < SAMPLES; i++) {
	//	newTime = micros();
	//	vReal[i] = analogRead(AUDIO_IN_PIN); // A conversion takes about 9.7uS on an ESP32
	//	vImag[i] = 0;
	//	while (micros() < (newTime + sampling_period_us)) { /* chill */ }
	//}




	////////////////////////////////////////
	if (show_num == 1)  // FFT  white bars at top
	{
		Serial.println(F("------------------------->P3: show1"));

		for (int loop = 0; loop < SHOW_LOOPS_PRODUCTION3; ++loop)
		{

			FastLED.clear();
			FFT_COMPUTE(); ////sample analog input and  Compute FFT
			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 

			// Process the FFT data into bar heights
			//for (byte band = 0; band < NUM_BANDS; band++) 
			for (byte band = 0; band < G_COMB_bandValues; band++)
			{

				// Scale the bars for the display
				//int barHeight = bandValues[band] / AMPLITUDE;
				int barHeight = COMB_bandValues[band] / AMPLITUDE;
				if (barHeight > TOP) barHeight = TOP;

				// Small amount of averaging between frames
				barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;

				// Move peak up
				if (barHeight > peak[band]) {
					peak[band] = min(TOP, barHeight);
				}

				rainbowBars(band, barHeight);
				whitePeak(band);

				// Save oldBarHeights for averaging later
				oldBarHeights[band] = barHeight;
			}


			// Decay peak
			EVERY_N_MILLISECONDS(60) {
				for (byte band = 0; band < NUM_BANDS; band++)
					if (peak[band] > 0) peak[band] -= 1;
				colorTimer++;
			}

			// Used in some of the patterns
			EVERY_N_MILLISECONDS(10) {
				colorTimer++;
			}


			BT_interrupt = SHOW_slow();

			if (BT_interrupt > 0) { break; }  // leave while loop
		}

	}

	///////////////////////////////////////////////////////////
	if (show_num == 2)  // FFT, white bars at top purple bars
	{
		int show_loops = SHOW_LOOPS_PRODUCTION3;

		Serial.println(F("------------------------->P3: show2"));

		for (int loop = 0; loop < show_loops; ++loop)
		{
			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT
			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 


			if (SERIAL_MON == 2)
			{
				for (int n = 0; n < 11; ++n)
				{
					//COMB_bandValues[index] += bandValues[k];

					Serial.print(F("COMB_bandValues["));
					Serial.print(n);
					Serial.print(F("]="));
					Serial.println(COMB_bandValues[n]);

				}
				Serial.println("");
			}

			FastLED.clear();

			// Process the FFT data into bar heights
			//for (byte band = 0; band < NUM_BANDS; band++)
			for (byte band = 0; band < G_COMB_bandValues; band++)
			{

				// Scale the bars for the display
				//int barHeight = bandValues[band] / AMPLITUDE;
				int barHeight = COMB_bandValues[band] / AMPLITUDE;

				//if (barHeight > 5)
				//{
				//	Serial.print(F("band="));
				//	Serial.print(band);
				//	Serial.print(F("     barHeight="));
				//	Serial.println(barHeight);
				//}


				if (barHeight > TOP) barHeight = TOP;

				int hue = int((255 * band) / G_COMB_bandValues);

				////////////  new code ////////////////
				//LINE(0, band, barHeight, band, hue);

				purpleBars(band, barHeight);

				peak[band] = barHeight;
				whitePeak(band);

				///////////////////////////////////////



				// //Small amount of averaging between frames
				//barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;
				//
				//// Move peak up
				//if (barHeight > peak[band]) {
				//	peak[band] = min(TOP, barHeight);
				//}
				//peak[band] = barHeight;


				//rainbowPeak(band);

				//// Save oldBarHeights for averaging later
				//oldBarHeights[band] = barHeight;
			}


			//// Process the FFT data into bar heights
			////for (byte band = 0; band < NUM_BANDS; band++) 
			//for (byte band = 0; band < G_COMB_bandValues; band++)
			//{

			//	// Scale the bars for the display
			//	//int barHeight = bandValues[band] / AMPLITUDE;
			//	int barHeight = COMB_bandValues[band] / AMPLITUDE;
			//	if (barHeight > TOP) barHeight = TOP;

			//	// Small amount of averaging between frames
			//	barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;

			//	// Move peak up
			//	if (barHeight > peak[band]) {
			//		peak[band] = min(TOP, barHeight);
			//	}


			//	purpleBars(band, barHeight);
			//	//whitePeak(band);


			//	// Save oldBarHeights for averaging later
			//	oldBarHeights[band] = barHeight;
			//}

			////Serial.println(F("------------------------->P3: here 2"));

			//// Decay peak
			//EVERY_N_MILLISECONDS(60) {
			//	for (byte band = 0; band < NUM_BANDS; band++)
			//		if (peak[band] > 0) peak[band] -= 1;
			//	colorTimer++;
			//}

			////Serial.println(F("------------------------->P3: here 3"));

			//// Used in some of the patterns
			//EVERY_N_MILLISECONDS(10) {
			//	colorTimer++;
			//}

			//Serial.println(F("------------------------->P3: here 4"));

			BT_interrupt = SHOW_slow();

			if (BT_interrupt > 0) { break; }  // leave while loop

			//Serial.println(F("------------------------->P3: here 5"));
		}
	}


	///////////////////////////////////////////////////////////
	if (show_num == 3)  // FFT
	{
		int show_loops = SHOW_LOOPS_PRODUCTION3;

		Serial.println(F(" ^^^  PRODUCTION 3: show 3 :  start"));
		Serial.println("");

		for (int loop = 0; loop < show_loops; ++loop)
		{
			//beat = BEAT_DETECT(200); // 200 was determined by turning off sound and looking at the adjusted peak threshold
			
			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT
			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 

			//Serial.println(F(" P3S3: after FFT"));

			//if (SOUND_DETECT2(SOUND_DETECT_THRESHOLD-5, 1) == 1)
			//{
			//	byte detected_note = 0;

			//	detected_note = NOTE_DETECT();

			//		Serial.print(F("*****------->>>>   detected NOTE="));
			//		Serial.println(detected_note);
			//		Serial.println(F(""));
			//}

				//for (int n = 0; n < 21; ++n)
				//{
				//	//COMB_bandValues[index] += bandValues[k];

				//	Serial.print(F("COMB_bandValues["));
				//	Serial.print(n);
				//	Serial.print(F("]="));
				//	Serial.println(COMB_bandValues[n]);

				//}
				//Serial.println("");


		//	Serial.println("");

			FastLED.clear();

			// Process the FFT data into bar heights
			//for (byte band = 0; band < NUM_BANDS; band++)
			for (byte band = 0; band < G_COMB_bandValues; band++)
			{

				// Scale the bars for the display
				//int barHeight = bandValues[band] / AMPLITUDE;
				int barHeight = COMB_bandValues[band] / AMPLITUDE;

				//if (barHeight > 5)
				//{
				//	Serial.print(F("band="));
				//	Serial.print(band);
				//	Serial.print(F("     barHeight="));
				//	Serial.println(barHeight);
				//}


				if (barHeight > TOP) barHeight = TOP;

				int hue = int((255 * band) / G_COMB_bandValues) ;

				////////////  new code ////////////////
				LINE(0, band, barHeight, band, hue);




				///////////////////////////////////////



				// //Small amount of averaging between frames
				//barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;
				//
				//// Move peak up
				//if (barHeight > peak[band]) {
				//	peak[band] = min(TOP, barHeight);
				//}
				//peak[band] = barHeight;


				//rainbowPeak(band);

				//// Save oldBarHeights for averaging later
				//oldBarHeights[band] = barHeight;
			}

			//// Decay peak
			//EVERY_N_MILLISECONDS(60) {    // was 60
			//	for (byte band = 0; band < NUM_BANDS; band++)
			//		if (peak[band] > 0) peak[band] -= 2;
			//	colorTimer++;
			//}

			//// Used in some of the patterns
			//EVERY_N_MILLISECONDS(10) {
			//	colorTimer++;
			//}


			BT_interrupt = SHOW_slow();

			//Serial.print(F(" ++++++++  PRODUCTION 3: show 3:  BT_interrupt="));
			//Serial.println(BT_interrupt);
			//Serial.println("");

			if (BT_interrupt > 0) { break; }  // leave for loop
		}
	}

	///////////////////////////////////////////////////////////
	if (show_num == 4)  // FFT
	{
		int show_loops = SHOW_LOOPS_PRODUCTION3;

		for (int loop = 0; loop < show_loops; ++loop)
		{
			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT
			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 

			FastLED.clear();

			// Process the FFT data into bar heights
			//for (byte band = 0; band < NUM_BANDS; band++) 
			for (byte band = 0; band < G_COMB_bandValues; band++)
			{

				// Scale the bars for the display
				//int barHeight = bandValues[band] / AMPLITUDE;
				int barHeight = COMB_bandValues[band] / AMPLITUDE;
				if (barHeight > TOP) barHeight = TOP;

				// Small amount of averaging between frames
				barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;

				// Move peak up
				if (barHeight > peak[band]) {
					peak[band] = min(TOP, barHeight);
				}


				changingBars(band, barHeight);



				// Save oldBarHeights for averaging later
				oldBarHeights[band] = barHeight;
			}


			// Decay peak
			EVERY_N_MILLISECONDS(60) {
				for (byte band = 0; band < NUM_BANDS; band++)
					if (peak[band] > 0) peak[band] -= 1;
				colorTimer++;
			}

			// Used in some of the patterns
			EVERY_N_MILLISECONDS(10) {
				colorTimer++;
			}

			BT_interrupt = SHOW_slow();

			if (BT_interrupt > 0) { break; }  // leave while loop


		}
	}


	///////////////////////////////////////////////////////////
	if (show_num == 5)  // FFT  Don with dynamic lines
	{
		int show_loops = SHOW_LOOPS_PRODUCTION3;
		int adr;
		int adr2;
		int hue = 0;
		byte hue_index = 0;

		for (int loop = 0; loop < show_loops; ++loop)
		{
			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT
			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 

			FastLED.clear();


			// Process the FFT data into bar heights
			//for (byte band = 0; band < NUM_BANDS; band++) 
			for (byte band = 0; band < G_COMB_bandValues; band++)
			{

				// Scale the bars for the display
				//int barHeight = bandValues[band] / AMPLITUDE;
				int barHeight = COMB_bandValues[band] / AMPLITUDE;
				if (barHeight > TOP) barHeight = TOP;

				// Small amount of averaging between frames
				barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;

				// Move peak up
				if (barHeight > peak[band]) {
					peak[band] = min(TOP, barHeight);
				}

				////////// draw disks  ////////////////
				++hue_index;
				if (hue_index > MAX_HUES) { hue_index = 1; }


				adr = XY_ADR(barHeight, 21 - band);
				hue = hues[hue_index];

				leds1[adr] = CHSV(hue, 255, 255);
				leds3[adr] = CHSV(hue, 255, 255);

				adr2 = modify_adr(0, 0, adr);

				leds2[adr2] = CHSV(hue, 255, 255);
				leds4[adr2] = CHSV(hue, 255, 255);
				///////////////////////////////////


				BT_interrupt = DYNAMIC_LINES(band, barHeight);  // don


				if (BT_interrupt > 0) { break; }  // leave while loop

				// Save oldBarHeights for averaging later
				oldBarHeights[band] = barHeight;
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////
	if (show_num == 6)  // FFT lines between bins ... bins 21 to 11 are connected to bins 10 to 0 with lines:  y=bin ; x=bar height; color = based on magnitude
	{

#define LOOP_COUNTS_PER_ACT  30  // number of times to execute an ACT within show_loops
#define NUMBER_OF_ACTS 5  // number of switch_case statements 

		int show_loops = LOOP_COUNTS_PER_ACT * NUMBER_OF_ACTS;

		byte xs;  // starting x
		byte ys; //  starting y
		byte xe;  // ending x
		byte ye;  // ending y
		int hue_index;  // hue for line
		double radius;
		byte act_index = 0; //points to present ACT in switch case




		for (int loop = 0; loop < show_loops; ++loop)
		{

			if (loop % LOOP_COUNTS_PER_ACT == 0)
			{
				++act_index;
				if (act_index >= NUMBER_OF_ACTS) { act_index = 0; }
			}

			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT
			BAND(G_COMB_bandValues);  // combine frequencies into BANDs 

			FastLED.clear();

			// Process the FFT data into bar heights
			//for (byte band = 0; band < NUM_BANDS; band++) 
			for (byte band = 0; band < G_COMB_bandValues / 2; band++)
			{

				// Scale the bars for the display

				int barHeight = COMB_bandValues[band] / AMPLITUDE;
				if (barHeight > TOP) barHeight = TOP;

				// Small amount of averaging between frames
				barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;

				ys = band;
				xs = barHeight;

				int barHeight2 = COMB_bandValues[band + 11] / AMPLITUDE;
				if (barHeight2 > TOP) barHeight2 = TOP;

				// Small amount of averaging between frames
				barHeight2 = ((oldBarHeights[band + 11] * 1) + barHeight2) / 2;

				ye = band + 11;
				xe = barHeight2;


				// Move peak up
				if (barHeight2 > peak[band + 11]) {
					peak[band + 11] = min(TOP, barHeight2);
				}

				hue_index = (2 + barHeight + barHeight2) / 4;  // there are 12 hues, barHeight and barHeight2 can max out at 21 --> 2+21+21 = 44 --> 44/4 = 11 

				radius = (barHeight + barHeight2) / 2;


				// ********  acts  **********************

				switch (act_index) {
				case 0:
					CIRCLE(radius, xe, ye, hues[11 - hue_index]);  //good
					CIRCLE(radius, xs, ys, hues[hue_index]);  //good
					break;
				case 1:
					TRIANGLE(xs, ys, xe, ye, hues[11 - hue_index]);  // good
					break;
				case 2:
					LINE(ys, xs, ye, xe, hues[11 - hue_index]);  // good
					break;
				case 3:
					LINE(xs, ys, xe, ye, hues[hue_index]);  // good
					break;
				case 4:
					LINE(xs, ys, ye, xe, hues[hue_index]);  // good
					break;
				default:

					break;
				}







				//RECTANGLE(xs, ys, xe, ye, hues[11 - hue_index]);  //too busy

				//LINE(ys, xs, ye, xe, hues[11 - hue_index]);  // good
				//LINE(xs, ys, xe, ye, hues[11 - hue_index]);
				//changingBars(band, barHeight);

				//************************ end acts  ************

				// Save oldBarHeights for averaging later
				oldBarHeights[band] = barHeight;
				oldBarHeights[band + 11] = barHeight2;
			}


			//// Decay peak
			//EVERY_N_MILLISECONDS(60) {
			//	for (byte band = 0; band < NUM_BANDS; band++)
			//		if (peak[band] > 0) peak[band] -= 1;
			//	colorTimer++;
			//}

			//// Used in some of the patterns
			//EVERY_N_MILLISECONDS(10) {
			//	colorTimer++;
			//}

			BT_interrupt = SHOW_slow();

			if (BT_interrupt > 0) { break; }  // leave while loop


		}
	}


	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// cylindrical radial display
	// angle = band
	// radius = barheight
	// z = barheight
	if (show_num == 7)  // cylindrical coordinate show
	{
		Serial.println(F("*****------->>>>   P3S7 start"));
		Serial.println(F(""));
		
		//#define LOOP_COUNTS_PER_ACT  30  // number of times to execute an ACT within show_loops
		//#define NUMBER_OF_ACTS 5  // number of switch_case statements 
#define BANDS_FOR_THIS_SHOW 20  // number of frequency bands for this show

		int show_loops = 30;

		int saved_G_dim = G_dim;

		//byte xs;  // starting x
		//byte ys; //  starting y
		//byte xe;  // ending x
		//byte ye;  // ending y
		int hue_index;  // hue for line
		double radius;
		//byte act_index = 0; //points to present ACT in switch case

		//G_COMB_bandValues = 10;  // 10 bins

		int angle = 0;

		byte depth = 22;  // number of active columns
		//byte active_columns = 22;  // number of active columns
		int num_leds = depth * 22; // number of active LEDs



		byte blanks = 8; // number of flashes to ignore at the end to prevent over wrap, was 5
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command

		//radius, angle, z
		cylin[0] = { 0,180,11 };  // center of all radius

		blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes

		for (int loop = 0; loop < show_loops; ++loop)
		{



			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT
			BAND(BANDS_FOR_THIS_SHOW);  // combine frequencies into BANDs 

			FastLED.clear();

			// Process the FFT data into bar heights
			for (byte band = 0; band < BANDS_FOR_THIS_SHOW; band++)
				//for (byte band = 0; band < G_COMB_bandValues / 2; band++)
			{
				// Scale the bars for the display

				int barHeight = COMB_bandValues[band] / AMPLITUDE;
				if (barHeight > TOP) barHeight = TOP;

				//// Small amount of averaging between frames
				//barHeight = ((oldBarHeights[band] * 1) + barHeight) / 2;

				////ys = band;
				////xs = barHeight;

				//int barHeight2 = COMB_bandValues[band + 11] / AMPLITUDE;
				//if (barHeight2 > TOP) barHeight2 = TOP;

				//// Small amount of averaging between frames
				//barHeight2 = ((oldBarHeights[band + 11] * 1) + barHeight2) / 2;

				//oldBarHeights[band] = barHeight;
				//oldBarHeights[band + 11] = barHeight2;

				angle = (360 / BANDS_FOR_THIS_SHOW) * band;

				//radius, angle, z
				// radials
				cylin[band + BANDS_FOR_THIS_SHOW] = { barHeight, angle, barHeight };

				// low index cylin[0] for centers 
				//radius, angle, z
				cylin[band] = { 0, angle, barHeight - 4 };  // the -4 adds depth

			}


			//////////////////////////////cylin



			//byte HUES[7] = { 0,85, 171, 42, 213, 128, 35 };   // red, green, blue, yellow, purple, aqua,  orangish /// + 1 ring color


			SET_SLOW();
			G_dim = DIMMING_INNER;

			G_dim = saved_G_dim;

			if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
			{
				G_dim = DIMMING_MAX_BRIGHTNESS;
			}

			//num_leds = active_columns * 22; // number of active LEDs
			SET_VAR(num_leds);
			//blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes

			/// test only  ////////
			//G_max_flashes = 12;
			//blanks = 8;
			//////////////////////////


			//cylin[0] = { 1, 180,11 };  //radius, angle, z  // center

			//cylin[1] = { 21,90,0 };

			//Serial.print(F("***** P3S7: G_max_flashes="));
			//Serial.println( G_max_flashes);
			//Serial.print(F("blanks="));
			//Serial.println(blanks);
			//Serial.println(F(""));

		
				for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
				{

					//LOAD_BACKGROUND();
					for (int n = 0; n < BANDS_FOR_THIS_SHOW; ++n)
					{
						FLASH_DRAW_CYLIN_CORDINATES(n, n + BANDS_FOR_THIS_SHOW, flash, hues[n], depth);
					}


					//BT_interrupt = SHOW_var_no_dimming(num_leds); // display a variable number of LEDs with no dimming from G_dim
					BT_interrupt = SHOW_var(num_leds);
					FastLED.clear();

					if (BT_interrupt != 0) { break; }

				}
				FastLED.clear();  // remove all streaking during blanking
				SHOW_var(num_leds);

				blanks = blanks + HALL_SYNC2();  // adjust blanks if HALL_SYNC2() returns a 1
				
				if (BT_interrupt != 0) { break; }
			

			G_dim = saved_G_dim;  // restore dimming



			//// Decay peak
			//EVERY_N_MILLISECONDS(60) {
			//	for (byte band = 0; band < NUM_BANDS; band++)
			//		if (peak[band] > 0) peak[band] -= 1;
			//	colorTimer++;
			//}

			//// Used in some of the patterns
			//EVERY_N_MILLISECONDS(10) {
			//	colorTimer++;
			//}

			BT_interrupt = SHOW_slow();

			if (BT_interrupt > 0) { break; }  // leave while loop


		}

	}

	///////////////////////////////////////////////////////////
	// cylindrical radial display
	// angle =  barheight
	// radius = barheight
	// z = band
	if (show_num == 8)  //EXPERIMENTAL cylindrical coordinate show, display spectrum along outter ring and BEAT_SHOW in the center
	{
		Serial.println(F("P3S8: start"));
		Serial.println("");

		//#define LOOP_COUNTS_PER_ACT  30  // number of times to execute an ACT within show_loops
		//#define NUMBER_OF_ACTS 5  // number of switch_case statements 
#define BANDS_FOR_THIS_SHOW 22  // number of frequency bands for this show
#define MAX_INNER_IMAGE_X 11 // maximum x coordinate for innner display

		int show_loops = 30;

		int saved_G_dim = G_dim;

		//byte xs;  // starting x
		//byte ys; //  starting y
		//byte xe;  // ending x
		//byte ye;  // ending y
		int hue_index;  // hue for line
		double radius = 21;


		//G_COMB_bandValues = 10;  // 10 bins

		double angle = 0;
		double angle2 = 0;

		byte depth = 4;  // 22 number of active columns
		//byte active_columns = 22;  // number of active columns
		int num_leds = depth * 22; // number of active LEDs



		byte blanks = 2; // number of flashes to ignore at the end to prevent over wrap, was 5
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command


		///////////// for beat shows
		byte initialize_BS_enables_flag = 1;
#define NUMBER_OF_BS_TO_DISPLAY 3 
#define BS_INCREMENTS 6  // increments to complete BS
		byte total_increments = 8; // number of increments to complete a BEAT_SHOW
		unsigned long beat_count = 0;


		///////////////////////////// define hue's  ///////////////////////////////////////////////////
		//int hue1_bs[NUMBER_OF_BEAT_SHOWS];
		//int hue2_bs[NUMBER_OF_BEAT_SHOWS];
		int start_hue = 0;
		int end_hue = 213;
		int hue_code = STARTING_IMAGE_HUE;

		//// setup HUEs  /////////////////////////

		for (byte bs = 0; bs < NUMBER_OF_BEAT_SHOWS; ++bs)
		{
			// spread the hue's evenly across the number of BEAT_SHOWs using 2 different HUE spreaders
			hue1_bs[bs] = HUE_TRANSITION2(start_hue, end_hue, NUMBER_OF_BEAT_SHOWS, bs);
			hue2_bs[bs] = HUE_TRANSITION(start_hue, end_hue, NUMBER_OF_BEAT_SHOWS, bs);
		}

		//////////////////////////////////////////////////////



		//static byte hall_measure_interval_count = 0;

		//if (hall_measure_interval_count > 30)  // set how long between making HALL_MEASURE2(num_leds)
		//{
		//	hall_measure_interval_count = 0;
		//}

		//if (hall_measure_interval_count == 0)
		//{
		//	++hall_measure_interval_count;

		//	//blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes....commented out with new blanking method

		//	 HALL_MEASURE2(num_leds);  // find G_max_flashes

		//	// for test only 
		//	//blanks = 2;
		//	////////////

		//}

		SET_SLOW();
		G_dim = DIMMING_INNER;

		//G_dim = saved_G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}

		//num_leds = active_columns * 22; // number of active LEDs
		SET_VAR(num_leds);
		//blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes

		//blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes
		HALL_MEASURE2(num_leds);

		Serial.println("");
		Serial.print(F("P3S8: G_max_flashes= "));
		Serial.println(G_max_flashes);
		Serial.println("");

		/// test only
		//cylin[0] = { int(10), int(90), 13 };  // 1st end point 
		//cylin[10] = { 0, int(90), 13 - 5 };  // the -5 adds depth  , 2nd end point anchor at rotation axis

		for (int loop = 0; loop < show_loops; ++loop)
		{



			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT

			BAND(BANDS_FOR_THIS_SHOW);  // combine frequencies into BANDs 

			//SET_SLOW();
			//FastLED.clear();  // clear ALL leds


			//////////////  for center image  /////////////
			//Serial.println(F("P3S8: position 2 "));
			//Serial.println("");

			if ((loop % BS_INCREMENTS) == 0)  // change beat show
			{
				initialize_BS_enables_flag = 1;

			}


			if (initialize_BS_enables_flag == 1)
			{
				initialize_BS_enables_flag = 0;  // only need to initalize one time
				GENERATE_RANDOM_BEAT_SHOW_ENABLES(NUMBER_OF_BS_TO_DISPLAY, NUMBER_OF_BEAT_SHOWS); // determine which non-random bs will play

				SET_SLOW();
				FastLED.clear();  // clear ALL leds
				
			}
			/////////////////////////////////////////////////////////
			//Serial.println(F("P3S8: position 3 "));
			//Serial.println("");

			 //if ((BEAT_DETECT(BEAT_DETECT_THRESHOLD) == 1)||(generate_first_beat == 1))
			 {
				 
				++beat_count;

				SET_SLOW();
				FastLED.clear();  // clear ALL leds

				//BEAT_SHOW_0(beat_count, 1, 1, total_increments, 0, hue1_bs[0], hue2_bs[0], hue_code, 0, 0, 0);

				BEAT_SHOW_ALL(beat_count, total_increments, hue_code);

				//BEAT_SHOW_0(beat_count, 1, BS_enables[0], total_increments, 0, hue1_bs[0], hue2_bs[0], hue_code, 0, 0, 0);
				//BEAT_SHOW_1(beat_count, 1, BS_enables[1], total_increments, 0, hue1_bs[1], hue2_bs[1], hue_code, 0, 0, 0);
				//BEAT_SHOW_2(beat_count, 1, BS_enables[2], total_increments, 0, hue1_bs[2], hue2_bs[2], hue_code, 0, 0, 0);
				//BEAT_SHOW_3(beat_count, 1, BS_enables[3], total_increments, 0, hue1_bs[3], hue2_bs[3], hue_code, 0, 0, 0);
				//BEAT_SHOW_4(beat_count, 1, BS_enables[4], total_increments, 0, hue1_bs[4], hue2_bs[4], hue_code, 0, 0, 0);
				//BEAT_SHOW_5(beat_count, 2, BS_enables[5], total_increments, 0, hue1_bs[5], hue2_bs[5], hue_code, 0, 0, 0);
				//BEAT_SHOW_6(beat_count, 2, BS_enables[6], total_increments, 0, hue1_bs[6], hue2_bs[6], hue_code, 0, 0, 0);
				//BEAT_SHOW_7(beat_count, 2, BS_enables[7], total_increments, 0, hue1_bs[7], hue2_bs[7], hue_code, 0, 0, 0);
				//BEAT_SHOW_8(beat_count, 2, BS_enables[8], total_increments, 0, hue1_bs[8], hue2_bs[8], hue_code, 0, 0, 0);
				//BEAT_SHOW_9(beat_count, 2, BS_enables[9], total_increments, 0, hue1_bs[9], hue2_bs[9], hue_code, 0, 0, 0);
				//BEAT_SHOW_10(beat_count, 3, BS_enables[10], total_increments, 0, hue1_bs[10], hue2_bs[10], hue_code, 0, 0, 0);
				//BEAT_SHOW_11(beat_count, 3, BS_enables[11], total_increments, 0, hue1_bs[11], hue2_bs[11], hue_code, 0, 0, 0);
				//BEAT_SHOW_12(beat_count, 3, BS_enables[12], 5, 0, hue1_bs[12], hue2_bs[12], hue_code);
				//BEAT_SHOW_13(beat_count, 3, BS_enables[13], 5, 0, hue1_bs[13], hue2_bs[13], hue_code);
				//BEAT_SHOW_14(beat_count, 1, BS_enables[14], 4, 0, hue1_bs[14], hue2_bs[14], hue_code);
				//BEAT_SHOW_15(beat_count, 1, BS_enables[15], 4, 0, hue1_bs[15], hue2_bs[15], hue_code);
				//BEAT_SHOW_16(beat_count, 1, BS_enables[16], 4, 0, hue1_bs[16], hue2_bs[16], hue_code);   // pre-programed kind
				//BEAT_SHOW_17(beat_count, 3, BS_enables[17], total_increments, 0, hue1_bs[17], hue2_bs[17], hue_code, 0, 0, 0);
				//BEAT_SHOW_18(beat_count, 2, BS_enables[18], total_increments, 0, hue1_bs[18], hue2_bs[18], hue_code);
				//BEAT_SHOW_19(beat_count, 2, BS_enables[19], total_increments, 0, hue1_bs[19], hue2_bs[19], hue_code);
				////////////////////re-used but changed
				//BEAT_SHOW_16(beat_count, 1, BS_enables[20], 4, 9, hue1_bs[20], hue2_bs[18], hue_code);  // forced kind=9
				//BEAT_SHOW_5(beat_count, 3, BS_enables[21], total_increments, 5, hue1_bs[21], hue2_bs[21], hue_code, 0, 0, 0);   // forced kind=5
				//BEAT_SHOW_8(beat_count, 1, BS_enables[22], total_increments, 3, hue1_bs[22], hue2_bs[22], hue_code, 0, 0, 0); // forced kind=3
				//BEAT_SHOW_10(beat_count, 2, BS_enables[23], total_increments, 3, hue1_bs[23], hue2_bs[23], hue_code, 0, 0, 0); // forced kind=3


			 }

			//Serial.println(F("P3S8: position 4 "));
			//Serial.println("");


			// Process the FFT data into bar heights
			for (byte band = 0; band < BANDS_FOR_THIS_SHOW; band++)
			{
				// Scale the bars for the display

				double barHeight = double(COMB_bandValues[band] / AMPLITUDE);


				if (barHeight > TOP) { barHeight = TOP; }
				if (barHeight == 0) { barHeight = 1; }  // prevent devide by 0

				double barHeight_decreased = barHeight;

				angle = (360 / BANDS_FOR_THIS_SHOW) * band;

				//angle = ((barHeight / 22) * 360);

				angle2 = 360 - angle;

				int delta_band = 5; //for effect, angles line towards center


				///////////// **************************** old: generate an inner image  ************************  ////////////////////////////////////////

				//static byte index_hue = 0;

				//    // limit barHeight_decreased
				//	barHeight_decreased = barHeight/2;
				//	if (barHeight_decreased > MAX_INNER_IMAGE_X)
				//	{
				//		barHeight_decreased = MAX_INNER_IMAGE_X;
				//	}
				//

				//++index_hue;

				//if (index_hue > MAX_HUES) { index_hue = 0; }
				//
				//
				//if (barHeight > 2)
				//{
				//	
				//	LINE(0, 11, barHeight_decreased, band, hues[index_hue]);        // end point x = amplitude, end point y = frequency/band
				//	
				//	if (band <= MAX_INNER_IMAGE_X)  // set maximum x 
				//	{
				//		LINE(0, 11, band, barHeight, hues[index_hue]);        // end point x = frequency/band, end point y = amplitude
				//	}
				//	
				//}

				/////////////////////////****   end of inner image generation *****************/////////////////////////////////////////////////////////////

				// angle = barheight
				// radius = 21
				// z = barheight


				//////////////////////  1st set /////////////////
				//radius, angle, z
				// radials
				cylin[band + BANDS_FOR_THIS_SHOW] = { int(radius), int(angle), int(barHeight) };  // 1st end point ... top

				// below is for test only
				//cylin[band + BANDS_FOR_THIS_SHOW] = { int(barHeight), int(angle), band };  // 1st end point   

				// low index cylin[0] for centers 
				//radius, angle, z
				cylin[band] = { int(radius), int(angle), 0 };  // the -5 adds depth  , 2nd end point anchor at rotation axis...bottom


				/////////// ************ for test only  ******************** //////////////////////////////////////////////////
				////radius, angle, z
				//cylin[band + BANDS_FOR_THIS_SHOW] = { 0, 0, 0 };  // 1st end point 
				//cylin[band] = { 0, 0, 0};

				////radius, angle, z
				//cylin[0] = { int(10), int(90), 13 };  // 1st end point 
				//cylin[10] = { 0, int(90), 13 - 5 };  // the -5 adds depth  , 2nd end point anchor at rotation axis

				//////////////////***************************************************************////////////////////////


				////////////////////////////////////



				///////////////////////////////////////////////

				///////////2nd set /////////////////////////////////////////
				//radius, angle, z
				// radials
				cylin[band + 3 * BANDS_FOR_THIS_SHOW] = { int(radius), int(angle), int(21- barHeight) };  //  end point


				// low index cylin[0] for centers 
				//radius, angle, z
				cylin[band + 2* BANDS_FOR_THIS_SHOW] = { int(radius), int(angle), 21 };  // top

				////////////////////////////////////////////////////////////////////////////////////

				//if (band == 14)
				//{

					//Serial.println("");
					//Serial.println(F("P3S8: data"));
					//Serial.print(F("barHeight= "));
					//Serial.println(barHeight);
					//Serial.print(F("angle= "));
					//Serial.println(int(angle));
					////Serial.print(F("angle2= "));
					////Serial.println(int(angle2));
					//Serial.print(F("blanks= "));
					//Serial.println(blanks);
					//Serial.print(F("G_max_flashes= "));
					//Serial.println(G_max_flashes);
					//Serial.print(F("band= "));
					//Serial.println(band);
					//Serial.println("");

				//}

			}

			G_dim = DIMMING_INNER;

			SHOW_slow();  // display inner image
			SET_VAR(num_leds);

			G_dim = DIMMING_MAX_BRIGHTNESS;  // set brightness of outter LEDs
			//DIM_VAR_LEDS(DIMMING_MAX_BRIGHTNESS, num_leds);  // set proper dimming for outter LEDs

			unsigned long starting_HALL_COUNT = G_Hall_counts;
			byte flash_zeroed_counts = 0;  // incremented each time flash is set to 0;
#define MAX_NUMBER_SAME_FLASH_COUNT_REPEATS 1


			starting_HALL_COUNT == G_Hall_counts;


			if (starting_HALL_COUNT != G_Hall_counts) // this prevents a blank rotation waiting for another sync
			{
				++blanks;

				Serial.print(F("P3S8: incrementing blanks="));
				Serial.println(blanks);
				Serial.println("");
			}

			//Serial.println(F("P3S8: position 5 "));
			//Serial.println("");

			HALL_SYNC2(); //finish out the previous frame

			starting_HALL_COUNT = G_Hall_counts;

			//Serial.println(F("P3S8: position 6 "));
			//Serial.println("");

			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{
				//Serial.print(F("P3S8: position 6.5: flash= "));
				//Serial.println(flash);
				//Serial.println("");

				//FLASH_DRAW_CYLIN_CORDINATES(10, 0, flash, hues[1], depth);  // test only



				for (int k = 0; k < BANDS_FOR_THIS_SHOW; ++k)
				{
					//Serial.print(F("P3S8: position 7: k= "));
					//Serial.println(k);
					//Serial.println("");

					//FLASH_DRAW_CYLIN_CORDINATES(10, 0, flash, hues[1], depth);  // test only
				//FLASH_DRAW_CYLIN_CORDINATES(10, 0, flash, hues[1], depth);  // test only

					FLASH_DRAW_CYLIN_CORDINATES(k, k + BANDS_FOR_THIS_SHOW, flash, hues[k], depth);  // 1st set

					//Serial.print(F("P3S8: position 8: k= "));
					//Serial.println(k);
					//Serial.println("");

					FLASH_DRAW_CYLIN_CORDINATES(k + (2 * BANDS_FOR_THIS_SHOW), k + (3 * BANDS_FOR_THIS_SHOW), flash, hues[k], depth);   // 2nd set
				}


				//BT_interrupt = SHOW_var_no_dimming(num_leds); // display a variable number of LEDs with no dimming from G_dim
				BT_interrupt = SHOW_var(num_leds);
				FastLED.clear();

				if (BT_interrupt != 0) { break; }

			}
			FastLED.clear();  // remove all streaking during blanking
			SHOW_var(num_leds);

			if (BT_interrupt != 0)
			{
				break;
			}


		}


		Serial.println(F("P3S8: >>END "));
		Serial.println("");

		G_dim = saved_G_dim;  // restore dimming

	}
	

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// cylindrical radial display
	// angle =  barheight
	// radius = barheight
	// z = band
	if (show_num == 9)  //original cylindrical coordinate show, 
	{
		Serial.println(F("P3S9: start"));
		Serial.println("");

		//#define LOOP_COUNTS_PER_ACT  30  // number of times to execute an ACT within show_loops
		//#define NUMBER_OF_ACTS 5  // number of switch_case statements 
#define BANDS_FOR_THIS_SHOW 22  // number of frequency bands for this show

		int show_loops = 30;

		int saved_G_dim = G_dim;

		//byte xs;  // starting x
		//byte ys; //  starting y
		//byte xe;  // ending x
		//byte ye;  // ending y
		int hue_index;  // hue for line
		double radius;


		//G_COMB_bandValues = 10;  // 10 bins

		double angle = 0;
		double angle2 = 0;

		byte depth = 4;  // 22 number of active columns
		//byte active_columns = 22;  // number of active columns
		int num_leds = 22 * 22; // number of active LEDs



		byte blanks = 1; // number of flashes to ignore at the end to prevent over wrap, was 5
		byte BT_interrupt = 0;  // equals 1 if interrupted by BT command



		//static byte hall_measure_interval_count = 0;

		//if (hall_measure_interval_count > 30)  // set how long between making HALL_MEASURE2(num_leds)
		//{
		//	hall_measure_interval_count = 0;
		//}

		//if (hall_measure_interval_count == 0)
		//{
		//	++hall_measure_interval_count;

		//	//blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes....commented out with new blanking method

		//	 HALL_MEASURE2(num_leds);  // find G_max_flashes

		//	// for test only 
		//	//blanks = 2;
		//	////////////

		//}

		SET_SLOW();
		G_dim = DIMMING_INNER;

		G_dim = saved_G_dim;

		if (G_dim < DIMMING_MAX_BRIGHTNESS)  // don't allow outter image to be too bright
		{
			G_dim = DIMMING_MAX_BRIGHTNESS;
		}

		//num_leds = active_columns * 22; // number of active LEDs
		SET_VAR(num_leds);
		//blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes

		//blanks = HALL_MEASURE2(num_leds);  // find G_max_flashes
		HALL_MEASURE2(num_leds);

		Serial.println("");
		Serial.print(F("P3S9: G_max_flashes= "));
		Serial.println(G_max_flashes);
		Serial.println("");

		/// test only
		//cylin[0] = { int(10), int(90), 13 };  // 1st end point 
		//cylin[10] = { 0, int(90), 13 - 5 };  // the -5 adds depth  , 2nd end point anchor at rotation axis

		for (int loop = 0; loop < show_loops; ++loop)
		{



			// Compute FFT
			FFT_COMPUTE(); ////sample analog input and  Compute FFT

			BAND(BANDS_FOR_THIS_SHOW);  // combine frequencies into BANDs 

			FastLED.clear();

			// Process the FFT data into bar heights
			for (byte band = 0; band < BANDS_FOR_THIS_SHOW; band++)
			{
				// Scale the bars for the display

				double barHeight = double(COMB_bandValues[band] / AMPLITUDE);

				if (barHeight > TOP) { barHeight = TOP; }
				if (barHeight == 0) { barHeight = 1; }  // prevent devide by 0

				//angle = (360 / BANDS_FOR_THIS_SHOW) * band;

				angle = ((barHeight / 22) * 360);

				angle2 = 360 - angle;

				int delta_band = 5; //for effect, angles line towards center

				// angle = barheight
				// radius = barheight
				// z = band


				//////////////////////  1st set /////////////////
				//radius, angle, z
				// radials
				cylin[band + BANDS_FOR_THIS_SHOW] = { int(barHeight), int(angle), band };  // 1st end point 

				// below is for test only
				//cylin[band + BANDS_FOR_THIS_SHOW] = { int(barHeight), int(angle), band };  // 1st end point 

				// low index cylin[0] for centers 
				//radius, angle, z
				cylin[band] = { 0, int(angle), band - delta_band };  // the -5 adds depth  , 2nd end point anchor at rotation axis


				/////////// ************ for test only  ******************** //////////////////////////////////////////////////
				////radius, angle, z
				//cylin[band + BANDS_FOR_THIS_SHOW] = { 0, 0, 0 };  // 1st end point 
				//cylin[band] = { 0, 0, 0};

				////radius, angle, z
				//cylin[0] = { int(10), int(90), 13 };  // 1st end point 
				//cylin[10] = { 0, int(90), 13 - 5 };  // the -5 adds depth  , 2nd end point anchor at rotation axis

				//////////////////***************************************************************////////////////////////


				////////////////////////////////////



				///////////////////////////////////////////////

				///////////2nd set /////////////////////////////////////////
				//radius, angle, z
				// radials
				cylin[band + 3 * BANDS_FOR_THIS_SHOW] = { int(barHeight), int(angle2), band };  // 1st end point


				// low index cylin[0] for centers 
				//radius, angle, z
				cylin[band + 2 * BANDS_FOR_THIS_SHOW] = { 0, int(angle2), band - delta_band };  // the -2 adds depth  , 2nd end point anchor at rotation axis

				////////////////////////////////////////////////////////////////////////////////////

				//if (band == 14)
				//{

					//Serial.println("");
					//Serial.println(F("P3S8: data"));
					//Serial.print(F("barHeight= "));
					//Serial.println(barHeight);
					//Serial.print(F("angle= "));
					//Serial.println(int(angle));
					////Serial.print(F("angle2= "));
					////Serial.println(int(angle2));
					//Serial.print(F("blanks= "));
					//Serial.println(blanks);
					//Serial.print(F("G_max_flashes= "));
					//Serial.println(G_max_flashes);
					//Serial.print(F("band= "));
					//Serial.println(band);
					//Serial.println("");

				//}

			}

			unsigned long starting_HALL_COUNT = G_Hall_counts;
			byte flash_zeroed_counts = 0;  // incremented each time flash is set to 0;
#define MAX_NUMBER_SAME_FLASH_COUNT_REPEATS 1


			starting_HALL_COUNT == G_Hall_counts;
			//blanks = 1; 

		//for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
		//{
		//			////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//			// The below is done an alternative way sychronize to the hall sensor by leaving the loop if G_Hall_counts is incremented while in the loop.
		//			// The advantage to this method is that there is never a HALL_SYNC to cause a blank display.

		//			if (starting_HALL_COUNT != G_Hall_counts)  // prevent long blank displays waiting for HALL_SYNC
		//			{
		//				
		//				starting_HALL_COUNT = G_Hall_counts;

		//				break; // leave the for loop...this effectively is the same as a HALL_SYNC

		//					//Serial.print(F("blanks= "));  // print to allow for empriacal value of blanks
		//					//Serial.println(blanks);
		//					//Serial.println("");
		//				
		//			}
		//			///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		//			for (int n = 0; n < BANDS_FOR_THIS_SHOW; ++n)
		//			{
		//				//FLASH_DRAW_CYLIN_CORDINATES(10, 0, flash, hues[1], depth);
		//				
		//				FLASH_DRAW_CYLIN_CORDINATES(n, n + BANDS_FOR_THIS_SHOW, flash, hues[n], depth);  // 1st set
		//				
		//			//	FLASH_DRAW_CYLIN_CORDINATES(n + (2 * BANDS_FOR_THIS_SHOW), n + (3 * BANDS_FOR_THIS_SHOW), flash, hues[n], depth);   // 2nd set
		//			}


		//			//BT_interrupt = SHOW_var_no_dimming(num_leds); // display a variable number of LEDs with no dimming from G_dim
		//			BT_interrupt = SHOW_var(num_leds);
		//			FastLED.clear();

		//			if (BT_interrupt != 0) { break; }

		//}


			if (starting_HALL_COUNT != G_Hall_counts) // this prevents a blank rotation waiting for another sync
			{
				++blanks;

				Serial.print(F("P3S8: incrementing blanks="));
				Serial.println(blanks);
				Serial.println("");
			}

			HALL_SYNC2(); //finish out the previous frame

			starting_HALL_COUNT = G_Hall_counts;

			for (byte flash = 0; flash < G_max_flashes - blanks; ++flash)
			{


				//FLASH_DRAW_CYLIN_CORDINATES(10, 0, flash, hues[1], depth);

				for (int n = 0; n < BANDS_FOR_THIS_SHOW; ++n)
				{
					//FLASH_DRAW_CYLIN_CORDINATES(10, 0, flash, hues[1], depth);  // test only

					FLASH_DRAW_CYLIN_CORDINATES(n, n + BANDS_FOR_THIS_SHOW, flash, hues[n], depth);  // 1st set

					FLASH_DRAW_CYLIN_CORDINATES(n + (2 * BANDS_FOR_THIS_SHOW), n + (3 * BANDS_FOR_THIS_SHOW), flash, hues[n], depth);   // 2nd set
				}



				//BT_interrupt = SHOW_var_no_dimming(num_leds); // display a variable number of LEDs with no dimming from G_dim
				BT_interrupt = SHOW_var(num_leds);
				FastLED.clear();

				if (BT_interrupt != 0) { break; }

			}
			FastLED.clear();  // remove all streaking during blanking
			SHOW_var(num_leds);

			if (BT_interrupt != 0) { break; }

			G_dim = saved_G_dim;  // restore dimming
		}

	}

	///////////////////////////////  end of shows ////////////////////////////////////////////////////////
	if (BT_interrupt == 1)
	{


		Serial.println(F("+_+_+_>  PRODUCTION_3 end:   before BLUE_TOOTH_COMMAND_HANDLER"));
		Serial.print(F("G_message= "));
		Serial.println(G_message);
		Serial.print(F("G_BT_command= "));
		Serial.println(G_BT_command);
		Serial.println("");

		BLUE_TOOTH_COMMAND_HANDLER(1);  // execute the BT command  ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

		delay(50);


	}

	if ((show_num >= NUMBER_OF_PRODUCTION3_SHOWS) || (G_force_production_end == 1))
	{
		G_force_production_end = 0;
		G_show_num = 0;  // changed 4/9/24  to correct not executing show 1 (was =1)
		return 1;  // flag that production is complete
	}
	else
	{
		Serial.println(F(" %%%%%%%%  PRODUCTION 3: END:  returning 0"));
		Serial.println(F(""));
		return 0;
	}



}    /////////// end of PRODUCTION 3  ///////////////////

/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
byte PRODUCTION_4()   ////////////  beat detector shows 
// return 1 when PRODUCTION is complete
{
	//return 1; // for testing only

#define run_time 90000 // 1.5 min in ms=90000 ...how long prior to doing the next PRODUCTION,  30 sec for testing
#define NUMBER_OF_PRODUCTION4_SHOWS  1 // one show devided into different cases

	unsigned long last_BT_check = millis();
	unsigned long BT_check_interval = 300;  // check BT every 300ms

	//G_dim = 252;  // for debug only with hood off

	// note: width of each bin = sample rate/number of samples


	//int number_of_shows = 100;       // number of SHOWs
	int show_num = 0;

	int stringSize = 0;
	int hue = -1;  // white
	byte BT_interrupt = 0;


	//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	if ((G_continuous_SPECIAL_mode == 0) && (G_continuous_SPECIAL_mode_was_ON == 1))
	{
		G_continuous_SPECIAL_mode_was_ON = 0;

		CLEAR_FAST_LEDS();

		SHOW_fast(1, 0);
	}


	if (G_BT_message_flag == 0)
	{
		G_BT_message_flag = CHECK_BLUE_TOOTH();

		/*Serial.println("In DO_SHOW2 after CHECK_BLUE_TOOTH");
		Serial.print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= ");
		Serial.println(G_BT_message_flag);
		Serial.println("");*/
	}

	if (G_BT_message_flag == 1)
	{



		//int stringSize = strlen(text_array);
		Serial.println(F("In PRODUCTION_4 after CHECK_BLUE_TOOTH"));
		Serial.print(F("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= "));
		Serial.println(G_BT_message_flag);
		Serial.println("");
		Serial.print(F("G_message= "));
		Serial.println(G_message);
		//Serial.print("stringSize= ");
		//Serial.println(stringSize);
		Serial.print(F("G_BT_command= "));
		Serial.println(G_BT_command);
		Serial.println("");

		/*SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0, 0);
		G_BT_message_flag = 0;*/


		BLUE_TOOTH_COMMAND_HANDLER(1);  // execute the BT command  ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
		//DC_COMMAND_HANDLER();  // need this if the BT COMMAND HANDLER calls TRANSFER2_SLOW which will transfer back a DON_COM command
		delay(50);


	}

	if (G_continuous_SPECIAL_mode == 1)
	{
		G_show_num = 255;
	}

	//if ((G_show_num > number_of_shows) || (G_show_num == 1))
	//{
	//	if ((G_show_num != 255) && (G_show_num != 254))  // 255 is a flag to show BT text_array
	//	{
	//		G_show_num = 1;
	//		HALL_MEASURE3(22);  //find G_max_bins
	//	}

	//}



	/////////////////////////////  THE SHOWs ///////////////////////////

		// -------------->    get next show number  <--------------------------
	// NOTE: I need to keep the number of shows low to prevent delay in show handler

	Serial.print(F("***  in PRODUCTION4: just prior to SHOW_HANDLER"));
	Serial.print(F("G_show_num="));
	Serial.println(G_show_num);
	Serial.print(F("G_forced_production="));
	Serial.println(G_forced_production);



	show_num = SHOW_HANDLER(NUMBER_OF_PRODUCTION4_SHOWS);  ////// SHOW HANDLER  ///////////

	if (SERIAL_MON == 1)
	{
		Serial.println("");
		Serial.println(F("------> PRODUCTION_4 <------ "));
		Serial.print(F("******************************************* G_show_num= "));
		Serial.println(G_show_num);
		Serial.print(F("show_num= "));
		Serial.println(show_num);
		Serial.println("");
	}

	if (show_num == 0)   // CREATE mode
	{
		unsigned long present_system_time = millis();
		unsigned long delta_time = present_system_time - G_CREATE_MODE_start_time;

		//Serial.println("");
		//Serial.println(F("--------->  DO_SHOW:"));
		//Serial.print(F(" G_CREATE_MODE_start_time="));
		//Serial.println(G_CREATE_MODE_start_time);
		//Serial.print(F(" delta_time="));
		//Serial.println(delta_time);
		//Serial.print(F(" G_executing_CREATE_mode="));
		//Serial.println(G_executing_CREATE_mode);
		//Serial.print(F(" G_PLAY_SAVES_MODE_ON="));
		//Serial.println(G_PLAY_SAVES_MODE_ON);
		//Serial.println("");

		if (G_PLAY_SAVES_MODE_ON == 0) //  not PLAY SAVES
		{

			if (((delta_time) > MAXIMUM_IDLE_CREATE_MODE_TIME))  // EXIT CREATE MODE and execute SHOW
			{
				// NOTE: G_CREATE_MODE_start_time is set in the BT command handler every time a BT command is called
				G_BT_command = 'L'; // turn off CREATE MODE and turn on SHOW

				//Serial.println("");
				//Serial.println(F("--------->  before BT command to exit CREATE MODE:"));
				//Serial.println("");

				BLUE_TOOTH_COMMAND_HANDLER(1);
				return 1;
			}

		}

		CREATE_MODE();
		//Serial.println(F("DO_SHOW: before DUMP after CREATE_MODE(): show_num=0"));
		//DUMP_LED_ARRAY(leds1, NUM_LEDS);

	}

	//////  SHOW 255...show BT text
	if (G_show_num == 255)
	{
		SHOW_255();

		//HALL_MEASURE3(22);

		////stringSize = strlen(text_array);

		//stringSize=ADD_SPECIAL_TEXT();  // add special image Text characters to text_array

		////stringSize = strlen(text_array);  // new string size
		//
		//SCROLL_TEXT(text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0);
		//BT_and_DC_CHECKandDO();
	}

	if (G_show_num == 254)  // works in conjunction with DC command 11
		// display G_SAVED image 
	{
		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");

		int stringSize = strlen(scroll_text_array);

		//HALL_MEASURE3(22);  //find G_max_bins
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 2, 0);
		G_special_char_select = 1;
		BT_and_DC_CHECKandDO();

	}


	if (G_CREATE_mode == 0)
	{
		FastLED.clear();
	}



	///////////////////////////////////////////////////////////
	if (show_num == 1)  // BEAT DETECTOR :   BEAT SHOWS
		// https://www.hackster.io/mamifero/arduino-beat-detector-d0a21f  // note: I didn't end up using this BEAT DETECTOR...I wrote my own
	{
		//Serial.println(F(""));
		//Serial.print(F("$$$$$$$$$ 88: G_dim= "));
		//Serial.println(G_dim);
		//Serial.println(F(""));
		
		BEAT_SHOW_PRODUCTION(0);

		Serial.println(F(""));
		Serial.println(F(">>>>>>>  END of BEAT_SHOW_PRODUCTION 4  <<<<<<<<<<"));
		Serial.println(F(""));
	}

	if ((show_num == NUMBER_OF_PRODUCTION4_SHOWS) || (G_force_production_end == 1))
	{
		G_force_production_end = 0;
		G_show_num = 1;
		return 1;  // flag that production is complete
	}
	else
	{
		return 0;
	}



}

/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
byte PRODUCTION_5()   ////////////  musical NOTES on PIANO
// return 1 when PRODUCTION is complete
{
	//return 1; // for testing only

#define run_time_SHOW1 90000 // 6 min in ms=360000 ...how long prior to doing the next PRODUCTION, was 180000
#define run_time_SHOW2 90000 // 6 min in ms=360000 ...how long prior to doing the next PRODUCTION

#define NUMBER_OF_PRODUCTION5_SHOWS  2 // one show devided into different cases
#define MAX_NO_SOUND_TIME 4000  // maximum amount of time with no sound before exiting this production
#define max_no_beat_time  2000 // maximum amount of time between beats before threshold is reset to initial value


	unsigned long last_BT_check = millis();
	unsigned long BT_check_interval = 300;  // check BT every 300ms

	//G_dim = 252;  // for debug only with hood off

	// note: width of each bin = sample rate/number of samples


	//int number_of_shows = 100;       // number of SHOWs
	int show_num = 0;

	int stringSize = 0;
	int hue = -1;  // white
	byte BT_interrupt = 0;


	Serial.println(F("--------->  PRODUCTION_5 start:"));
	Serial.println("");

	//TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	if ((G_continuous_SPECIAL_mode == 0) && (G_continuous_SPECIAL_mode_was_ON == 1))
	{
		G_continuous_SPECIAL_mode_was_ON = 0;

		CLEAR_FAST_LEDS();

		SHOW_fast(1, 0);
	}


	if (G_BT_message_flag == 0)
	{
		G_BT_message_flag = CHECK_BLUE_TOOTH();

		/*Serial.println("In DO_SHOW2 after CHECK_BLUE_TOOTH");
		Serial.print("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= ");
		Serial.println(G_BT_message_flag);
		Serial.println("");*/
	}

	if (G_BT_message_flag == 1)
	{



		//int stringSize = strlen(text_array);

		//Serial.println(F("In PRODUCTION_5 after CHECK_BLUE_TOOTH"));
		//Serial.print(F("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%G_BT_message_flag= "));
		//Serial.println(G_BT_message_flag);
		//Serial.println("");
		//Serial.print(F("G_message= "));
		//Serial.println(G_message);
		//Serial.print(F("G_BT_command= "));
		//Serial.println(G_BT_command);
		//Serial.println("");

		/*SCROLL_TEXT(text_array, stringSize, 1, 1, 1, 0, 0);
		G_BT_message_flag = 0;*/


		BLUE_TOOTH_COMMAND_HANDLER(1);  // execute the BT command  ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
		//DC_COMMAND_HANDLER();  // need this if the BT COMMAND HANDLER calls TRANSFER2_SLOW which will transfer back a DON_COM command
		delay(50);


	}

	if (G_continuous_SPECIAL_mode == 1)
	{
		G_show_num = 255;
	}

	//if ((G_show_num > number_of_shows) || (G_show_num == 1))
	//{
	//	if ((G_show_num != 255) && (G_show_num != 254))  // 255 is a flag to show BT text_array
	//	{
	//		G_show_num = 1;
	//		HALL_MEASURE3(22);  //find G_max_bins
	//	}

	//}



	/////////////////////////////  THE SHOWs ///////////////////////////

		// -------------->    get next show number  <--------------------------
	// NOTE: I need to keep the number of shows low to prevent delay in show handler

	//Serial.print(F("***  in PRODUCTION5: just prior to SHOW_HANDLER"));
	//Serial.print(F("G_show_num="));
	//Serial.println(G_show_num);

	show_num = SHOW_HANDLER(NUMBER_OF_PRODUCTION5_SHOWS);  ////// SHOW HANDLER  ///////////

	if (SERIAL_MON == 1)
	{
		Serial.println("");
		Serial.println(F("------> PRODUCTION_5 <------ "));
		Serial.print(F("******************************************* G_show_num= "));
		Serial.println(G_show_num);
		Serial.print(F("show_num= "));
		Serial.println(show_num);
		Serial.println("");
	}

	if (show_num == 0)   // CREATE mode
	{
		unsigned long present_system_time = millis();
		unsigned long delta_time = present_system_time - G_CREATE_MODE_start_time;

		//Serial.println("");
		//Serial.println(F("--------->  DO_SHOW:"));
		//Serial.print(F(" G_CREATE_MODE_start_time="));
		//Serial.println(G_CREATE_MODE_start_time);
		//Serial.print(F(" delta_time="));
		//Serial.println(delta_time);
		//Serial.print(F(" G_executing_CREATE_mode="));
		//Serial.println(G_executing_CREATE_mode);
		//Serial.print(F(" G_PLAY_SAVES_MODE_ON="));
		//Serial.println(G_PLAY_SAVES_MODE_ON);
		//Serial.println("");

		if (G_PLAY_SAVES_MODE_ON == 0) //  not PLAY SAVES
		{

			if (((delta_time) > MAXIMUM_IDLE_CREATE_MODE_TIME))  // EXIT CREATE MODE and execute SHOW
			{
				// NOTE: G_CREATE_MODE_start_time is set in the BT command handler every time a BT command is called
				G_BT_command = 'L'; // turn off CREATE MODE and turn on SHOW

				//Serial.println("");
				//Serial.println(F("--------->  before BT command to exit CREATE MODE:"));
				//Serial.println("");

				BLUE_TOOTH_COMMAND_HANDLER(1);
				return 1;
			}

		}

		CREATE_MODE();
		//Serial.println(F("DO_SHOW: before DUMP after CREATE_MODE(): show_num=0"));
		//DUMP_LED_ARRAY(leds1, NUM_LEDS);

	}

	//////  SHOW 255...show BT text
	if (G_show_num == 255)
	{
		SHOW_255();

		//HALL_MEASURE3(22);

		////stringSize = strlen(text_array);

		//stringSize=ADD_SPECIAL_TEXT();  // add special image Text characters to text_array

		////stringSize = strlen(text_array);  // new string size
		//
		//SCROLL_TEXT(text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0);
		//BT_and_DC_CHECKandDO();
	}

	if (G_show_num == 254)  // works in conjunction with DC command 11
		// display G_SAVED image 
	{
		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");

		int stringSize = strlen(scroll_text_array);

		//HALL_MEASURE3(22);  //find G_max_bins
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1, 2, 0);
		G_special_char_select = 1;
		BT_and_DC_CHECKandDO();

	}


	//if (G_CREATE_mode == 0)
	//{
	//	FastLED.clear();
	//}



	///////////////////////////////////////////////////////////
	if (show_num == 1)  // musical NOTE show
	{

		byte sd = 0;  // sound detect
		unsigned long sound_detect_time_stamp = millis();


		byte dim_rate = 200;  // this will dim to black after 10 notes, higher number faster dimming...was 100
		byte beat = 0;
		int active_leds = 22 * 22;
		unsigned long time = micros(); // Used to track rate
		float thresh = 150; // initial threshold value

		static byte do_once = 0;

		unsigned long start_time = millis();
		static byte hue_rolling = 0;


		// for show
		static unsigned long beat_count = 0; // increments on each detected beat

		G_dim = DEFAULT_BRIGTHNESS;


		/////////////////////////////////////////////////////////////////

				// NOTE: FFT2:   bin width resolution = 8KHz sample rate/512 samples = 15Hz per bin
			// for FFT, 125us/sample --> 64ms/512 samples

				/* NOTE detection works by using FFT2 then running FIND_MAX_CORRELATION_VALUE().
				This is needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2.
				G_ND_correlation is the maximum correlation from any of the MNOTES relative to the FFT2 bins (all bins).
				The threshold for NOTE_DETECT2 is a fixed fraction of G_ND_correlation.
				Also, all the MNOTE data is scaled according to MNOTE[].gain_factor. The MNOTE data is retrieved from TEST #51.
				This data is captured from the microphone after playing each note. But, because playing a note multiple times results in
				data that is not consistant in amplitude, I need to scale the MNOTE data to normalize it.
				The MNOTE[].gain_factor is obtained by playing a NOTE multiple times and finding the maximum correlation value
				as reported by NOTE_DETECT2. I then normalized everything to NOTE 0's maximum correlation value.
				*/


				// NOTE: FFT bin width resolution = 40KHz sample rate/1024 samples = 39Hz per bin
				// highest freq. note 16 E5 = 659 Hz --> 659/39 = bin 17
				// lowest freq. note 0 C4 =261 Hz --> 261/39 = bin 6 or 7


		while (millis() < start_time + run_time_SHOW1)
		{
			if (millis() - sound_detect_time_stamp > MAX_NO_SOUND_TIME)  // no sound detected so return to previous shows
			{
				G_force_sound_productions = 0;
				G_force_production_end = 1;

				Serial.println(F("----)))--->PRODUCTION 5: show 1:  NO SOUND DETECTED"));
				Serial.println(F(""));
			}


			if ((G_production != 5) || (G_force_production_end == 1))  // force exit this show
			{

				break;

			}

			//if (check_BT_count > 20)
			if ((millis() - last_BT_check) > BT_check_interval)
			{
				//check_BT_count = 0; 

				last_BT_check = millis();

				if (G_BT_message_flag == 0)
				{
					G_BT_message_flag = CHECK_BLUE_TOOTH();  // get BT command

				}

				if (G_BT_message_flag == 1)
				{
					TURN_OFF_PLAY_SAVES_MODE();
					BLUE_TOOTH_COMMAND_HANDLER(1);

					break;
				}

			}

			//byte CHOOSE_NOTE_DETECT_type = 1;  // 0=find most likely note,  1 = test an individual note


			static unsigned long time_SD = millis();  // time of sound detect
			unsigned long amplitude = 1000;  // was 2000
			int noise = 800; // was 500
			byte radius8 = (beat_count) % 8;  // increments based on modulus
			//static byte check_BT_count = 0;  // used to only check BT after a defined number of counts

			//if ((millis() - time_SD) > 250)  // can't have two sound detects closer than 250ms
			{


				// sd = SOUND_DETECT2(4, 0);  // threshold was 2
				sd = SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0);

				Serial.print(F("%%%%--->>>> sd ="));
				Serial.println(sd);
				//Serial.print(F("first_time_flag ="));
			   // Serial.println(first_time_flag);
				Serial.println(F(""));



				if (sd == 1)
				{
					byte detected_note = 0;

					sound_detect_time_stamp = millis();

					FFT2_COMPUTE();
					FIND_MAX_CORRELATION_VALUE();  // needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2

					time_SD = millis();

					Serial.print(F("$$$$$------->>>> G_ND_correlation ="));
					Serial.println(G_ND_correlation);
					Serial.println(F(""));

					///////////use NOTE_DETECT
					//	if (CHOOSE_NOTE_DETECT_type == 0)
					//	{
					//		detected_note = FIND_MAX_CORRELATION_VALUE();

					//		Serial.print(F("*****------->>>>   detected NOTE="));
					//		Serial.println(detected_note);
					//		Serial.println(F(""));
					//	}

					////////////////////////////////////////////////////

					int threshold = (G_ND_correlation * NOTE_DETECT_THRESHOLD) / 100;  // take 80% to set threshold;
					byte detected = 0;


					for (byte note = 0; note < NUMBER_OF_MNOTES; ++note)
					{


						detected = NOTE_DETECT2(note, threshold);

						if (detected == 1)
						{
							Serial.print(F("*****------->>>>   detected NOTE="));
							Serial.println(note);
							Serial.println(F(""));

							Serial.print(F("%%%%%------->>>> threshold="));
							Serial.println(threshold);
							Serial.println(F(""));

							//// DIMMING //////////////////////////////////////////
							for (int i = 0; i < NUM_LEDS; ++i)  // dim all LEDs 
							{
								leds1[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
								leds2[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
								leds3[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
								leds4[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
							}


							++beat_count;
							++hue_rolling;
							++hue_rolling;

							byte enable = 1;  //  previous show is erased if enable=0


							switch (note) {
							case 0:

								BEAT_SHOW_0(beat_count, 1, enable, 8, 0, 171, 42, STARTING_IMAGE_HUE, 0, 0, 0);  // 2 moving triangles

								break;
							case 1:

								BEAT_SHOW_1(beat_count, 1, enable, 8, 0, 85, 0, STARTING_IMAGE_HUE, 0, 0, 0); // two crosing lines of different color

								break;
							case 2:
								//BEAT_SHOW_2x(beat_count, 1, enable, 5, 171);  // downward moving blue cone
								BEAT_SHOW_2(beat_count, 1, enable, 5, 0, 171, 85, STARTING_IMAGE_HUE, 0, 0, 0);  // downward blue cone and green circle

								break;
							case 3:
								//BEAT_SHOW_3x(beat_count, 8, enable, radius8, 0, 42);  // up and down yellow sphere
								BEAT_SHOW_3(beat_count, 1, enable, 8, 0, 42, 42, STARTING_IMAGE_HUE, 0, 0, 0);

								break;
							case 4:
								//BEAT_SHOW_4x(beat_count, 5, enable, 0, 213);  // verticle purple moving line
								BEAT_SHOW_4(beat_count, 1, enable, 5, 0, 213, 213, STARTING_IMAGE_HUE, 0, 0, 0);

								break;
							case 5:
								//BEAT_SHOW_5x(beat_count, 8, enable, 5, 0, 120);  //aqua hoz moving hoz line
								BEAT_SHOW_5(beat_count, 1, enable, 8, 0, 120, 120, STARTING_IMAGE_HUE, 0, 0, 0); // vertically moving line that starts vertical and ends horizontal

								break;
							case 6:
								//BEAT_SHOW_6x(beat_count, 10, enable, 0, 140);  // orangish in/out moving tube
								// in and out moving circles
								BEAT_SHOW_6(beat_count, 1, enable, 10, 0, 140, 42, STARTING_IMAGE_HUE, 0, 0, 0);
								break;
							case 7:
								//BEAT_SHOW_7x(beat_count, 8, enable, 3, hue_rolling);  // orangish in/out moving tube
								BEAT_SHOW_7(beat_count, 3, enable, 8, 0, hue_rolling, hue_rolling / 2, STARTING_IMAGE_HUE, 0, 0, 0); //2 moving squares

								break;
							case 8:
								//BEAT_SHOW_8x(beat_count, 8, enable, 2, 2 * hue_rolling);  // orangish in/out moving tube
								BEAT_SHOW_8(beat_count, 1, enable, 8, 0, 2 * hue_rolling, 2 * hue_rolling, STARTING_IMAGE_HUE, 0, 0, 0);

								break;
							case 9:
								//BEAT_SHOW_9x(beat_count, 6, enable, 0, 69);  
								BEAT_SHOW_9(beat_count, 1, enable, 6, 0, 69, 69, STARTING_IMAGE_HUE, 0, 0, 0);

								break;
							case 10:
								//BEAT_SHOW_10x(beat_count, 7, enable, 0, 84);
								BEAT_SHOW_10(beat_count, 1, enable, 7, 0, 84, 84, STARTING_IMAGE_HUE, 0, 0, 0);

								break;
							case 11:
								//BEAT_SHOW_11x(beat_count, 4, enable, 0, 114);
								BEAT_SHOW_11(beat_count, 1, enable, 4, 0, 114, 114, STARTING_IMAGE_HUE, 0, 0, 0);

								break;


							case 12:

								//BEAT_SHOW_0(beat_count, 1, enable, 8, 0, 171, 42, STARTING_IMAGE_HUE, 0, 0, 0);  // 2 moving triangles
								BEAT_SHOW_12(beat_count, 3, enable, 5, 0, 171, 42, STARTING_IMAGE_HUE);

								break;
							case 13:

								//BEAT_SHOW_1(beat_count, 1, enable, 8, 0, 85, 0, STARTING_IMAGE_HUE, 0, 0, 0); // two crosing lines of different color
								BEAT_SHOW_13(beat_count, 1, enable, 8, 0, 85, 0, STARTING_IMAGE_HUE);
								break;
							case 14:

								//BEAT_SHOW_2(beat, 1, enable, 8, 0, 20, 85, STARTING_IMAGE_HUE , 0, 0, 0);  // downward blue cone and green circle
								BEAT_SHOW_14(beat_count, 1, enable, 8, 0, 20, 85, STARTING_IMAGE_HUE);
								break;
							case 15:

								//BEAT_SHOW_3(beat_count, 1, enable, 8, 0, 142, 142, STARTING_IMAGE_HUE, 0, 0, 0);
								BEAT_SHOW_15(beat_count, 1, enable, 8, 0, 142, 142, STARTING_IMAGE_HUE);
								break;

							case 16:

								//BEAT_SHOW_0(beat_count, 1, enable, 8, 0, 171, 42, STARTING_IMAGE_HUE, 0, 0, 0);  // 2 moving triangles
								BEAT_SHOW_16(beat_count, 1, enable, 8, 0, 171, 42, STARTING_IMAGE_HUE);
								break;
							case 17:

								//BEAT_SHOW_1(beat_count, 1, enable, 8, 0, 85, 0, STARTING_IMAGE_HUE, 0, 0, 0); // two crosing lines of different color
								BEAT_SHOW_17(beat_count, 1, enable, 8, 0, 85, 0, STARTING_IMAGE_HUE, 0, 0, 0);
								break;
							case 18:

								//BEAT_SHOW_2(beat_count, 1, enable, 5, 0, 0, 85, STARTING_IMAGE_HUE,  0, 0, 0);  // downward red cone and green circle
								BEAT_SHOW_18(beat_count, 1, enable, 5, 0, 0, 85, STARTING_IMAGE_HUE);
								break;
							case 19:

								//BEAT_SHOW_10(beat_count, 1, enable, 5, 0, 0, 85, STARTING_IMAGE_HUE);
								BEAT_SHOW_19(beat_count, 1, enable, 5, 0, 0, 85, STARTING_IMAGE_HUE);
								break;
							case 20:
								//BEAT_SHOW_4x(beat_count, 5, enable, 0, 213);  // verticle purple moving line
								//BEAT_SHOW_4(beat_count, 1, enable, 5, 0, 213, 213, STARTING_IMAGE_HUE, 0, 0, 0);
								BEAT_SHOW_16(beat_count, 1, enable, 4, 9, 213, 213, STARTING_IMAGE_HUE);  // forced kind=9
								break;
							case 21:

								BEAT_SHOW_5(beat_count, 1, enable, 8, 0, 120, 120, STARTING_IMAGE_HUE, 0, 0, 0); // vertically moving line that starts vertical and ends horizontal

								break;
							case 22:

								//BEAT_SHOW_6(beat_count, 1, enable, 10, 0, 140 , 42, STARTING_IMAGE_HUE, 0, 0, 0);
								BEAT_SHOW_8(beat_count, 1, enable, 8, 3, 120, 120, STARTING_IMAGE_HUE, 0, 0, 0); // forced kind=3


								break;
							case 23:

								BEAT_SHOW_10(beat_count, 1, enable, 10, 3, 140, 42, STARTING_IMAGE_HUE, 0, 0, 0); // forced kind=3
								//BEAT_SHOW_7(beat_count, 3, enable, 8, 0, hue_rolling, hue_rolling / 2, STARTING_IMAGE_HUE, 0, 0, 0);

								break;

							default:
								// statements
								break;
							}

							Serial.print(F("P5: _________________________________________________"));
							Serial.println(F(""));
							Serial.println(F(""));

						}

						//++check_BT_count;

						//unsigned long last_BT_check = millis();
						//unsigned long BT_check_interval = 300;  // check BT every 300ms





						if (G_BT_message_flag == 0)
						{

							FastLED.show();

						}
						else   // needed to make sure PLAY SAVES switch reliably turns of PLAYSAVES moded when TEXT is showing
						{

							TURN_OFF_PLAY_SAVES_MODE();
							BLUE_TOOTH_COMMAND_HANDLER(1);

							break;

						}


						//Serial.print(F("_________________________________________________"));
						//Serial.println(F(""));
						//Serial.println(F(""));
					}
				}
			}
		}


	}
	//////////////////////////////////////////////////////////
	if (show_num == 2)  // merge load SHOW
	{
		Serial.println(F("----****)))--->PRODUCTION 5: show 2:  start"));
		Serial.println(F(""));

		if (G_force_production_end == 0)
		{

			FastLED.clear();

			byte sd = 0;  // sound detect
			unsigned long sound_detect_time_stamp = millis();


			byte dim_rate = 200;  // this will dim to black after 10 notes, higher number faster dimming...was 100
			byte beat = 0;
			int active_leds = 22 * 22;
			unsigned long time = micros(); // Used to track rate
			float thresh = 150; // initial threshold value

			static byte do_once = 0;

			unsigned long start_time = millis();
			static byte hue_rolling = 0;


			// for show
			static unsigned long beat_count = 0; // increments on each detected beat

			G_dim = DEFAULT_BRIGTHNESS;

			//MNOTE_HUES(0, 213); // assign a HUE to each musical note

			MAP_MNOTE_HUES(171, 0); // assign a HUE to each musical note

			/////////////////////////////////////////////////////////////////

					// NOTE: FFT2:   bin width resolution = 8KHz sample rate/512 samples = 15Hz per bin
				// for FFT, 125us/sample --> 64ms/512 samples

					/* NOTE detection works by using FFT2 then running FIND_MAX_CORRELATION_VALUE().
					This is needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2.
					G_ND_correlation is the maximum correlation from any of the MNOTES relative to the FFT2 bins (all bins).
					The threshold for NOTE_DETECT2 is a fixed fraction of G_ND_correlation.
					Also, all the MNOTE data is scaled according to MNOTE[].gain_factor. The MNOTE data is retrieved from TEST #51.
					This data is captured from the microphone after playing each note. But, because playing a note multiple times results in
					data that is not consistant in amplitude, I need to scale the MNOTE data to normalize it.
					The MNOTE[].gain_factor is obtained by playing a NOTE multiple times and finding the maximum correlation value
					as reported by NOTE_DETECT2. I then normalized everything to NOTE 0's maximum correlation value.
					*/


					// NOTE: FFT bin width resolution = 40KHz sample rate/1024 samples = 39Hz per bin
					// highest freq. note 16 E5 = 659 Hz --> 659/39 = bin 17
					// lowest freq. note 0 C4 =261 Hz --> 261/39 = bin 6 or 7


			while (millis() < start_time + run_time_SHOW2)
			{
				if (millis() - sound_detect_time_stamp > MAX_NO_SOUND_TIME)  // no sound detected so return to previous shows
				{
					G_force_sound_productions = 0;
					G_force_production_end = 1;

					Serial.println(F("----)))--->PRODUCTION 5: show 2:  NO SOUND DETECTED"));
					Serial.println(F(""));
				}


				if ((G_production != 5) || (G_force_production_end == 1))  // force exit this show
				{

					break;

				}

				//if (check_BT_count > 20)
				if ((millis() - last_BT_check) > BT_check_interval)
				{
					//check_BT_count = 0; 

					last_BT_check = millis();

					if (G_BT_message_flag == 0)
					{
						G_BT_message_flag = CHECK_BLUE_TOOTH();  // get BT command

					}

					if (G_BT_message_flag == 1)
					{
						TURN_OFF_PLAY_SAVES_MODE();
						BLUE_TOOTH_COMMAND_HANDLER(1);

						break;
					}

				}

				//byte CHOOSE_NOTE_DETECT_type = 1;  // 0=find most likely note,  1 = test an individual note
				unsigned long time_stamp = millis();
				static unsigned long time_SD = millis();  // time of sound detect
				unsigned long amplitude = 1000;  // was 2000
				int noise = 800; // was 500
				byte radius8 = (beat_count) % 8;  // increments based on modulus
				//static byte check_BT_count = 0;  // used to only check BT after a defined number of counts

				if ((time_stamp - time_SD) > 250)  // can't have two sound detects closer than 250ms
				{


					//sd = SOUND_DETECT2(4, 0);  // threshold was 2
					sd = SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0);

					if (sd == 1)
					{
						byte detected_note = 0;

						sound_detect_time_stamp = millis();

						FFT2_COMPUTE();
						FIND_MAX_CORRELATION_VALUE();  // needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2

						time_SD = millis();

						Serial.print(F("$$$$$------->>>> G_ND_correlation ="));
						Serial.println(G_ND_correlation);
						Serial.println(F(""));

						///////////use NOTE_DETECT
						//	if (CHOOSE_NOTE_DETECT_type == 0)
						//	{
						//		detected_note = FIND_MAX_CORRELATION_VALUE();

						//		Serial.print(F("*****------->>>>   detected NOTE="));
						//		Serial.println(detected_note);
						//		Serial.println(F(""));
						//	}

						////////////////////////////////////////////////////

						int threshold = (G_ND_correlation * NOTE_DETECT_THRESHOLD) / 100;  // take 80% to set threshold;
						byte detected = 0;


						for (byte note = 0; note < NUMBER_OF_MNOTES; ++note)
						{


							detected = NOTE_DETECT2(note, threshold);

							if (detected == 1)
							{
								Serial.print(F("*****------->>>>   detected NOTE="));
								Serial.println(note);
								Serial.println(F(""));

								Serial.print(F("%%%%%------->>>> threshold="));
								Serial.println(threshold);
								Serial.println(F(""));

								//// DIMMING //////////////////////////////////////////
								for (int i = 0; i < NUM_LEDS; ++i)  // dim all LEDs 
								{
									leds1[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
									leds2[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
									leds3[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
									leds4[i].fadeToBlackBy(dim_rate); // dims by 10/256ths
								}


								++beat_count;
								++hue_rolling;
								++hue_rolling;

								int image2load = image_array[note];
								int hue = MNOTE[note].hue;          // as set by MNOTE_HUES(213, 0)  which assigns a HUE to each musical note

								//MERGE_LOAD(image2load, -1);   /// this generates the show
								MERGE_LOAD(image2load, hue);   /// this generates the show

								Serial.print(F("_________________________________________________"));
								Serial.println(F(""));
								Serial.println(F(""));

							}

							//++check_BT_count;

							//unsigned long last_BT_check = millis();
							//unsigned long BT_check_interval = 300;  // check BT every 300ms





							if (G_BT_message_flag == 0)
							{

								FastLED.show();

							}
							else   // needed to make sure PLAY SAVES switch reliably turns of PLAYSAVES moded when TEXT is showing
							{

								TURN_OFF_PLAY_SAVES_MODE();
								BLUE_TOOTH_COMMAND_HANDLER(1);

								break;

							}


							//Serial.print(F("_________________________________________________"));
							//Serial.println(F(""));
							//Serial.println(F(""));
						}
					}
				}
			}

		}

		//////////////////////////////////////////////////////////
		// next show starts here

	}


	/////////////////

	if ((show_num >= NUMBER_OF_PRODUCTION5_SHOWS) || (G_force_production_end == 1))
	{
		G_force_production_end = 0;
		//G_show_num = 1;
		G_show_num = 0;  // changed on 4/9/24 to allow repeat of show #1
		return 1;  // flag that production is complete
	}
	else
	{
		return 0;
	}

}


/******************************************************************************************************************/
void BT_and_DC_CHECKandDO() // formarlly TRANSFER2_SLOW()
{

	if (G_BT_message_flag == 0)  // only allow for one BT message
	{
		G_BT_message_flag = CHECK_BLUE_TOOTH();      // *************** BLUE TOOTH *********************
	}

	if (G_BT_message_flag == 1)
	{
		Serial.print(F("TF2S TOP: %%%%%%%%%  G_BT_message_flag= "));
		Serial.println(G_BT_message_flag);
		Serial.print(F("G_BT_command="));
		Serial.println(G_BT_command);
		Serial.println("");

		BLUE_TOOTH_COMMAND_HANDLER(1);
	}


	G_message = "";  // clear previous Blue Tooth message

	DC_CHECK_AND_DO();


}






/******************************************************************************************************************/
byte SHOW_slow()  // display the maximum number of LEDs
{
	// return 1 if BT command detected: NOTE BT command is handled in SHOW_slow()

	if (G_active != NUM_LEDS)  // if current set to FAST LEDs
	{
		SET_SLOW();
		//	G_active = NUM_LEDS;
	}

	//Serial.println(F(""));
	//Serial.print(F("SHOW_SLOW: G_dim="));
	//Serial.println(G_dim);
	//Serial.println(F(""));

	//if (G_BT_data_arrival == 0)  // allow for BT interrupt: *********** NOTE  un-commenting this line causes GUI to appear non-responsive  ***********
	//{
	DIM_SLOW_LEDS(G_dim);  // dim SLOW leds


	FastLED.show();



	if (G_SKIP_BTCH == 0) // skip BLUE_TOOTH_COMMAND_HANDLER if =1
	{

		G_BT_message_flag = CHECK_BLUE_TOOTH();  // get BT command

		if (G_BT_message_flag != 0)  // needed to prevent multiple RESETS after CREATE MODE turned off
		{
			BLUE_TOOTH_COMMAND_HANDLER(1);
		}
	}

	return G_BT_message_flag;

}

/******************************************************************************************************************/
byte SHOW_fast(byte depth, byte depth_effect)  // display the fast_leds# by coping them into leds#
// return 1 if interrupted by BT command
// depth=number of columns to display same image as column 0, ex. depth=1 is outside column, depth=2 is outside column and next one over as well
// depth_effect = effect to apply to columns at depth >1 , 0 = no effect
// depth_effects: 0 = no effect,  1= shift inner LEDs down 1, 2=shift inner LEDs up 1,
//				  3= generate a vertical rainbow effect,  4=generate a horizontal rainbow effect (5 hue increment),  5= swap colors  
//				  6=generate a horizontal rainbow effect (2 hue increment)
//
// NOTE:  the fast_leds# are not displayed. Rather they are copied to leds# which are displayed.

{


	int adr = 0;
	int adr2 = 0;
	int hue = 0;
	int hue_increment = 255 / (depth + 1);
	byte rv = 0;

	int num2show = depth * NUM_ROWS;

	int x_count = 0; // keep track of x starting from 0

	//fast_leds1[MODIFIY_FAST_ADR(0)] = CHSV(hues[clr], 255, 255);

	//******************************** make G_SHOW_fast_row_offset move up to  +(NUM_ROWS-1)  and down to -(NUM_ROWS-1)
	if (G_row_direction == 1)
	{
		++G_SHOW_fast_row_offset; // keep track of how many time SHOW_fast() is called
	}

	if (G_row_direction == 0)
	{
		--G_SHOW_fast_row_offset; // keep track of how many time SHOW_fast() is called
	}

	if (G_SHOW_fast_row_offset == NUM_ROWS - 1)
	{
		G_row_direction = 0;
	}

	if (G_SHOW_fast_row_offset == (-1) * (NUM_ROWS - 1))
	{
		G_row_direction = 1;
	}
	//**********************************


	for (int x = NUM_COLUMNS - 1; x >= (NUM_COLUMNS - depth); x = x - 1)
	{


		if ((depth_effect == 0) || (depth_effect == 3) || (depth_effect == 4) || (depth_effect == 5))  // simple copy 
		{

			for (int y = 0; y < NUM_ROWS; ++y)
			{
				adr = XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);  // upside down

				leds1[adr2] = fast_leds1[y];
				leds3[adr2] = fast_leds3[y];


				// good
				//leds2[adr] = fast_leds1[y];  // note this also works
				//leds4[adr] = fast_leds3[y];

				leds2[adr2] = fast_leds2[y];  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
				leds4[adr2] = fast_leds4[y];

				//Serial.println(F("TEST 40"));
				//Serial.print(F("x="));
				//Serial.println(x);
				//Serial.print(F("y="));
				//Serial.println(y);
				//Serial.print(F("adr="));
				//Serial.println(adr);

				//Serial.print(F("fast_leds1[y].r="));
				//Serial.println(fast_leds1[y].r);
				//Serial.print(F("fast_leds1[y].g="));
				//Serial.println(fast_leds1[y].g);
				//Serial.print(F("fast_leds1[y].b="));
				//Serial.println(fast_leds1[y].b);
				//Serial.print(F("y="));
				//Serial.println(y);
				//Serial.print(F("adr="));
				//Serial.println(adr);



			}
		}



		if (depth_effect == 1) // shift inner leds down by one
		{
			int y_new = 0; // shifted y value


			for (int y = 0; y < NUM_ROWS; ++y)
			{
				byte turn_off_flag = 0; // set to 1 if LEDs are not to be shown because they shifted off the panel : y<0

				y_new = y - x_count;
				//y_new = y ;

				if (y_new < 0)
				{
					y_new = 0;
					turn_off_flag = 1;
					//	turn_off_flag = 0;
				}

				adr = XY_ADR(x, y_new);
				//adr = GET_XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);  // upside down

				if (turn_off_flag == 0)
				{
					leds1[adr2] = fast_leds1[y];
					leds3[adr2] = fast_leds3[y];

					leds2[adr2] = fast_leds2[y];  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
					leds4[adr2] = fast_leds4[y];
				}
				else  // turn_off_flag=1,  don't show LEDs
				{
					leds1[adr2] = 0;
					leds3[adr2] = 0;

					leds2[adr2] = 0;  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
					leds4[adr2] = 0;
				}



			}

		}

		///////////////
		if (depth_effect == 2) // shift inner leds up by one
		{
			int y_new = 0; // shifted y value


			for (int y = 0; y < NUM_ROWS; ++y)
			{
				byte turn_off_flag = 0; // set to 1 if LEDs are not to be shown because they shifted off the panel : y<0

				y_new = y + x_count;
				//y_new = y ;

				if (y_new >= NUM_ROWS)
				{
					y_new = NUM_ROWS - 1;
					turn_off_flag = 1;
					//	turn_off_flag = 0;
				}

				adr = XY_ADR(x, y_new);
				//adr = GET_XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);  // upside down

				if (turn_off_flag == 0)
				{
					leds1[adr2] = fast_leds1[y];
					leds3[adr2] = fast_leds3[y];

					leds2[adr2] = fast_leds2[y];  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
					leds4[adr2] = fast_leds4[y];
				}
				else  // turn_off_flag=1,  don't show LEDs
				{
					leds1[adr2] = 0;
					leds3[adr2] = 0;

					leds2[adr2] = 0;  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
					leds4[adr2] = 0;
				}



			}

		}

		///////////////
		//if (depth_effect == 3) // alternate shift inner leds up by one and down by one
		//{
		//	
		//	//G_active_column
		//	//G_column_0_count


		//	if (G_column_0_count == 5)  // G_column_0_count is incremented each time DISPLAY_TEXT shows a column 1
		//	{
		//		G_column_0_count = 1;
		//	}


		//	if ((G_column_0_count == 1)||(G_column_0_count == 3))  // no shift
		//	{
		//		for (int y = 0; y < NUM_ROWS; ++y)
		//		{
		//			adr = XY_ADR(x, y);
		//			//adr = GET_XY_ADR(x, y);
		//			adr2 = modify_adr(0, 0, adr);  // upside down

		//			leds1[adr2] = fast_leds1[y];
		//			leds3[adr2] = fast_leds3[y];

		//			leds2[adr2] = fast_leds2[y];  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
		//			leds4[adr2] = fast_leds4[y];

		//		}
		//	}


		//	if (G_column_0_count == 2)  // shift down
		//	{
		//		int y_new = 0; // shifted y value


		//		for (int y = 0; y < NUM_ROWS; ++y)
		//		{
		//			byte turn_off_flag = 0; // set to 1 if LEDs are not to be shown because they shifted off the panel : y<0

		//			y_new = y - x_count;
		//			//y_new = y ;

		//			if (y_new < 0)
		//			{
		//				y_new = 0;
		//				turn_off_flag = 1;
		//				//	turn_off_flag = 0;
		//			}

		//			adr = XY_ADR(x, y_new);
		//			//adr = GET_XY_ADR(x, y);
		//			adr2 = modify_adr(0, 0, adr);  // upside down

		//			if (turn_off_flag == 0)
		//			{
		//				leds1[adr2] = fast_leds1[y];
		//				leds3[adr2] = fast_leds3[y];

		//				leds2[adr2] = fast_leds2[y];  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
		//				leds4[adr2] = fast_leds4[y];
		//			}
		//			else  // turn_off_flag=1,  don't show LEDs
		//			{
		//				leds1[adr2] = 0;
		//				leds3[adr2] = 0;

		//				leds2[adr2] = 0;  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
		//				leds4[adr2] = 0;
		//			}



		//		}
		//	}


		//	if (G_column_0_count == 4)  // shift up
		//	{
		//		int y_new = 0; // shifted y value
		//		
		//		for (int y = 0; y < NUM_ROWS; ++y)  // shift up by one
		//		{
		//			byte turn_off_flag = 0; // set to 1 if LEDs are not to be shown because they shifted off the panel : y<0

		//			y_new = y + x_count;
		//			//y_new = y ;

		//			if (y_new >= NUM_ROWS)
		//			{
		//				y_new = NUM_ROWS - 1;
		//				turn_off_flag = 1;
		//				//	turn_off_flag = 0;
		//			}

		//			adr = XY_ADR(x, y_new);
		//			//adr = GET_XY_ADR(x, y);
		//			adr2 = modify_adr(0, 0, adr);  // upside down

		//			if (turn_off_flag == 0)
		//			{
		//				leds1[adr2] = fast_leds1[y];
		//				leds3[adr2] = fast_leds3[y];

		//				leds2[adr2] = fast_leds2[y];  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
		//				leds4[adr2] = fast_leds4[y];
		//			}
		//			else  // turn_off_flag=1,  don't show LEDs
		//			{
		//				leds1[adr2] = 0;
		//				leds3[adr2] = 0;

		//				leds2[adr2] = 0;  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
		//				leds4[adr2] = 0;
		//			}



		//		}
		//	}

		//}



		if (depth_effect == 3)  // generate a horozontal rainbow effect
		{
			HUE_CYCLE_HOZ(0, 5, 0);
		}


		if (depth_effect == 4)  // generate a vertical rainbow effect
		{
			HUE_CYCLE_VERT(0, 5, 0);
		}


		if (depth_effect == 5)  // rotate colors
		{
			ROTATE_COLORS(1);
		}

		if (depth_effect == 6)  // generate a vertical rainbow effect 
		{
			HUE_CYCLE_VERT(0, 2, 0);
		}

		///////////////
		if (depth_effect == 7) // animate outside shift up and down
		{
			int y_new = 0; // shifted y value


			for (int y = 0; y < NUM_ROWS; ++y)
			{

				//y_new = y + x_count;
				y_new = y + G_SHOW_fast_row_offset;

				if (y_new >= NUM_ROWS)  // roll to bottom of screen
				{
					y_new = y_new - NUM_ROWS;

				}


				if (y_new < 0)
				{
					y_new = NUM_ROWS + y_new;

				}


				adr = XY_ADR(x, y_new);
				//adr = GET_XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);  // upside down


				leds1[adr2] = fast_leds1[y];
				leds3[adr2] = fast_leds3[y];

				leds2[adr2] = fast_leds2[y];  // note: adr2 is correct as the data in fast_leds2 and fast_leds4 is already upside down
				leds4[adr2] = fast_leds4[y];




			}

		}

		++x_count;

	}

	//Serial.println(F(""));
	//Serial.println(F("SHOW_fast"));
	//adr = GET_XY_ADR(21, 0);
	//Serial.print(F("21="));
	//Serial.println(leds1[adr].r);
	//adr = GET_XY_ADR(20, 0);
	//Serial.print(F("20="));
	//Serial.println(leds1[adr].r);
	//Serial.println(F(""));


	//unsigned long current_time = millis();
	//unsigned long delta = current_time - G_system_time;
	//unsigned long delay = 500;  // half second
	//byte BT_waiting = 0;

	//if (delta > delay)
	//{
	//	G_system_time = millis();
	//	BT_waiting = SerialBT.available();
	//}


	rv = SHOW_var(num2show);
	return rv;



}


///******************************************************************************************************************/
//void SHOW_fast()  // display the minimum number of LEDs
//{
//
//	if (G_active != NUM_LEDS_FAST) // if current set to SLOW LEDs
//	{
//		SET_FAST();
//		//G_active = NUM_LEDS_FAST;
//	}
//
//
//	for (int n = 0; n < NUM_LEDS_FAST; ++n)
//	{
//		leds1[n] = fast_leds1[n];
//		leds2[n] = fast_leds2[n];
//		leds3[n] = fast_leds3[n];
//		leds4[n] = fast_leds4[n];
//	}
//
//
//	FastLED.show();
//	//	controllers[1]->showLeds();
//
//
//
//}

/******************************************************************************************************************/
byte SHOW_var(int num)  // display a variable number of LEDs
{
	// return 1 if there was an interrupting BT command

	byte checkBTcount = 20;  // number of times SHOW_var is called prior to checking for BT, was 20

	if (G_SKIP_BTCH == 0)
	{
		++G_SHOW_var_COUNT;

		if (G_SHOW_var_COUNT == checkBTcount)
		{
			G_SHOW_var_COUNT = 0;

			if (G_BT_message_flag == 0)
			{
				G_BT_message_flag = CHECK_BLUE_TOOTH();  // get BT command

			}
		}
	}

	if (G_active != num) // if current set to SLOW LEDs
	{
		SET_VAR(num);  // set to display to a variable number of LEDs
		//	G_active = num;
	}


	//	if (G_BT_data_arrival == 0)  // allow for BT interrupt
	if (G_BT_message_flag == 0)
	{
		//G_dim = 0;  /// test only
		//Serial.print(F(" SHOW_var: G_dim="));
		//Serial.println(G_dim);
		//Serial.println("");


		DIM_VAR_LEDS(G_dim, num);  // dim a variable number of LEDs

		FastLED.show();
		//delayMicroseconds(300);  // this is necessary to prevent false colors and pixels during a FLASH draw, note:200us is too small
		//	controllers[1]->showLeds();
	}
	else   // needed to make sure PLAY SAVES switch reliably turns of PLAYSAVES moded when TEXT is showing
	{

		//G_PLAY_SAVES_MODE_ON = 0;
		TURN_OFF_PLAY_SAVES_MODE();
		BLUE_TOOTH_COMMAND_HANDLER(1);
		return 1;


		//	SIGNAL(171, 8);
		//	delay(1000);
	}

	return 0;

}

/******************************************************************************************************************/






/******************************************************************************************/
void MAP_FONT_ARRAY()  // map the bitmap array and store the index for each bitmap, the array position is the bitmap number starting with #1
{
	int ind = 0;
	int type = 0;
	int bmp = 0;
	int H_led_adr = 0;

	while (type != 253)
	{
		++bmp;
		FONT_MAP[bmp] = ind;   // point to TYPE	

		type = pgm_read_byte_near(font_TEXT + ind);   // type=   255= full bitmap, 254=differential bitmap, 253= end of BMP_array

		//Serial.print("*****************");
		//Serial.print("MAP_ARRAY:");
		//Serial.print("TYPE=");
		//Serial.println(type);

		if (type == 255)  //full bit map thus read RGB data
		{
			ind = ind + (3 * NUM_LEDS) + 1;  // note +1 accounts for SPEED entry
		}

		if (type == 254)  // differential bitmap
		{

			ind = ind + 2;  // point to high byte address
			H_led_adr = pgm_read_byte_near(font_TEXT + ind);  // high byte of LED adr

			//Serial.print("ind=");
			//Serial.println(ind);
			//Serial.print("H_led_adr=");
			//Serial.println(H_led_adr);

			while (H_led_adr < 3)  // i.e. not a TYPE
			{
				ind = ind + 5; // skip to ntex H_led_adr
				H_led_adr = pgm_read_byte_near(font_TEXT + ind);  // high byte of LED adr
			}

		}
	}
	FONT_MAP[0] = bmp - 1;   // store the total number of bitmaps at position 0

	//Serial.print("BMP_MAP[0]=");
	//Serial.println(BMP_MAP[0]);
	//Serial.print("*******DONE with MAP******");
}

/******************************************************************************************/
void MAP_BMP_ARRAY()  // map the bitmap array and store the index for each bitmap, the array position is the bitmap number starting with #1
{
	int ind = 0;
	int type = 0;
	int bmp = 0;
	int H_led_adr = 0;

	while (type != 253)
	{
		++bmp;
		BMP_MAP[bmp] = ind;   // point to TYPE	

		type = pgm_read_byte_near(image_TEXT + ind);   // type=   255= full bitmap, 254=differential bitmap, 253= end of BMP_array

		//Serial.print("*****************");
		//Serial.print("MAP_ARRAY:");
		//Serial.print("TYPE=");
		//Serial.println(type);

		if (type == 255)  //full bit map thus read RGB data
		{
			ind = ind + (3 * NUM_LEDS) + 1;  // note +1 accounts for SPEED entry
		}

		if (type == 254)  // differential bitmap
		{

			ind = ind + 2;  // point to high byte address
			H_led_adr = pgm_read_byte_near(image_TEXT + ind);  // high byte of LED adr

			//Serial.print("ind=");
			//Serial.println(ind);
			//Serial.print("H_led_adr=");
			//Serial.println(H_led_adr);

			while (H_led_adr < 3)  // i.e. not a TYPE
			{
				ind = ind + 5; // skip to ntex H_led_adr
				H_led_adr = pgm_read_byte_near(image_TEXT + ind);  // high byte of LED adr
			}

		}
	}
	BMP_MAP[0] = bmp - 1;   // store the total number of bitmaps at position 0

	//Serial.print("BMP_MAP[0]=");
	//Serial.println(BMP_MAP[0]);
	//Serial.print("*******DONE with MAP******");
}



//********************************************************************************************************************************************
//********************************************************************************************************************************************
void LOAD_BMP(int bmp1)   // load the same bmp into both panels
{
	FastLED.clear();  // set to black all LEDs..

	//Serial.println("CALLING LOAD_BMP_PANEL #1");
	//Serial.println("");
	LOAD_BMP_PANEL(bmp1, 1);

	//Serial.println("CALLING LOAD_BMP_PANEL #2");
	//Serial.println("");
	LOAD_BMP_PANEL(bmp1, 2);

	//Serial.println("CALLING LOAD_BMP_PANEL #3");
	//Serial.println("");
	LOAD_BMP_PANEL(bmp1, 3);

	//Serial.println("CALLING LOAD_BMP_PANEL #4");
	//Serial.println("");
	LOAD_BMP_PANEL(bmp1, 4);

	//Serial.println("LOAD_BMP: after all loads");
	//Serial.println("");

}

//********************************************************************************************************************************************
int LOAD_BMP_PANEL(int bmp, int panel)   // load the LED array into 1 panel,  with the passed bitmap number, bitmap numbers start with 1, panel = 1 or 2 or 3 or 4
{
	// note: if panel=5 --> load bmp into leds_buffer1,  panel=6 --> leds_buffer2

	int ind = 0;
	int H_led_adr = 0;
	int L_led_adr = 0;
	int bmp_speed = 1;

	int led_adr = 0;


	ind = BMP_MAP[bmp];  // point to TYPE

	//FastLED.clear();   // set to black all LEDs

	//type = pgm_read_byte_near(BMP_array + ind);   // type=   255= full bitmap, 254=differential bitmap, 253= end of BMP_array
	type = pgm_read_byte_near(image_TEXT + ind);   // type=   255= full bitmap, 254=differential bitmap, 253= end of BMP_array

	//Serial.println("position 0 ");
	//Serial.print("PANEL=");
	//Serial.println(panel);
	//Serial.print("bmp #=");
	//Serial.println(bmp);
	//Serial.print("TYPE index,  ind=");
	//Serial.println(ind);
	//Serial.print("TYPE=");
	//Serial.println(type);
	//Serial.println(" ");

	++ind;
	//bmp_speed = 4 * pgm_read_byte_near(BMP_array + ind);   // reads the speed of the bitmap and multiplys it by 4
	bmp_speed = 4 * pgm_read_byte_near(image_TEXT + ind);   // reads the speed of the bitmap and multiplys it by 4

	//noInterrupts();



	if (type == 255)  //full bit map thus read RGB data
	{

		//	Serial.print("bitmap");


		for (int adr = 0; adr < NUM_LEDS; ++adr)
		{

			if ((panel == 2) || (panel == 4) || (panel == 6))
			{
				//FLIP(1);   // flip G_upside_down
				G_upside_down = 0;

			}
			else
			{
				//FLIP(0);  // back to normal
				G_upside_down = 1;
			}


			led_adr = modify_adr(G_upside_down, H_led_adr, L_led_adr);   //make image right side up or upside down



			if (panel == 1)
			{
				++ind;
				leds1[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds1[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds1[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//Serial.println(" ");
				//Serial.println("position 1 ");
				//Serial.print("led_adr=");
				//Serial.println(led_adr);
				//Serial.print("leds1[led_adr].r=");
				//Serial.println(leds1[led_adr].r);
				//Serial.print("leds1[led_adr].g=");
				//Serial.println(leds1[led_adr].g);
				//Serial.print("leds1[led_adr].b=");
				//Serial.println(leds1[led_adr].b);
				//Serial.println(" ");

			}
			if (panel == 2)
			{
				++ind;
				leds2[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds2[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds2[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds2[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds2[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}
			}
			if (panel == 3)
			{
				++ind;
				leds3[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds3[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds3[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds3[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds3[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}
			}
			if (panel == 4)
			{
				++ind;
				leds4[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds4[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds4[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds4[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds4[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}
			}

			if (panel == 5)
			{
				++ind;
				leds_buffer1[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds1[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds1[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}
			}

			if (panel == 6)
			{
				++ind;
				leds_buffer2[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds1[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds1[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}
			}

		}

	}

	int kind = type;

	while (kind == 254) // differential bitmap
	{



		++ind;
		H_led_adr = pgm_read_byte_near(image_TEXT + ind);  // high byte of LED adr

		/*Serial.println("position 1 ");
		Serial.print("ind= ");
		Serial.println(ind);
		Serial.println("diff bitmap ");
		Serial.print("H_led_adr= ");
		Serial.println(H_led_adr);
		Serial.println(" ");*/

		if (H_led_adr <= 3)  // not a TYPE 
		{

			++ind;
			L_led_adr = pgm_read_byte_near(image_TEXT + ind); // low byte of LED adr

			if ((panel == 2) || (panel == 4) || (panel == 6))
			{
				//FLIP(1);   // flip G_upside_down
				G_upside_down = 0;

			}
			else
			{
				//FLIP(0);  // back to normal
				G_upside_down = 1;
			}



			led_adr = modify_adr(G_upside_down, H_led_adr, L_led_adr);   //make image right side up or upside down


			/*Serial.println("position 2 ");
			Serial.print("ind= ");
			Serial.println(ind);
			Serial.print("L_led_adr= ");
			Serial.println(L_led_adr);
			Serial.print("led_adr= ");
			Serial.println(led_adr);
			Serial.print("H_led_adr= ");
			Serial.println(H_led_adr);
			Serial.println(" ");*/



			if (panel == 1)
			{
				++ind;
				leds1[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds1[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds1[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds1[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds1[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}

				/*Serial.println("position 3: panel 1 ");
				Serial.print("ind= ");
				Serial.println(ind);
				Serial.print("led_adr= ");
				Serial.println(led_adr);
				Serial.print("leds1[led_adr].r= ");
				Serial.println(leds1[led_adr].r);
				Serial.print("leds1[led_adr].g= ");
				Serial.println(leds1[led_adr].g);
				Serial.print("leds1[led_adr].b= ");
				Serial.println(leds1[led_adr].b);
				Serial.print("H_led_adr= ");
				Serial.println(H_led_adr);
				Serial.println(" ");*/

			}
			if (panel == 2)
			{
				++ind;
				leds2[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds2[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds2[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds2[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds2[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}

				/*Serial.println("position 4: panel 2 ");
				Serial.print("ind= ");
				Serial.println(ind);
				Serial.print("led_adr= ");
				Serial.println(led_adr);
				Serial.print("leds2[led_adr].r= ");
				Serial.println(leds2[led_adr].r);
				Serial.print("leds2[led_adr].g= ");
				Serial.println(leds2[led_adr].g);
				Serial.print("leds2[led_adr].b= ");
				Serial.println(leds2[led_adr].b);
				Serial.print("H_led_adr= ");
				Serial.println(H_led_adr);
				Serial.println(" ");*/
			}
			if (panel == 3)
			{
				++ind;
				leds3[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds3[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds3[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds3[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds3[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}

				/*Serial.println("position 4: panel 2 ");
				Serial.print("ind= ");
				Serial.println(ind);
				Serial.print("led_adr= ");
				Serial.println(led_adr);
				Serial.print("leds2[led_adr].r= ");
				Serial.println(leds2[led_adr].r);
				Serial.print("leds2[led_adr].g= ");
				Serial.println(leds2[led_adr].g);
				Serial.print("leds2[led_adr].b= ");
				Serial.println(leds2[led_adr].b);
				Serial.print("H_led_adr= ");
				Serial.println(H_led_adr);
				Serial.println(" ");*/
			}
			if (panel == 4)
			{
				++ind;
				leds4[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds4[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds4[led_adr].b = pgm_read_byte_near(image_TEXT + ind);

				//leds4[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds4[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}

				/*Serial.println("position 4: panel 2 ");
				Serial.print("ind= ");
				Serial.println(ind);
				Serial.print("led_adr= ");
				Serial.println(led_adr);
				Serial.print("leds2[led_adr].r= ");
				Serial.println(leds2[led_adr].r);
				Serial.print("leds2[led_adr].g= ");
				Serial.println(leds2[led_adr].g);
				Serial.print("leds2[led_adr].b= ");
				Serial.println(leds2[led_adr].b);
				Serial.print("H_led_adr= ");
				Serial.println(H_led_adr);
				Serial.println(" ");*/
			}

			if (panel == 5)
			{
				++ind;
				leds_buffer1[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].b = pgm_read_byte_near(image_TEXT + ind);
			}

			if (panel == 6)
			{
				++ind;
				leds_buffer2[led_adr].r = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].g = pgm_read_byte_near(image_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].b = pgm_read_byte_near(image_TEXT + ind);
			}


		}
		else
		{
			kind = 0;   // leave the while loop
		}

	}
	//interrupts();
	//BOARD_SYNC();

//	FLIP(0);  // back to normal

	/*Serial.println("LEAVING LOAD_BMP_PANEL ");
	Serial.println("************************************ ");*/
	return bmp_speed;

}










/**************************************************************************************************************/
int MODIFIY_FAST_ADR(int adr)  // modify fast LED adr based on G_upside_down
{
	int reverse = abs(1 - G_upside_down);  // reverse it


	return abs((21 * reverse) - adr);  // note: 21=max number of FAST LEDs
}



/**************************************************************************************************************/
int GET_LED_ADR(int row, int col)   // find the address of the LED at the row and columnn
{
	int adr = 0; // address of the LED

	if ((col % 2) == 0)   // even column
	{
		//adr = (col*NUM_LEDS_FAST ) + row;
		adr = (col * (NUM_LEDS_FAST)) + row;
	}
	else  // odd column
	{
		//adr = NUM_LEDS_FAST * (col + 1) - (row + 1);
		adr = (NUM_LEDS_FAST) * (col + 1) - (row + 1);
	}

	return adr;
}



/**************************************************************************************************************/
void INC_HALL_COUNT()   // interrupt driven 
{
	++G_Hall_counts;


	unsigned long even = G_Hall_counts % 2;

	if (even == 0)  // send HALL signal to HEX base at half the HALL frequency
	{
		digitalWrite(Hall_out, HIGH);
	}
	else
	{
		digitalWrite(Hall_out, LOW);
	}

	//Hall_out

	// the below seems to cause a RESET()
	//if ((G_BT_message_flag == 0) && (G_SKIP_BTCH == 0))
	//{
	//	G_BT_message_flag = CHECK_BLUE_TOOTH();  // get BT command
	//}

}


/**************************************************************************************************************/
///Don: check if this can get stuck?

byte HALL_SYNC2()   // interrupt driven synchronization,  return 1 if wait time exceeds 130ms, otherwise return 0
{
	volatile unsigned long k = READ_HALL_COUNTS();
	volatile unsigned long time_stamp = millis();
	//volatile unsigned long MAX_WAIT_DELAY = 130;  // 130ms
	volatile byte rv = 0;
	volatile byte leave = 0;

#define MAX_WAIT_DELAY 130  // 130ms
#define MAX_SYNC_TIME 600 // equivalent to 100 RPM

	if (G_Hall_sync == 1)
	{
		while ((k == READ_HALL_COUNTS()) && (leave == 0))
		{
			if ((millis() - time_stamp) > MAX_SYNC_TIME)  // added to prevent endless loop if not rotating
			{
				leave = 1;
			}
		}

		if ((millis() - time_stamp) > MAX_WAIT_DELAY)
		{
			rv = 1;
		}

	}

	return rv;
}



///**************************************************************************************************************/
//unsigned long HALL_MEASURE3(int num)  // return time in mills , num=number of LEDs used to determing G_max_bins
//{
//	if (G_Hall_sync == 0)
//	{
//		G_max_bins = 10;  // could be any number... this is for testing
//		return 0;
//	}
//
//
//	unsigned long start_count = 0;
//	unsigned long time_interval = 0; // Note: G_time_interval decreases as rotation speed increases
//	byte max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution
//
//	HALL_SYNC2();
//	start_count = G_Hall_counts;
//	time_interval = millis(); // measure system time
//	//FastLED.clear();   // commented out on 2/27/21 as it cleared leds1 every loop cycle
//
//
//	while (start_count == G_Hall_counts)  // NOTE: next HALL interrupt increments G_Hall_counts
//	{
//		++max_flashes;
//		SHOW_var(num);
//		//SHOW_fast();
//
//	}
//
//
//	//G_max_timer_count = G_timer_count; // store the number of timer counts in one revolution
//
//	time_interval = millis() - time_interval;
//
//	if (G_special_char_select < 1000)// note >1000 is for displaying leds_saved
//	{
//		G_max_bins = max_flashes / G_letter_width;  // keep track of maximum number of letter bins per 
//	}
//	else  // each leds_saved is 11 wide
//	{
//		G_max_bins = max_flashes / 11;  // keep track of maximum number of letter bins per 
//	}
//
//	if (G_max_bins % 2 != 0) //G_max_bins must be even or else panel 1,2 text do not align with panel 3,4 text....because panels 3,4 are offset by G_max_bins/2
//	{
//		++G_max_bins;
//
//	}
//
//
//	return (time_interval);
//}






//**********************************************************
unsigned long READ_HALL_COUNTS()
// return an accurate value for G_Hall_counts
{
	//noInterrupts();
	//int count = G_Hall_counts;
	//interrupts();
	//return(count);
	unsigned long HC = G_Hall_counts;

	return(HC);
}


////******************************************************************************************
//void READ_BRIGHTNESS()
//// read the G_brightness from the pot
//{
//	G_bright = analogRead(sensorPin);
//
//	G_dim = 253 - (G_bright / 14);  // calculate dimmness based on pot positon, maximum value of G_bright I read was 3400
//
//	/*Serial.println(" ");
//	Serial.println("READ_BRIGHTNESS");
//	Serial.print("G_bright=");
//	Serial.println(G_bright);
//	Serial.print("G_dim=");
//	Serial.println(G_dim);
//	Serial.println(" ");*/
//
//
//}





//******************************************************************************************
void CLEAR_FONT_BUFFER()  // clear the BMP array
{
	CLEAR_FONT_BUFFER_1();
	CLEAR_FONT_BUFFER_2();

}

//******************************************************************************************
void CLEAR_FONT_BUFFER_1()  // clear the leds1 BMP array
{
	for (int n = 0; n < NUM_LEDS; ++n)
	{
		leds_buffer1[n].r = 0;
		leds_buffer1[n].g = 0;
		leds_buffer1[n].b = 0;
	}
}
//******************************************************************************************
void CLEAR_FONT_BUFFER_2()  // clear the leds2 BMP array
{
	for (int n = 0; n < NUM_LEDS; ++n)
	{
		leds_buffer2[n].r = 0;
		leds_buffer2[n].g = 0;
		leds_buffer2[n].b = 0;
	}
}



//******************************************************************************************
byte SCROLL_TEXT(char* text, int nts, int reps, int scroll_speed, int huey, int banner, byte wrap, byte depth, byte depth_effect)   // Alphabet text from the present G_bmp_num by slicing each column,  


// return 1 if interrupted by BT command																																	// if huey=-1=WHITE		
// wrap=1 to cause all bins to show around the display, otherwise only half the display shows text or images
// depth = display depth
// depth_effect = 0 for no effect
// depth_effects: 0 = no effect,  1= shift inner LEDs down 1, 2=shift inner LEDs up 1,
//				  3= generate a vertical rainbow effect,  4=generate a horizontal rainbow effect (5 hue increment),  5= swap colors  
//				  6=generate a horizontal rainbow effect (2 hue increment)
{
	//Serial.println(F("########  SCROLL_TEXT start  ########"));
	//Serial.print(F("text="));
	//Serial.println(text);
	//Serial.println(F(""));

	//if (G_Hall_sync == 0) { return 0; }
	if ((G_Hall_sync == 0) || (digitalRead(HEAD_COM) == 1)) { return 0; }

	byte jump2end = 0; // used to quickly exit 
	byte BT_interrupt = 0;

	if (G_skip_SCROLL_TEXT == 1)
	{
		return 0;
	}



	//G_allow_RESET = 0;  // don't allow a RESET

	//G_RESET = 0;  



	G_depth = depth; // set how many columns to dispaly

	G_column_0_count = 0;  // keep track of how many times G_active_column goes to 0

	G_UNDO_stored = 0; // flag that no images are stored in led_buffer1 or led_buffer2

	if ((G_AUTO_DIM == 1) && (G_AUTO_DIM_LEVEL > G_dim)) // only dim SLOW leds more if auto dim level is more than G_dim
	{
		DIM_SLOW_LEDS(G_AUTO_DIM_LEVEL);  // dim SLOW leds
		FastLED.show();
	}


	if ((G_AUTO_DIM == 1) && (G_AUTO_DIM_LEVEL <= G_dim)) // dim more than the G_AUTO_DIM_LEVEL
	{
		//int max_delta = G_dim - G_AUTO_DIM_LEVEL;
		int max_delta = 255 - G_dim;

		DIM_SLOW_LEDS(G_dim + max_delta / 2);  // dim even more
		FastLED.show();
	}

	//HALL_MEASURE3(G_depth*NUM_ROWS);   // find G_max_bins...this was used prior to the line below


	//CALCULATED_MAX_FLASHES(G_depth*NUM_ROWS);  // returns calculate G_max_flashes and G_max_bins based on number of LEDs

	//if (G_execute_CREATE_mode == 1) // this insures that CREATE mode is entered even if MASTER is in control
	//{
	//	G_execute_CREATE_mode = 0; 

	//	// the DC below shouldn't be necessary as it is handled in the BTCH
	//	DC_OUT_array[0] = 7;  // turn on CREATE mode
	//	DC_OUT_array[1] = 0;  // no meaning
	//	DC_SEND();

	//	return ;
	//}

	// the following allows for a quick abort of MASTER mode if entering CREATE mode
	// I'm not certan the below is needed
	G_BT_message_flag = CHECK_BLUE_TOOTH();
	if (G_BT_message_flag == 1)
	{

		BLUE_TOOTH_COMMAND_HANDLER(1);
		if (G_do_CREATE_mode == 1)
		{
			//		G_allow_RESET = 1;  //  allow a RESET
			return 1;
		}
	}

	//	if (G_BT_data_arrival==1){return;}


		//HALL_MEASURE3(G_depth*NUM_ROWS);   // find G_max_bins...this was used prior to the line below: NOTE ***  This is the main HALL sychronization for the SCROLL function   ****
		//CALCULATED_MAX_FLASHES(G_depth*NUM_ROWS);  // returns calculate G_max_flashes and G_max_bins based on number of LEDs


	////////////////////////////////////////////prior to 070524
	//CALCULATED_MAX_FLASHES(depth * NUM_ROWS);
	//HALL_SYNC2();

	/////////////////////////  alternative to above ///////////////////   EXPERIMENTAL 070524
	HALL_MEASURE2(depth * NUM_ROWS);
	CALCULATED_MAX_BINS();


	////////////////

	//G_max_bins = 14;   // ******************   for debug only


	int adr = 0;
	int banner_time = 5;
	int clr = 0;
	int start_index = 0;
	int copy_length = 0;
	//int start_count = 0;
	byte drop_flag = 0;  // set to 1 if a letter is dropped
	int adr_offset = 0;  // this offset is calculated from G_max_bins and is used to sychronize panels 3,4 text to panels 1,2

	//CLEAR_FAST_LEDS();

	//for (int n = 0; n < NUM_LEDS_FAST; ++n)  // these aren't LEDs but are virtual LEDs as they get copied into LEDS1..4
	//{
	//	fast_leds1[n] = 0;
	//	fast_leds2[n] = 0;
	//	fast_leds3[n] = 0;
	//	fast_leds4[n] = 0;
	//}
	//CLEAR_VAR_LEDS(G_depth*NUM_ROWS);
	//SHOW_var(G_depth*NUM_ROWS);
	//SHOW_fast(G_depth);



	//if (G_AUTO_DIM == 1)  // dim SLOW display
	//{
	//	DC_OUT_array[0] = 26;  // DIM LEDs
	//	DC_OUT_array[1] = G_DIMMED;
	//	DC_SEND();

	//}

	// clear out un-used portions of text to prevent old letters from showing when displaying shorter text than before
	for (int n = nts; n < MAX_TEXT_DISPLAYED; ++n)
	{
		text[n] = ' ';  // note: text comes into the function SCROLL_TEXT
	}

	for (int r = 0; r < reps; ++r)
	{
		if (jump2end == 0)
		{
			for (int n = 0; n < NUM_LEDS_FAST; ++n)  // these aren't LEDs but are virtual LEDs as they get copied into LEDS1..4
			{
				fast_leds1[n] = 0;
				fast_leds2[n] = 0;
				fast_leds3[n] = 0;
				fast_leds4[n] = 0;
			}
			CLEAR_VAR_LEDS(G_depth * NUM_ROWS);
			SHOW_var(G_depth * NUM_ROWS);


			int max_len = G_max_bins; // new means to calculate max_len, G_max_bins comes from HALL_MEASURE3(22)
			//int max_len = G_max_bins-4;  // new means to calculate max_len, G_max_bins comes from HALL_MEASURE3(22)


			adr_offset = G_max_bins / 2;   // G_max_bins comes from HALL_MEASURE3

			if (max_len < 1) { max_len = 2; }
			//if (max_len >= MAX_BINS) { max_len = MAX_BINS - 1; }
			if (max_len >= MAX_BINS) { max_len = MAX_BINS - 2; }


			//int stringSize = strlen(myStrings[0]);

			int tot_len = nts + max_len;  // by adding max_len to nts, I guarantee the last letter scrolls off the display

			if (tot_len % 2 != 0) //G_max_bins must be even or else panel 1,2 text do not align with panel 3,4 text....because panels 3,4 are offset by G_max_bins/2
			{
				--tot_len;
			}

			for (byte n = 0; n < MAX_BINS; ++n)
			{
				bined_TEXT[n] = ' ';
				bined_TEXT2[n] = ' ';  // for panels 3 and 4
				//	bined_TEXT2[n] = 'W';  // for panels 3 and 4...................for testing only
			}


			//for (int j = 0; j<nts ; ++j)  // for counter clockwise motor direction; 
			//for (int j = 0; j < tot_len; ++j)  // for clockwise motor direction; 
			for (int j = 0; j < tot_len-1; ++j)  // for clockwise motor direction, 6/22/24 = subtract 1 from tot_len to allow time for HALL_SYNC2 at end
			{

				if (jump2end == 0)
				{
					for (int repeats = 0; repeats < scroll_speed; ++repeats)
					{
						if (jump2end == 0)
						{
							//HALL_SYNC2();  // -------------> experimental

							//?FastLED.clear();  // set to black all LEDs  // I added these two lines to prevent letter bleeding when a new bitmap was loaded, it works but creates spaces between every bitmap
							//?FastLED.show();
							//?HALL_SYNC2();


							//////////////     NEW CODE   ///////////////////

							// clear the binded_TEXT array
							//for (byte n = 0; n < MAX_BINS; ++n)
							//{
							//	bined_TEXT[n] = '\0';
							//	bined_TEXT2[n] = '\0';  // for panels 3 and 4
							//	bined_TEXT2[n] = 'W';  // for panels 3 and 4...................for testing only
							//}

							copy_length = j;

							if (copy_length >= max_len)
							{
								start_index = copy_length - max_len;  // change the first letter to be displayed by dropping pervious first letter
								copy_length = max_len;
								drop_flag = 1; // flag dropping letter

							}
							else
							{
								start_index = 0;
								drop_flag = 0;
							}

							adr = 0;

							//for (int n = start_index + copy_length - 1; n >= start_index; n--)   // stuff the bined_TEXT array
							for (int n = start_index + copy_length - 1; n >= start_index; n--)   // stuff the bined_TEXT array...counting backwards

							{
								bined_TEXT[adr] = text[n];   //  load bined_TEXT array for panels 1,2
								//bined_TEXT2[adr + adr_offset] = text[n];  // sychronize panels 3,4 with panels 1,2


								if (adr >= adr_offset)  // check for wrap past magnet
								{
									bined_TEXT2[adr - adr_offset] = text[n];  // sychronize panels 3,4 with panels 1,2
									//bined_TEXT2[adr - adr_offset] = 'W';   // 2nd half of the wrap: 0 to G_max_bins/2
								}
								else
								{
									bined_TEXT2[adr + adr_offset] = text[n];  // sychronize panels 3,4 with panels 1,2
									//bined_TEXT2[adr + adr_offset] = 'W';    // first half of the wrap
								}

								if ((adr >= adr_offset) && (wrap == 0)) // check for wrap past magnet and blank panel 3,4 text if wrap==0 
								{
									bined_TEXT2[adr - adr_offset] = ' ';  // sychronize panels 3,4 with panels 1,2
									//bined_TEXT2[adr - adr_offset] = 'W';   // 2nd half of the wrap: 0 to G_max_bins/2
								}

								++adr;  // scan through the bined_TEXT array
							}

							//for (int fadr = 0; fadr < G_max_bins/2; ++fadr)  // for testing only  ... displays 2nd half of wrap
							//{
							//	//bined_TEXT2[fadr] = 'W';
							//	bined_TEXT2[fadr] = text[fadr];
							//}


							// *****************  The following controls how far the letters scroll before the are no longer displayed  *********************************
							int last_position = 5; // this defines the position/bin of the last letter at which point I want to exit the main loop...was 5
							int min_letters = 4;

							// below shortens the text display time by detecting when the last letter to be displayed has reached the last_position I want to see it at
							if ((j > nts) && (bined_TEXT[last_position] == text[nts - 1]) && (nts >= min_letters))
							{
								j = tot_len;  // force loop exit
							}

							if ((j > nts) && (bined_TEXT[last_position] == text[nts - 1]) && (nts < min_letters))
							{
								tot_len = tot_len - min_letters;  // force loop exit after min_letters scrolls out
							}
							//******************************************************************************************************************************************


							//////////TESTING ONLY//////////////////////////
							//for (int nn = 0; nn < max_len; nn=nn+2)  // for testing only
							//{
							//	bined_TEXT[nn] = '*';
							//	bined_TEXT[nn + 1] = '%';
							//	
							//	
							//	bined_TEXT2[nn] = '*';
							//	bined_TEXT2[nn+1] = '%';
							//}
							//////////////////end of testing only  ///////////////

						//	Serial.println(F("########  SCROLL_TEXT before DISPLAY_TEXT_ARRAY  ########"));
							//Serial.print(F("bined_TEXT="));
							//Serial.println(bined_TEXT);
							//Serial.print(F("bined_TEXT2="));
							//Serial.println(bined_TEXT2);
							//Serial.println(F(""));




							BT_interrupt = DISPLAY_TEXT_ARRAY(bined_TEXT, bined_TEXT2, max_len, scroll_speed, huey, banner, wrap, depth_effect);

							//	 Serial.println(F("########  SCROLL_TEXT after DISPLAY_TEXT_ARRAY  ########"));

							if ((G_BT_message_flag != 0) || (BT_interrupt == 1)) // terminate SCROLL_TEXT if BT message available
							{

								jump2end = 1;
								//	TURN_ON_CREATE_MODE();   // added 8/15/22
							}

							//if (G_BT_data_arrival==1) // make RESET during SCROLL text work correctly
							//{
							//	j = tot_len;  // force loop exit;
							//}  

							//if (G_RESET == 1)
							//{
							//	return;
							//}
						}

					}
				}


			}

			////////////////////////////////////// new HALL SYNC delay added 6/22/24////////
			/* I added below in an attempt to better sychronize the text display. Below re-sychronizes to the HALL sensor before starting a new TEXT display
			The below waits after a TEXT display until the HALL sensor registers a new HALL count. Note: I don't have clear proof that this makes a difference.*/
			
		//	CLEAR_VAR_LEDS(G_depth* NUM_ROWS);   // this is necessary to prevent streaking after text shows
		//	FastLED.show();
		//	HALL_SYNC2();  

			// NOTE: as of 070524 I added a HALL_MEASURE2 at the start of SCROLL_TEXT which sychronizes. Thus this end time fill is not necessary.

			////////////////////////////////////////////////////////////////////////////////


		}
	}

	// this is where jump2end goes to

	jump2end = 0;


	CLEAR_VAR_LEDS(G_depth * NUM_ROWS);   // this is necessary to prevent streaking after text shows


	if (G_AUTO_DIM == 1)
	{
		DIM_SLOW_LEDS(G_dim);  // restore brightness
		FastLED.show();
	}
	else   // to prevent streaking
	{

		FastLED.show();

	}

	if (BT_interrupt > 0)
	{
		return 1;
	}
	else
	{
		return 0;
	}

	//if (G_AUTO_DIM == 1)  // dim SLOW display
	//{
	//	DC_OUT_array[0] = 26;  // restore SLOW LEDs to previous brightness
	//	DC_OUT_array[1] = G_DIM;
	//	DC_SEND();
	//}

//	G_allow_RESET = 1; // allow reset to occur



}

/////////////////////////////////////////////////////////////////////////////
//  convert passed text at index d to bmp number
int TEXT2BMP(char* text, int d, int panel)
// panel=1 for panels 1,2   panel=2 for panels 3,4
// if G_special_char_select=1001 will return 1001 for first 11 columns and 2001 for last 11 columns...same for G_special_char_select=1002,1003,1004,1005
// if G_special_char_select>1000 then '*'=first 11 columns of leds_saved
// if G_special_char_select>1000 then '%'=last 11 columns of leds_saved
{



	if (SERIAL_MON == 1)
	{
		// IMPORTANT NOTE:  if the Serial.prints are enabled below then TEXT or GRAPHICS will streak
		//Serial.println(F(".............  TEXT2BMP  ..........."));
		//Serial.print(F("text="));
		//Serial.println(text);
		//Serial.print(F("G_special_char_select="));
		//Serial.println(G_special_char_select);
		//Serial.print(F("d="));
		//Serial.println(d);
		//Serial.print(F("panel="));
		//Serial.println(panel);
		//Serial.println(F(""));
	}




	int bmp = 0;

	if (G_uppercase == 1)  // convert letters to upper case
	{
		if ((text[d] > 96) && (text[d] < 123))
		{
			text[d] = text[d] - 32; // convert to upper case
		}
	}

	if (text[d] < 58) // NUMBERS, 9 = 57 ascii, 0=48 ascii
	{
		bmp = (text[d] - 48) + 27; // 27=bitmap number 0
	}
	else
	{
		bmp = text[d] - 64;   // LETTERS: convert from ASCII to numeric
	}
	if (text[d] == 63)
	{
		bmp = 37; // QUESTION mark, 37 = bitmap number
	}
	if (text[d] == 46)
	{
		bmp = 38; // PERIOD, 38 = bitmap number
	}
	if (text[d] == 33) // !
	{
		bmp = 39; // EXCLAMATION, 39 = bitmap number
	}
	//*********** custom 11 pixel wide image  ******************************
	if (text[d] == 42) // * = first half of saved image
	{
		if (G_special_char_select == 0) { bmp = 40; } // RAINBOW}
		if (G_special_char_select == 1) { bmp = 45; } // STAR}

		if ((G_special_char_select > 1000) && (G_special_char_select < 3000)) // leds_saved[][] or stored image (note: stored images 1st half >3000)
		{
			bmp = G_special_char_select;  // in this case G_special_char_select defines the BMP, first half saved images = 1-->1001, 2-->1002
			//  first half of predefined images = 1-->3001, 2-->3002
		}

		if (G_special_char_select == 3000)
		{
			bmp = BMP_LOOKUP_ARRAY[0];
			G_2nd_half_flag = 0;
		}

		//G_bmp_num = 70;
	}


	//*********** custom 11 pixel wide image  ******************************
	if (text[d] == 37) // % = 2nd half of leds_saved image
	{
		if (G_special_char_select == 0) { bmp = 41; }// FLOWER
		if (G_special_char_select == 1) { bmp = 46; } //candy cane }

		if ((G_special_char_select > 1000) && (G_special_char_select < 3000))  // leds_saved[][] or stored image or stored image (note: stored image 2nd half >2000)
		{
			bmp = G_special_char_select + 1000;  // 2nd half of saved images = 1-->2001, 2-->2002
			// 2nd half of predefined images = 1-->4001, 2-->4002
		}

		if (G_special_char_select == 3000)
		{
			bmp = BMP_LOOKUP_ARRAY[0];
			G_2nd_half_flag = 1;
		}
	}

	//*********** custom 11 pixel wide image  ******************************
	if (text[d] == 35) // #
	{
		if (G_special_char_select == 0) { bmp = 42; } // egg
		if (G_special_char_select == 1) { bmp = 47; } // XMAS TREE}

		if ((G_2nd_saved_image > 1000) && (G_2nd_saved_image < 3000)) // leds_saved[][] or stored image (note: stored images 1st half >3000)
		{
			bmp = G_2nd_saved_image;  // in this case G_special_char_select defines the BMP, first half saved images = 1-->1001, 2-->1002
			//  first half of predefined images = 1-->3001, 2-->3002
		}

		if (G_special_char_select == 3000)  // stored image
		{
			bmp = BMP_LOOKUP_ARRAY[1];
			G_2nd_half_flag = 0;
		}
	}

	//*********** custom 11 pixel wide image  ******************************
	if (text[d] == 94) // ^ = 2nd half of leds_saved image
	{
		if (G_special_char_select == 0) { bmp = 43; } // bunny
		if (G_special_char_select == 1) { bmp = 48; } // Flower}

		if ((G_2nd_saved_image > 1000) && (G_2nd_saved_image < 3000))  // leds_saved[][] or stored image or stored image (note: stored image 2nd half >2000)
		{
			bmp = G_2nd_saved_image + 1000;  // 2nd half of saved images = 1-->2001, 2-->2002
			// 2nd half of predefined images = 1-->4001, 2-->4002
		}

		if (G_special_char_select == 3000)  // stored image
		{
			bmp = BMP_LOOKUP_ARRAY[1];
			G_2nd_half_flag = 1;
		}
	}

	//*********** custom 11 pixel wide image  ******************************
	if (text[d] == 126) // ~
	{
		if (G_special_char_select == 0) { bmp = 44; } // heart
		if (G_special_char_select == 1) { bmp = 49; } // RAINBOW}
	}

	if ((text[d] == 42) || (text[d] == 37) || (text[d] == 35) || (text[d] == 94) || (text[d] == 126))   // either * or % or # or ^ or ~
	{
		//G_letter_width = G_num_col;

		if (panel == 1)
		{

			if (G_char_width_flag12 >= 2)
			{
				G_char_width_flag12 = 0;
			}

			++G_char_width_flag12;

			//if (G_char_width_flag12 == 1)
			//{
			//	G_char_width_flag12 = 2;  // indicate previous image was double width and now we need to display the 2nd half
			//}
			//if (G_char_width_flag12 == 0)
			//{
			//	G_char_width_flag12 = 1;  // indicate character is double width and now need to display the 1st half
			//}
		}
		if (panel == 2)
		{

			if (G_char_width_flag34 >= 2)
			{
				G_char_width_flag34 = 0;
			}

			++G_char_width_flag34;

			//if (G_char_width_flag34 == 1)
			//{
			//	G_char_width_flag34 = 2;  // indicate previous image was double width and now we need to display the 2nd half
			//}

			//if (G_char_width_flag34 == 0)
			//{
			//	G_char_width_flag34 = 1;  // indicate previous image was double width and now we need to display the 2nd half
			//}
		}

	}
	else
	{
		//G_letter_width = 6;

		if (panel == 1)
		{
			G_char_width_flag12 = 0;
		}
		if (panel == 2)
		{
			G_char_width_flag34 = 0;
		}
	}
	//***********************************************************************

	if (text[d] == 32)  // SPACE
	{
		bmp = 0;

		//++G_hue_select;  // cycle though HUE space
		//if (G_hue_select > MAX_HUES)
		//{
		//	G_hue_select = 0;
		//}
	}



	return bmp;
}


//////////////////////////////////////////////////////////////////////////
// display text... text2 is the panel 3,4 sychronized text
byte DISPLAY_TEXT_ARRAY(char* text, char* text2, int max_len, int scroll_speed, int huey, int banner, byte wrap, byte depth_effect)  // display max_len number of text in the text
{
	// return 1 if there was a BT interrupt
	// "text" is displayed on panels 1 and 2, "text2" is displayed on panels 3 and 4
	// depth_effect is effect to apply at display depth>1

	// wrap =1 to force no bin cutoff on display
	// there are 6 banners 0 to 5
	// if G_special_char_sel = 1000

	if ((G_Hall_sync == 0) || (digitalRead(HEAD_COM) == 1)) { return 0; }


	int clr = 0;
	int banner_time = 0;
	int bmp2 = 0; // bitmap for panels 3,4
	int last_bin_displayed = (G_max_bins / 2);  // sets how many visible letters will be displayed after the half way point
	int col_12 = 0;
	int col_34 = 0;
	unsigned long hall_count = G_Hall_counts;  // hold last hall count
	//byte active_bins12_array[MAX_BINS];

	//  ^^^^^^^^^^^^^^  for testing  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	//byte text2_on_flag = G_text2;  // set to 1 for text2 display  ... panels 3,4
	byte text2_on_flag = 1;  // set to 1 for text2 display  ... panels 3,4
	byte text1_on_flag = 1;   // set to 1 for text1 display  ... panels 1,2 = main display
	byte red_flag = 0;  // set to 1 to make panels 3,4 text RED...good for debugging
	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


	//SerialBT.flush();  
	//G_BT_data_arrival = 0;   // needed as to allow 8Way RING in GUI3 to work


	//memset(active_bins12_array, 0, sizeof(active_bins12_array));  // initialize array to 0

	//HALL_SYNC2();
	//hall_count = G_Hall_counts;


	////////////////////////////////////////////////////////////////////////////
	//unsigned long current_time = millis();
	//unsigned long delta = current_time - G_system_time;
	//unsigned long delay = 500;  // half second
	//byte BT_waiting = 0;

	//if (delta > delay)
	//{
	//	G_system_time = millis();
	//	//BT_waiting = SerialBT.available();
	//	BT_waiting = CHECK_BLUE_TOOTH();
	//}

	//if (BT_waiting != 0)  // allow for BT interrupt
	//{
	//	BLUE_TOOTH_COMMAND_HANDLER(1);
	//	return;
	//}
	///////////////////////////////////////////////////////////////////////////////



	if (wrap == 1)
	{
		last_bin_displayed = G_max_bins;
	}



	//for (int repeat = 0; repeat < scroll_speed; ++repeat)
	//{

		// ***** GET G_bmp_num from input text[]	
	for (int d = 0; d < max_len; ++d)  // run though the binned text
	{
		if ((G_Hall_sync == 0) || (digitalRead(HEAD_COM) == 1)) { break; }

		if (hall_count == G_Hall_counts)  // only display if next Hall count isn't detected 
		{
			G_bmp_num = TEXT2BMP(text, d, 1);  // convert text to bitmap number

			// IMPORTANT NOTE:  if the Serial.prints are enabled below then TEXT or GRAPHICS will streak
			if (SERIAL_MON == 1)
			{
				//	Serial.println(F("DT1"));
					//Serial.println(F(":::::::::::::  DISPLAY_TEXT_ARRAY start ::::::::::::::"));
					//Serial.print(F("G_bmp_num="));
					//Serial.println(G_bmp_num);
					//Serial.print(F("d="));
					//Serial.println(d);
					//Serial.print(F("last_bin_displayed="));
					//Serial.println(last_bin_displayed);
					//Serial.print(F("text="));
					//Serial.println(text);
					//Serial.print(F("text2="));
					//Serial.println(text2);
					//Serial.print(F("G_special_char_select="));
					//Serial.println(G_special_char_select);
					//Serial.println(F(""));
			}

			if (G_bmp_num == 0)
			{
				text2[d + (G_max_bins / 2)] = ' ';  // make sure panels 3,4 don't display text unless panels 1,2 displayed it
			}

			bmp2 = TEXT2BMP(text2, d, 2);  // get bitmap number for panels 3,4


			if (d >= last_bin_displayed)  // cut off the display after last bin
			{
				G_bmp_num = 0;  // note only panel 1,2 will be displaying at this time as panels 3,4 are necessarilly dark at these bins
			}


			// allow for turning on and off the TEXT from panels 1,2 or 3,4
			if (text1_on_flag == 0)
			{
				G_bmp_num = 0;
			}
			if (text2_on_flag == 0)
			{
				bmp2 = 0;
			}

			//if (G_bmp_num > 0)
			//{
			//	active_bins12_array[d] = 1; // flag that position is used by panels 1,2
			//}

			///NOW that I've got the BMP number to display I need to load it 

			//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			//FastLED.clear();  // set to black all LEDs  // I added these two lines to prevent letter bleeding when a new bitmap was loaded, it works but creates spaces between every bitmap
			//FastLED.show();
			//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

			CLEAR_FONT_BUFFER();   // FastLED.clear won't work as the leds1 and leds2 aren't LEDs in the TEXT program....just arrays.

			//Serial.print(F("DT2:  G_bmp_num="));
			//Serial.println(G_bmp_num);

			// IMPORTANT NOTE:  if the Serial.prints are enabled below then TEXT or GRAPHICS will streak
			if (SERIAL_MON == 1)
			{
				//Serial.println(F("::::::::::::: position2:  DISPLAY_TEXT_ARRAY  ::::::::::::::"));
				//Serial.print(F("G_bmp_num="));
				//Serial.println(G_bmp_num);
				//Serial.print(F("bmp2="));
				//Serial.println(bmp2);
				//Serial.print(F("G_char_width_flag12="));
				//Serial.println(G_char_width_flag12);
				//Serial.print(F("G_char_width_flag34="));
				//Serial.println(G_char_width_flag34);
				//Serial.print(F("G_special_char_select="));
				//Serial.println(G_special_char_select);
				//Serial.print(F("G_2nd_saved_image="));
				//Serial.println(G_2nd_saved_image);

				//Serial.println(F(""));
			}

			if (G_bmp_num > 0)
			{
				if (G_special_char_select < 1000)
				{
					//	LOAD_BMP_PANEL(G_bmp_num, 1);  // only load leds1 as leds2 will be loaded with the sychronized TEXT for panels 3 and 4
					LOAD_FONT_BUFFER(G_bmp_num, 1);  // only load leds1 as leds2 will be loaded with the sychronized TEXT for panels 3 and 4
					//	Serial.println(F("DT2.1"));
				}

				//Serial.println(F("DT2.2"));

				if ((G_special_char_select > 1000) && (G_special_char_select < 3000)) // saved images start at 1001 and are passed with G_special_char_select, pre-made images are flaged with G_special_char_select=3000
				{

					//LOAD_FONT_BUFFER(G_bmp_num, 1);
					LOAD_BMP_SAVED_2BUFFER(G_bmp_num, 1);
					//	Serial.println(F("DT2.3"));
						//LOAD_BMP_SAVED_2BUFFER(1001, 1);

						//Serial.println(F(""));
						//Serial.println(F("<<<  DISPLAY_TEXT_ARRAY: after LOAD_BMP_SAVED_2BUFFER(1001,1)  >>>"));
						//DUMP_LED_ARRAY(leds_buffer1, NUM_LEDS); // dump the passed LED array to the Serial Monitor



					//    LOAD_BMP_PANEL(52, 1);    // TEST PATTERN

						//Serial.println(F(""));
						//Serial.println(F("<<<   DISPLAY_TEXT_ARRAY: after LOAD_BMP_PANEL(52,1)  >>>"));
						//DUMP_LED_ARRAY(leds1, NUM_LEDS); // dump the passed LED array to the Serial Monitor
				}

				//Serial.println(F("DT2.4"));

				if (G_special_char_select == 3000) // normal pre-made image 
				{
					LOAD_BMP_2BUFFER(G_bmp_num, 1);
					//	Serial.println(F("DT2.5"));
				}

			}
			else
			{
				//	Serial.println(F("DT2.6"));
				CLEAR_FONT_BUFFER_1();
			}


			//	Serial.println(F("-->DT3"));

			if (bmp2 > 0)
			{
				if (G_special_char_select < 1000)
				{
					LOAD_FONT_BUFFER(bmp2, 2);

					//LOAD_BMP_PANEL(bmp2, 2);  // load bitmap for panels 3,4 into leds2 array
				}

				if ((G_special_char_select > 1000) && (G_special_char_select < 3000)) // saved images start at 1001 and are passed with G_special_char_select, pre-made images are flaged with G_special_char_select=3000
				{
					LOAD_BMP_SAVED_2BUFFER(bmp2, 2);
					//LOAD_BMP_PANEL(52, 2);    // TEST PATTERN
					//CLEAR_FONT_BUFFER_2();   // for TEST only
				}

				if (G_special_char_select == 3000) // normal pre-made images
				{
					LOAD_BMP_2BUFFER(bmp2, 2);
				}
			}
			else
			{

				CLEAR_FONT_BUFFER_2();
			}


			//Serial.println(F("DT4"));

			//////////////for testing only
			/*LOAD_BMP_SAVED_2BUFFER(1001, 1);
			LOAD_BMP_SAVED_2BUFFER(2001, 2);*/

			//////////////end of testing only



			/*if (SERIAL_MON == 1)
			{

				Serial.println(F(""));
				Serial.println(F("+++++++++++++++++++>  DISPLAY_TEXT_ARRAY"));


				Serial.println(F("DUMPING leds1 "));
				DUMP_LED_ARRAY(leds1, NUM_LEDS);

				Serial.println(F("DUMPING leds2 "));
				DUMP_LED_ARRAY(leds2, NUM_LEDS);
			}*/



			////////////////  NOW DISPLAY THE leds_saved or pre-made IMGAGES  (not TEXT)  /////////////////

			//for (int col = 0; col < G_num_col; ++col)    // for original counter clockwise motor rotation

			//if ((G_special_char_select > 1000) && (G_special_char_select < 3000))   // display leds_saved images:  100# = 1'st half , 200#=2nd half
			if (G_special_char_select > 1000)    // display leds_saved images:  100# = 1'st half , 200#=2nd half
			{
				for (int col = 0; col < 11; ++col)    // for reverse clockwise motor rotation
					//for (int col = G_letter_width - 1; -1 < col; --col)    // for reverse clockwise motor rotation
				{


					if (col == 0) { ++G_column_0_count; } // keep track of number of times col=0, this is 0'd out at the start of SCROLL_TEXT

					if (hall_count == G_Hall_counts)
					{
						for (int row = 0; row < NUM_LEDS_FAST; ++row)
						{
							if (hall_count == G_Hall_counts)
							{
								int adr12 = GET_LED_ADR(row, col);
								int adr34 = GET_LED_ADR(row, col);

								fast_leds1[row].g = leds_buffer1[adr12].g;   // copy from internal to the bit map to outside column
								fast_leds1[row].r = leds_buffer1[adr12].r;   // copy from internal to the bit map to outside column
								fast_leds1[row].b = leds_buffer1[adr12].b;   // copy from internal to the bit map to outside column



								if (red_flag == 0)  // for testing only set red_flag=1
								{
									fast_leds4[row].r = leds_buffer2[adr34].r;   // copy from internal to the bit map to outside column
									fast_leds4[row].g = leds_buffer2[adr34].g;  // copy from internal to the bit map to outside column
									fast_leds4[row].b = leds_buffer2[adr34].b;  // copy from internal to the bit map to outside column
								}
								else  // red_flag=1
								{
									if ((leds_buffer2[adr34].r > 0) || (leds_buffer2[adr34].g > 0) || (leds_buffer2[adr34].b > 0))
									{
										fast_leds4[row].r = 255;  // copy from internal to the bit map to outside column

										fast_leds4[row].g = 0;
										fast_leds4[row].b = 0;
									}
									else
									{
										fast_leds4[row].r = 0;
										fast_leds4[row].g = 0;
										fast_leds4[row].b = 0;
									}
								}

								adr12 = modify_adr(0, 0, adr12);
								adr34 = modify_adr(0, 0, adr34);

								fast_leds2[row].g = leds_buffer1[adr12].g;   // copy from internal to the bit map to outside column
								fast_leds2[row].r = leds_buffer1[adr12].r;   // copy from internal to the bit map to outside column
								fast_leds2[row].b = leds_buffer1[adr12].b;   // copy from internal to the bit map to outside column



								if (red_flag == 0)  // for testing only set red_flag=1
								{
									fast_leds3[row].r = leds_buffer2[adr34].r;   // copy from internal to the bit map to outside column
									fast_leds3[row].g = leds_buffer2[adr34].g;  // copy from internal to the bit map to outside column
									fast_leds3[row].b = leds_buffer2[adr34].b;  // copy from internal to the bit map to outside column
								}
								else  // red_flag=1
								{
									if ((leds2[adr34].r > 0) || (leds2[adr34].g > 0) || (leds2[adr34].b > 0))
									{
										fast_leds3[row].r = 255;  // copy from internal to the bit map to outside column

										fast_leds3[row].g = 0;
										fast_leds3[row].b = 0;
									}
									else
									{
										fast_leds3[row].r = 0;
										fast_leds3[row].g = 0;
										fast_leds3[row].b = 0;

									}
								}

							}

						}

					}

					////////////////  NOW DISPLAY THE leds_saved or pre-made IMGAGES  (not TEXT)  /////////////////
					if (hall_count == G_Hall_counts)
					{
						byte BT_detected = 0;  // added 8/15/22
						BT_detected = SHOW_fast(G_depth, depth_effect);

						if (BT_detected > 0) { return 1; }  // allow a BT command to interrupt display quickly   // added 8/15/22


					}
				}


			}

			//Serial.println(F("DT5"));

			////////////////  NOW DISPLAY TEXT  /////////////////
			if (G_special_char_select < 1000)
			{
				for (int col = G_letter_width - 1; 0 <= col; col--)    // for reverse clockwise motor rotation
					//for (int col = G_letter_width - 1; -1 < col; --col)    // for reverse clockwise motor rotation
				{
					if (hall_count == G_Hall_counts)
					{
						for (int row = 0; row < NUM_LEDS_FAST; ++row)
						{
							if (hall_count == G_Hall_counts)
							{
								if ((G_char_width_flag12 == 0) || (G_char_width_flag12 == 2))
								{
									col_12 = col;
								}
								if (G_char_width_flag12 == 1)
								{
									col_12 = col + G_letter_width;  // add an offset
								}
								//////


								if ((G_char_width_flag34 == 0) || (G_char_width_flag34 == 2))
								{
									col_34 = col;
								}
								if (G_char_width_flag34 == 1)
								{
									col_34 = col + G_letter_width;  // add an offset
								}

								//	col_12 = 11;   /// TEST ONLY

								int adr12 = GET_LED_ADR(row, col_12);
								int adr34 = GET_LED_ADR(row, col_34);


								//	int offset = 0;  // amount to offset position of letter

									//led_row = modify_adr(G_upside_down, 0, offset + row);   //make image right side up or upside down

									//fast_leds[MODIFIY_FAST_ADR(row - offset)].g = leds[adr].g;   // copy from internal to the bit map to outside column
									//fast_leds[MODIFIY_FAST_ADR(row - offset)].r = leds[adr].r;   // copy from internal to the bit map to outside column
									//fast_leds[MODIFIY_FAST_ADR(row - offset)].b = leds[adr].b;   // copy from internal to the bit map to outside column


								fast_leds1[row].g = leds_buffer1[adr12].g;   // copy from internal to the bit map to outside column
								fast_leds1[row].r = leds_buffer1[adr12].r;   // copy from internal to the bit map to outside column
								fast_leds1[row].b = leds_buffer1[adr12].b;   // copy from internal to the bit map to outside column



								if (red_flag == 0)  // for testing only set red_flag=1
								{
									fast_leds4[row].r = leds_buffer2[adr34].r;   // copy from internal to the bit map to outside column
									fast_leds4[row].g = leds_buffer2[adr34].g;  // copy from internal to the bit map to outside column
									fast_leds4[row].b = leds_buffer2[adr34].b;  // copy from internal to the bit map to outside column
								}
								else  // red_flag=1
								{
									if ((leds_buffer2[adr34].r > 0) || (leds_buffer2[adr34].g > 0) || (leds_buffer2[adr34].b > 0))
									{
										fast_leds4[row].r = 255;  // copy from internal to the bit map to outside column

										fast_leds4[row].g = 0;
										fast_leds4[row].b = 0;
									}
									else
									{
										fast_leds4[row].r = 0;
										fast_leds4[row].g = 0;
										fast_leds4[row].b = 0;
									}
								}

								adr12 = modify_adr(0, 0, adr12);
								adr34 = modify_adr(0, 0, adr34);

								fast_leds2[row].g = leds_buffer1[adr12].g;   // copy from internal to the bit map to outside column
								fast_leds2[row].r = leds_buffer1[adr12].r;   // copy from internal to the bit map to outside column
								fast_leds2[row].b = leds_buffer1[adr12].b;   // copy from internal to the bit map to outside column



								if (red_flag == 0)  // for testing only set red_flag=1
								{
									fast_leds3[row].r = leds_buffer2[adr34].r;   // copy from internal to the bit map to outside column
									fast_leds3[row].g = leds_buffer2[adr34].g;  // copy from internal to the bit map to outside column
									fast_leds3[row].b = leds_buffer2[adr34].b;  // copy from internal to the bit map to outside column
								}
								else  // red_flag=1
								{
									if ((leds_buffer2[adr34].r > 0) || (leds_buffer2[adr34].g > 0) || (leds_buffer2[adr34].b > 0))
									{
										fast_leds3[row].r = 255;  // copy from internal to the bit map to outside column

										fast_leds3[row].g = 0;
										fast_leds3[row].b = 0;
									}
									else
									{
										fast_leds3[row].r = 0;
										fast_leds3[row].g = 0;
										fast_leds3[row].b = 0;

									}
								}

								//	Serial.println(F("DT6"));

									// ************  COLOR TEXT  *************************  hue=1 for WHITE

										// NOTE: I need to use G_char_width_flag12 in place of G_letter_width

								if (red_flag == 0)  // for testing only set red_flag=1
								{
									if (G_char_width_flag12 == 0)  // only colorize non-full images ... ie TEXT
									{
										//if ((fast_leds[MODIFIY_FAST_ADR(row-offset)].g>0) || (fast_leds[MODIFIY_FAST_ADR(row-offset)].r>0) || (fast_leds[MODIFIY_FAST_ADR(row-offset)].b>0))  // i.e. not a dark LED
										if ((fast_leds1[row].g > 0) || (fast_leds1[row].r > 0) || (fast_leds1[row].b > 0))  // i.e. not a dark LED
										{

											if (huey == -1) // white
											{
												fast_leds1[row] = CRGB(255, 255, 255);  // white
											}
											else
											{
												fast_leds1[row] = CHSV(huey, 255, 255);
											}


										}
										if ((fast_leds2[row].g > 0) || (fast_leds2[row].r > 0) || (fast_leds2[row].b > 0))  // i.e. not a dark LED
										{

											if (huey == -1) // white
											{
												fast_leds2[row] = CRGB(255, 255, 255);  // white
											}
											else
											{
												fast_leds2[row] = CHSV(huey, 255, 255);
											}


										}

									}

									if (G_char_width_flag34 == 0)  // only colorize non-full images ... ie TEXT
									{
										if ((fast_leds3[row].g > 0) || (fast_leds3[row].r > 0) || (fast_leds3[row].b > 0))  // i.e. not a dark LED
										{

											if (huey == -1) // white
											{
												fast_leds3[row] = CRGB(255, 255, 255);  // white
											}
											else
											{
												fast_leds3[row] = CHSV(huey, 255, 255);
											}
										}
										if ((fast_leds4[row].g > 0) || (fast_leds4[row].r > 0) || (fast_leds4[row].b > 0))  // i.e. not a dark LED
										{

											if (huey == -1) // white
											{
												fast_leds4[row] = CRGB(255, 255, 255);  // white
											}
											else
											{
												fast_leds4[row] = CHSV(huey, 255, 255);
											}
										}
									}
								}

							}
						}

						//	Serial.println(F("DT7"));

						if (G_char_width_flag12 == 0)  // only colorize non-full images ie. TEXT , no banner if full image
						{
							int adr = 0;
							if (banner == 1)  // lights that appear above and below text
							{

								fast_leds1[MODIFIY_FAST_ADR(0)].g = 255; // red on top
								fast_leds1[MODIFIY_FAST_ADR(1)].r = 255; // green 
								fast_leds1[MODIFIY_FAST_ADR(2)].b = 255;

								fast_leds1[MODIFIY_FAST_ADR(19)].g = 255; // red on bottom
								fast_leds1[MODIFIY_FAST_ADR(20)].r = 255; // green 
								fast_leds1[MODIFIY_FAST_ADR(21)].b = 255;

								fast_leds2[0].g = 255; // red on top
								fast_leds2[1].r = 255; // green 
								fast_leds2[2].b = 255;

								fast_leds2[19].g = 255; // red on bottom
								fast_leds2[20].r = 255; // green 
								fast_leds2[21].b = 255;
							}

							if (banner == 2)
							{
								fast_leds1[MODIFIY_FAST_ADR(0)].g = 255; // yellow
								fast_leds1[MODIFIY_FAST_ADR(0)].r = 255;

								fast_leds1[MODIFIY_FAST_ADR(1)].r = 255; // green 
								fast_leds1[MODIFIY_FAST_ADR(1)].b = 255; // green 

								fast_leds1[MODIFIY_FAST_ADR(2)].b = 255;  // blue
								fast_leds1[MODIFIY_FAST_ADR(3)].g = 255;  // red

								fast_leds1[MODIFIY_FAST_ADR(18)].g = 255; // red 

								fast_leds1[MODIFIY_FAST_ADR(19)].g = 255; // red on bottom
								fast_leds1[MODIFIY_FAST_ADR(19)].b = 255; // red on bottom

								fast_leds1[MODIFIY_FAST_ADR(20)].r = 255; // green 

								fast_leds1[MODIFIY_FAST_ADR(21)].b = 255;
								fast_leds1[MODIFIY_FAST_ADR(21)].r = 255;

								//^^

								fast_leds2[0].g = 255; // yellow
								fast_leds2[0].r = 255;

								fast_leds2[1].r = 255; // green 
								fast_leds2[1].b = 255; // green 

								fast_leds2[2].b = 255;  // blue
								fast_leds2[3].g = 255;  // red

								fast_leds2[18].g = 255; // red 

								fast_leds2[19].g = 255; // red on bottom
								fast_leds2[19].b = 255; // red on bottom

								fast_leds2[20].r = 255; // green 

								fast_leds2[21].b = 255;
								fast_leds2[21].r = 255;


							}
							if (banner == 3)
							{
								int duration = 5;
								++banner_time;
								if (banner_time < duration)
								{
									fast_leds1[MODIFIY_FAST_ADR(0)].g = 255; // red on top
									fast_leds1[MODIFIY_FAST_ADR(1)].r = 255; // green 
									fast_leds1[MODIFIY_FAST_ADR(2)].b = 255;

									fast_leds1[MODIFIY_FAST_ADR(19)].g = 255; // red on bottom
									fast_leds1[MODIFIY_FAST_ADR(20)].r = 255; // green 
									fast_leds1[MODIFIY_FAST_ADR(21)].b = 255;

									//^

									fast_leds2[0].g = 255; // red on top
									fast_leds2[1].r = 255; // green 
									fast_leds2[2].b = 255;

									fast_leds2[19].g = 255; // red on bottom
									fast_leds2[20].r = 255; // green 
									fast_leds2[21].b = 255;

								}
								else
								{
									if (banner_time > 2 * duration)
									{
										banner_time = 0;
									}

									fast_leds1[MODIFIY_FAST_ADR(2)].g = 255; // red on top
									fast_leds1[MODIFIY_FAST_ADR(1)].r = 255; // green 
									fast_leds1[MODIFIY_FAST_ADR(0)].b = 255;

									fast_leds1[MODIFIY_FAST_ADR(21)].g = 255; // red on bottom
									fast_leds1[MODIFIY_FAST_ADR(20)].r = 255; // green 
									fast_leds1[MODIFIY_FAST_ADR(19)].b = 255;

									//^

									fast_leds2[2].g = 255; // red on top
									fast_leds2[1].r = 255; // green 
									fast_leds2[0].b = 255;

									fast_leds2[21].g = 255; // red on bottom
									fast_leds2[20].r = 255; // green 
									fast_leds2[19].b = 255;
								}
							}
							if (banner == 4)  // create an on/off stripe
							{
								int duration = 5;

								++banner_time;
								if ((banner_time > duration) && (banner_time <= 2 * duration))
								{



									fast_leds1[MODIFIY_FAST_ADR(0)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(1)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(2)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(3)] = CHSV(hues[clr], 255, 255);

									fast_leds1[MODIFIY_FAST_ADR(18)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(19)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(20)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(21)] = CHSV(hues[clr], 255, 255);

									//^

									fast_leds2[0] = CHSV(hues[clr], 255, 255);
									fast_leds2[1] = CHSV(hues[clr], 255, 255);
									fast_leds2[2] = CHSV(hues[clr], 255, 255);
									fast_leds2[MODIFIY_FAST_ADR(3)] = CHSV(hues[clr], 255, 255);

									fast_leds2[18] = CHSV(hues[clr], 255, 255);
									fast_leds2[19] = CHSV(hues[clr], 255, 255);
									fast_leds2[20] = CHSV(hues[clr], 255, 255);
									fast_leds2[21] = CHSV(hues[clr], 255, 255);


									if (banner_time == 2 * duration)
									{
										banner_time = 0;
										clr = random(0, MAX_HUES);
									}

								}


							}
							if (banner == 5)  // create random continuous stripes
							{
								int duration = 10;

								++banner_time;
								if ((banner_time > duration) && (banner_time <= 2 * duration))
								{
									fast_leds1[MODIFIY_FAST_ADR(0)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(1)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(2)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(3)] = CHSV(hues[clr], 255, 255);

									fast_leds1[MODIFIY_FAST_ADR(18)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(19)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(20)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(21)] = CHSV(hues[clr], 255, 255);

									//^

									fast_leds2[0] = CHSV(hues[clr], 255, 255);
									fast_leds2[1] = CHSV(hues[clr], 255, 255);
									fast_leds2[2] = CHSV(hues[clr], 255, 255);
									fast_leds2[3] = CHSV(hues[clr], 255, 255);

									fast_leds2[18] = CHSV(hues[clr], 255, 255);
									fast_leds2[20] = CHSV(hues[clr], 255, 255);
									fast_leds2[21] = CHSV(hues[clr], 255, 255);

									if (banner_time == 2 * duration)
									{
										banner_time = 0;
										clr = random(0, MAX_HUES);
									}

								}
								if (banner_time < duration)
								{
									if (banner_time == 0)
									{

										clr = random(0, MAX_HUES);
									}
									fast_leds1[MODIFIY_FAST_ADR(0)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(1)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(2)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(3)] = CHSV(hues[clr], 255, 255);

									fast_leds1[MODIFIY_FAST_ADR(18)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(19)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(20)] = CHSV(hues[clr], 255, 255);
									fast_leds1[MODIFIY_FAST_ADR(21)] = CHSV(hues[clr], 255, 255);

									//^

									fast_leds2[0] = CHSV(hues[clr], 255, 255);
									fast_leds2[0] = CHSV(hues[clr], 255, 255);
									fast_leds2[0] = CHSV(hues[clr], 255, 255);
									fast_leds2[0] = CHSV(hues[clr], 255, 255);

									fast_leds2[18] = CHSV(hues[clr], 255, 255);
									fast_leds2[19] = CHSV(hues[clr], 255, 255);
									fast_leds2[20] = CHSV(hues[clr], 255, 255);
									fast_leds2[21] = CHSV(hues[clr], 255, 255);

								}
							}
						}

						//Show_LEDs();
						//MAX_BRIGHTNESS();



						if (hall_count == G_Hall_counts)
						{
							int previous_G_dim = G_dim;

							G_dim = SCROLL_TEXT_INCREASED_BRIGTNESS_FACTOR * G_dim; // make text 30% brighter

							byte BT_interrupt = SHOW_fast(G_depth, depth_effect);  // DISPLAY TEXT

							G_dim = previous_G_dim;  // restore previous G_dim value

							if ((G_BT_message_flag != 0) || (BT_interrupt == 1)) // BT message received
							{
								return 1;
							}

						}
					}
				}
			}
		}
	}

	//	Serial.println(F("DT8"));

	return 0;

}



//////////////////////////////////////////////////////////////////////////
void MAX_BRIGHTNESS()  // set all LEDs to maximum brightness as set by DEFAULT_BRIGTHNESS
{
	G_dim = DEFAULT_BRIGTHNESS;  // maximum brightness

	for (int i = 0; i < NUM_LEDS; ++i)
	{
		leds1[i].maximizeBrightness();
		leds1[i].fadeLightBy(DEFAULT_BRIGTHNESS); // Dim a color 

		leds2[i].maximizeBrightness();
		leds2[i].fadeLightBy(DEFAULT_BRIGTHNESS); // Dim a color 

		leds3[i].maximizeBrightness();
		leds3[i].fadeLightBy(DEFAULT_BRIGTHNESS); // Dim a color 

		leds4[i].maximizeBrightness();
		leds4[i].fadeLightBy(DEFAULT_BRIGTHNESS); // Dim a color 

	}
}



//////////////////////////////////////////////////////////////////////

/**************************************************************************************************************/





//////////////////////////////////////////////////////////////////////





/**************************************************************************************************************/
void CAPTURE_VALUE(int value)
{
	byte forever = 1;

	if (SERIAL_MON == 1)
	{
		while (forever == 1)
		{
			Serial.print("value=");
			Serial.println(value);
			Serial.println("");

		}
	}
}


/******************   DON_COM    ******************************************************************************************************/
int DC_WRITE_BYTE(byte data)  // write a byte of Don Com data, the WRITE is written from the MASTER's perspective
// return a 0 if no data is to be received first, return a 1 if data is to be recieved before a write (NOTE: WRITE won't be done if data first needs to be recieved
{


	byte mask = 1; //our bitmask
	byte polarity_flag = 0; // keep track if 1 or 0 sent

	// change pin mapping if SLAVE is writing data to MASTER .. mapping is restored at end of WRITE
	if (G_MASTER_SLAVE_FLAG == 0) // SLAVE is writing to MASTER 
	{
		G_DC_M0 = DC_S0_PIN;
		G_DC_M1 = DC_S1_PIN;
		G_DC_S0 = DC_M0_PIN;
		G_DC_S1 = DC_M1_PIN;
	}


	// check if no data is to be received first
	if ((digitalRead(G_DC_S0) == LOW) && (digitalRead(G_DC_S1) == LOW))
	{
		// restore normal pin mapping
		G_DC_M0 = DC_M0_PIN;
		G_DC_M1 = DC_M1_PIN;
		G_DC_S0 = DC_S0_PIN;
		G_DC_S1 = DC_S1_PIN;

		return 0;   //EXIT function: data must first be read before new data written
	}



	//while ((digitalRead(G_DC_S0) == LOW) || (digitalRead(G_DC_S1) == LOW))  // wait for both SLAVE signals to go HIGH .... ^^^^^^^^^^^test to fix error
	//{
	//	// just wait....maybe check for Blue Tooth if MASTER

	//}

//	noInterrupts();  // added as experiment

	digitalWrite(G_DC_M0, LOW);   // signal that data is ready to be sent
	digitalWrite(G_DC_M1, LOW);   // signal that data is ready to be sent



	while ((digitalRead(G_DC_S0) == HIGH) && (digitalRead(G_DC_S1) == HIGH))  // wait for both SLAVE signals to go LOW
	{
		// just wait....maybe check for Blue Tooth if MASTER

	}


	////////  SLAVE is ready to receive ... begin transmission ////////////


	// transmit 8 bits
	for (mask = 1; mask > 0; mask <<= 1) { //iterate through bit mask  ... 8 bits


		// output next bit only when SLAVE outputs are LOW
		if (data & mask) { // if bitwise AND resolves to true

			if (mask == 1) { delayMicroseconds(10); }  // delay the first bit for reasons I don't understand ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

			digitalWrite(G_DC_M1, HIGH); // send 1
			polarity_flag = 1;
		}
		else { //if bitwise and resolves to false
			digitalWrite(G_DC_M0, HIGH); // send 0
			polarity_flag = 0;
		}

		while (digitalRead(G_DC_S0) == LOW)   // wait for slave acknowledgment with a HIGH that bit was received
		{
			// just wait....maybe check for Blue Tooth if MASTER

		}

		// drive MASTER data lines back LOW after SLAVE acknowledgement
		if (polarity_flag == 0)  // minimize pin changes (for speed) 
		{
			digitalWrite(G_DC_M0, LOW); // must be HIGH to end
		}
		else
		{
			digitalWrite(G_DC_M1, LOW); // must be HIGH to end
		}

		// wait for SLAVE to acknowledge MASTER data lines went LOW
		while (digitalRead(G_DC_S0) == HIGH)   // wait for slave acknowledgment that bit was received by a LOW signal
		{
			// just wait....maybe check for Blue Tooth if MASTER

		}


	}

	digitalWrite(G_DC_M0, HIGH); // must be HIGH to end
	digitalWrite(G_DC_M1, HIGH); // must be HIGH to end

	// restore normal pin mapping
	G_DC_M0 = DC_M0_PIN;
	G_DC_M1 = DC_M1_PIN;
	G_DC_S0 = DC_S0_PIN;
	G_DC_S1 = DC_S1_PIN;

	delayMicroseconds(G_frame_delay);  // this is needed or else system can latch

	//	interrupts(); // added as experiment

	return 1;  // data sent

}


/****************   DON_COM   ********************************************************************************************************/
int DC_READ_BYTE()  // read a byte of Don Com data, the READ is programmed from the SLAVE's perspective
// return a 0 if there is no data is to be received, return a 1 if data was received....NOTE: received data is returned in G_DC_data
{


	delayMicroseconds(G_frame_delay + 100);  // necessary for proper read

	byte mask = 1; //our bitmask

	int DC_1_STATE = LOW;

	// change pin mapping if MASTER is reading from SLAVE  ... mapping is restored at end of READ
	if (G_MASTER_SLAVE_FLAG == 1) // MASTER is reading from SLAVE
	{
		G_DC_M0 = DC_S0_PIN;
		G_DC_M1 = DC_S1_PIN;
		G_DC_S0 = DC_M0_PIN;
		G_DC_S1 = DC_M1_PIN;
	}


	// check if data is to be received ... both MASTER signals must be LOW
	if ((digitalRead(G_DC_M0) == HIGH) || (digitalRead(G_DC_M1) == HIGH))
	{
		// restore normal pin mapping
		G_DC_M0 = DC_M0_PIN;
		G_DC_M1 = DC_M1_PIN;
		G_DC_S0 = DC_S0_PIN;
		G_DC_S1 = DC_S1_PIN;


		return 0;   //EXIT function
	}




	G_DC_data = 0;  // initialize received data to 0

	//noInterrupts(); // added as an experiment

	digitalWrite(G_DC_S0, LOW);   // signal that data is ready to be read
	digitalWrite(G_DC_S1, LOW);   // STROBE signal stays LOW throught the entire READ 
	//delayMicroseconds(10);  // exp test

	for (mask = 1; mask > 0; mask <<= 1) { //iterate through bit mask  ... 8 bits

		while ((digitalRead(G_DC_M0) == LOW) && (digitalRead(G_DC_M1) == LOW))  // wait for MASTER to send a 1 or 0
		{
			// just wait....maybe check for Blue Tooth if MASTER

		}

		DC_1_STATE = digitalRead(G_DC_M1);  // got serial data bit

		digitalWrite(G_DC_S0, HIGH); // signal MASTER that a bit was recieved and it can return signal lines to LOW


		// accumulate data
		if (DC_1_STATE == HIGH)
		{
			G_DC_data = (G_DC_data | mask);  // insert a 1 at the mask position
		}


		// wait for MASTER data signal to go LOW
		if (DC_1_STATE == HIGH)
		{
			while (digitalRead(G_DC_M1) == HIGH) {}  // wait for MASTER signal to go LOW 

		}
		else
		{
			while (digitalRead(G_DC_M0) == HIGH) {}  // wait for MASTER signal to go LOW 
		}

		digitalWrite(G_DC_S0, LOW); // signal MASTER that SLAVE sees MASTER signals LOW



	}

	while ((digitalRead(G_DC_M0) == LOW) || (digitalRead(G_DC_M1) == LOW))  // wait for MASTER signals to go HIGH......hoping this works
	{
		// just wait....maybe check for Blue Tooth if MASTER

	}


	digitalWrite(G_DC_S0, HIGH); // must be HIGH to end
	digitalWrite(G_DC_S1, HIGH); // must be HIGH to end

	// restore normal pin mapping
	G_DC_M0 = DC_M0_PIN;
	G_DC_M1 = DC_M1_PIN;
	G_DC_S0 = DC_S0_PIN;
	G_DC_S1 = DC_S1_PIN;

	//interrupts();   // added as an experiment

	return 1;  // signal data was received ... answer = G_DC_data

}


/************************************************************************************************************************/
byte DC_SEND_ARRAY()  // send the DC_OUT_array via Don_COM to the other board
//  rv=1 if data sent, rv=0 if data first needs to be received
{
	int rv = 0;

	Serial.println(F("%%%%%%%   DC_SEND_ARRAY() %%%%%%%%%%%%"));
	Serial.print(F("DC_OUT_array[0]= "));
	Serial.println(DC_OUT_array[0]);
	Serial.print(F("DC_OUT_array[1]= "));
	Serial.println(DC_OUT_array[1]);
	Serial.print(F("DC_OUT_array[2]= "));
	Serial.println(DC_OUT_array[2]);

	for (int n = 0; n < DC_ARRAY_SIZE; ++n)
	{
		rv = DC_WRITE_BYTE(DC_OUT_array[n]);

		if (rv == 0)
		{
			Serial.print(F("n="));
			Serial.print(n);
			Serial.println(F("%%%%%%% leaving:  DC_SEND_ARRAY(): *** rv=0 %%%%%%%%%%%%"));
			Serial.println("");
			return 0;
		}  // data needs to be read first
	}

	Serial.println(F("%%%%%%% leaving:  DC_SEND_ARRAY():  rv=1 %%%%%%%%%%%%"));
	Serial.println("");

	return 1;  // signal that data was sent
}

//************************************************************************************************************************/
int DC_RECEIVE_ARRAY()  // receive a DC_OUT_array and store it into the DC_IN_array
// return a 0 if there is no data is to be received, return a 1 if data was received....NOTE: received data is returned in G_DC_data
{
	int rv = 0;

	//Serial.println("start of DC_RECEIVE_ARRAY");
	//Serial.println("");

	for (int n = 0; n < DC_ARRAY_SIZE; ++n)
	{
		rv = DC_READ_BYTE();  //  data returned in G_DC_data 

		//delayMicroseconds(50);

		/*Serial.print("n= ");
		Serial.println(n);
		Serial.print("rv= ");
		Serial.println(rv);
		Serial.print("G_DC_data= ");
		Serial.println(G_DC_data);
		Serial.println("");*/

		if (rv == 0) { return 0; }  // no data to be received

		DC_IN_array[n] = G_DC_data;   // received bytes stored in DC_IN_array
	}

	return 1; // signal that all data was received
}

//**************************************************************
void DC_COMMAND_HANDLER()  //  handle DON_COM communication
{
	if (DC_ON == 0) { return; }


	//if (G_DC_received_flag == 1)  // DC data received
	//{
	//	if (G_SM_DC == 1)
	//	{
	//		Serial.println(F("^^^^^DC_COMMAND_HANDLER^^^^^"));
	//		Serial.print(F("DC_IN_array[0]="));
	//		Serial.println(DC_IN_array[0]);
	//		Serial.print(F("DC_IN_array[1]="));
	//		Serial.println(DC_IN_array[1]);
	//	}

	//	if (DC_IN_array[0] == 1) // show TEXT show command
	//	{
	//		Serial.println(F("----------------------->DCCH: command 1 received"));

	//	}

	//	if (DC_IN_array[0] == 4) // receive SLAVE show number
	//	{
	//		byte next_show_num = DC_IN_array[1];
	//		SerialBT.print("*!");
	//		SerialBT.print(next_show_num);
	//		SerialBT.print("*");

	//		/*Serial.print("receive SLAVE show number= ");
	//		Serial.println(next_show_num);*/

	//	}

	//	if (DC_IN_array[0] == 5) // receive G_SAVED[] array from SLAVE
	//	{
	//		G_SAVED[1] = DC_IN_array[1];  // set to 1 if leds_save are saved and LEDs are non-zero
	//		G_SAVED[2] = DC_IN_array[2];
	//		G_SAVED[3] = DC_IN_array[3];
	//	}

	//	if (DC_IN_array[0] == 6) // receive G_SAVED[] array from SLAVE
	//	{
	//		G_SAVED[4] = DC_IN_array[1];  // set to 1 if leds_save are saved and LEDs are non-zero
	//		G_SAVED[5] = DC_IN_array[2];

	//		byte at_least_one_SAVED_image = 0;

	//		for (byte n = 1; n < 6; ++n)  // turn the appropriate SAVE indicator light to the correct color
	//		{
	//			if (G_SAVED[n] == 1)
	//			{
	//				//String BT_string2send = String("*MR" + String(leds1[0].r) + "G" + String(leds1[0].g) + "B" + String(leds1[0].b) + "*");

	//				String BT_string2send = String("*" + String(n) + "R" + String(255) + "G" + String(255) + "B" + String(255) + "*");  // send WHITE to indicator
	//				SerialBT.print(BT_string2send);  // turn indicator to HUE color

	//				at_least_one_SAVED_image = 1;
	//			}
	//			else
	//			{
	//				String BT_string2send = String("*" + String(n) + "R" + String(0) + "G" + String(0) + "B" + String(0) + "*");  // send DARK to indicator
	//				SerialBT.print(BT_string2send);  // turn indicator to HUE color
	//			}

	//		}

	//		if (at_least_one_SAVED_image == 0)
	//		{
	//			Serial.println(F("DCCH: TURN_OFF_PLAY_SAVES_MODE() "));
	//			Serial.println("");

	//			TURN_OFF_PLAY_SAVES_MODE();
	//		}

	//	}

	//	if (DC_IN_array[0] == 7) // set position of EFFECT slider for GUI2
	//	{
	//		Serial.println(F(" "));
	//		Serial.println(F("--------->  DCCH: command 7 "));
	//		Serial.print(F("G_EFFECT_slider= "));
	//		Serial.println(G_EFFECT_slider);
	//		Serial.println(F(" "));

	//		G_EFFECT_slider = DC_IN_array[1];

	//		if (G_EFFECT_slider != G_EFFECT_slider_previous)
	//		{
	//			MODIFY_GUI2(5); // preset EFFECT slider
	//			G_EFFECT_slider_previous = G_EFFECT_slider;
	//		}

	//	}

	//	if (DC_IN_array[0] == 8) // saved image from SLAVE to be transfered to MASETER
	//	{
	//		G_TRANSFERED_image = DC_IN_array[1];
	//		G_adr = 0;  // initialize
	//	}

	//	if (DC_IN_array[0] == 9) // saved image data from SLAVE
	//	{
	//		if (G_adr < NUM_LEDS)  // done as a precaution
	//		{
	//			leds_saved[G_TRANSFERED_image][G_adr].r = DC_IN_array[1];
	//			leds_saved[G_TRANSFERED_image][G_adr].g = DC_IN_array[2];
	//			leds_saved[G_TRANSFERED_image][G_adr].b = DC_IN_array[3];


	//			++G_adr;
	//		}
	//	}

	//	if (DC_IN_array[0] == 10) // end of transfer of leds_saved data
	//	{
	//		Serial.println(F(" "));
	//		Serial.print(F("--------->  DCCH: command 10 = end of transfer: G_TRANSFERED_image= "));
	//		Serial.println(G_TRANSFERED_image);
	//		Serial.print(F("--------->  DCCH: command 10: G_adr= "));
	//		Serial.println(G_adr);   // should be 484=last adr. +1
	//		Serial.println(F(" "));

	//		//////////////////FOR TESTING ONLY/////////////////////////
	//		//for (int n = 0; n < NUM_LEDS; ++n)
	//		//{
	//		//	leds_saved[1][n] = 0;  // clear array
	//		//}

	//		//for (int n = 0; n < 22; ++n)  // vertical line
	//		//{
	//		//	leds_saved[1][n].r = 255;
	//		//	leds_saved[1][n].g = 0;
	//		//	leds_saved[1][n].b = 0;
	//		//}

	//		//int adr = 0;

	//		//for (int col = 0; col < 22; ++col)
	//		//{
	//		//	adr = GET_LED_ADR(0, col);

	//		//	leds_saved[1][adr].r = 0;
	//		//	leds_saved[1][adr].g = 0;
	//		//	leds_saved[1][adr].b = 255;
	//		//}


	//		//////////////////end of test only ///////////////////////

	//	}

	//	////////////////////////
	//	if (DC_IN_array[0] == 11) // displayed G_saved image
	//	{

	//		G_special_char_select = DC_IN_array[1] + 1000;  //define image to be displayed

	//		// image will be displayed with show#=254
	//	}


	//	if (G_SM_DC == 1)
	//	{
	//		Serial.println(F("^^^^^leaving: DC_COMMAND_HANDLER^^^^^"));
	//		Serial.println("");
	//	}

	//}



	//G_DC_received_flag = 0;  // reset flag



}


//**************************************************************************************************************************
byte CHECK_BLUE_TOOTH()  // check if there is a message coming in on Blue Tooth, rv=1 if yes:  BT command returned as G_BT_command
{
	//Serial.println(F("++++  CHECK_BLUE_TOOTH:  START"));
	
	if (G_BLOCK_BT_CHECK == 1)  // when set to 1 CHECK_BLUE_TOOTH() is skipped
	{
		return 0;
	}

	/// prevent multiple BT command: note: this code is located here in order to decode BT command J=mouse pad
	byte skip = BT_DELAY_FILTER();  // filter out multiple fast BT transfers to prevent a CRASH if commands issued too fast during SCROLL_TEXT

	if (skip == 1)
	{
		Serial.println("");
		Serial.println(F("++++  CHECK_BLUE_TOOTH:  executing a RETURN()"));
		Serial.print(F("G_BT_command ="));
		Serial.println(G_BT_command);
		Serial.print(F("G_BT_previous_command ="));
		Serial.println(G_BT_previous_command);
		Serial.println("");


		return 0; // no BT message
	} // BT buffer was flushed don't execute command

	byte amperstand_found = 1;  // set to 1 if amperstand is found and also at start to prevent reading BT if none is available
	byte data_count = 0; // keeps track of how much data is coming in
	byte max_data_count = 20;  // if amount of data exceeds this then FLUSH the BT buffer, was 7


	///////////////////
	// Flash BT connected indicator


	static byte BT_indicator_ON = 0;
	unsigned long present_time = millis();
	static unsigned long last_update = 0;
	unsigned long delta_update = 0;


	if ((G_GUI == 3) || (G_GUI == 4))
	{
		delta_update = present_time - last_update;

		if (delta_update > 1000)  // only update every second
		{
			last_update = present_time;

			if (BT_indicator_ON == 0)
			{
				if (G_GUI == 3)
				{
					MODIFY_GUI3(6);  // turn BT indicator GREEN
				}

				if (G_GUI == 4)
				{
					MODIFY_GUI4(6);  // turn BT indicator GREEN
				}

			}

			if (BT_indicator_ON == 1)
			{
				if (G_GUI == 3)
				{
					MODIFY_GUI3(7);  // turn BT indicator BLACK
				}

				if (G_GUI == 4)
				{
					MODIFY_GUI4(7);  // turn BT indicator BLACK
				}

			}

			if (BT_indicator_ON == 0)  // toggle BT_indicator_ON
			{
				BT_indicator_ON = 1;
			}
			else
			{
				BT_indicator_ON = 0;
			}
		}
	}




	//	G_BT_data_arrival = 1; // block INC_HALL_COUNT interrupt from checking SerialBT.available

		//Serial.println(F("_______ start of CHECK_BLUE_TOOTH___________"));
		//Serial.print(F("G_message="));
		//Serial.println(G_message);
		//Serial.print(F("G_message.substring(0,3)="));
		//Serial.println(G_message.substring(0, 3));
		//Serial.print(F(""));

		//byte skip = BT_DELAY_FILTER();  // filter out multiple fast BT transfers to prevent a CRASH if commands issued too fast during SCROLL_TEXT


		//if (skip == 1)
		//{
		//	Serial.println("");
		//	Serial.println(F("++++  CHECK_BLUE_TOOTH:  executing a RETURN()"));
		//	Serial.print(F("G_BT_command ="));
		//	Serial.println(G_BT_command);
		//	Serial.println("");
		//	return 0;
		//} // BT buffer was flushed don't execute command


	G_message = "";  // if this isn't done then CLEAR and GENERATE don't work


	if (SerialBT.available())
	{
		Serial.println(F("_______ CHECK_BLUE_TOOTH:  incomming BT ___________"));
		//Serial.print(F("G_BT_data_arrival="));
		//Serial.println(G_BT_data_arrival);

		//Serial.print(F("G_message="));
		//Serial.println(G_message);
		//Serial.print(F("G_message.substring(0,3)="));
		//Serial.println(G_message.substring(0, 3));
		Serial.println(F(""));

		amperstand_found = 0; // amperstand not found at start

		for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)  // clear text array
		{
			text_array[n] = ' ';
		}


	}

	

	//while (SerialBT.available())
	while (amperstand_found == 0)
	{
		++data_count;
		if (data_count > max_data_count) // garbage is coming in so exit and flush
		{
			amperstand_found = 1; // force exit
			delay(500);
			//SerialBT.flush();  // flush the BT buffer on first incomming ... which is junk
			FLUSH_BT_BUFFER();
			G_incomingChar = ' ';
			G_BT_command = ' ';
			G_BT_command2 = ' ';
			G_BT_command3 = ' ';

			Serial.println(F("BT MAX DATA COUNT exceeded"));
			Serial.println(F(""));
		}

		delay(15);  // this is needed or junk comes in
		G_incomingChar = SerialBT.read();

		if (G_BT_firstMessage_flag == 0)
		{
			//SerialBT.flush();  // flush the BT buffer on first incomming ... which is junk
			FLUSH_BT_BUFFER();
			G_incomingChar = ' ';
			G_BT_firstMessage_flag = 1;
		}

		Serial.print(F("G_incomingChar="));
		Serial.println(G_incomingChar);
		Serial.print(F("G_BT_firstMessage_flag="));
		Serial.println(G_BT_firstMessage_flag);
		Serial.println(F(""));


		if ((G_incomingChar != ' '))
			//	if ((G_incomingChar != ' ') && (G_BT_command = ' '))
		{
			if (G_incomingChar != '@')
			{
				G_message += String(G_incomingChar);

				if (G_BT_firstMessage_flag == 1)
				{
					G_BT_firstMessage_flag = 2; // don't clear the G_message except at the beginning... which is junk
					//	G_message = "";
				}
			}
			else  // end of message
			{

				amperstand_found = 1; // @ found so exit WHILE loop

				int stringSize = G_message.length();

				if (stringSize >= MAX_TEXT_DISPLAYED - 1)
				{

					stringSize = MAX_TEXT_DISPLAYED - 2;
				}

				G_message.toCharArray(text_array, stringSize + 1);  // convert message to my text_array, for some reason I have to add 1 to the string size

				text_array[MAX_TEXT_DISPLAYED - 1] = '\0';

				//G_BT_previous_command = G_BT_command ;
				//G_BT_previous_command2 = G_BT_command2;
				//G_BT_previous_command3 = G_BT_command3;

				G_BT_command = text_array[0];
				G_BT_command2 = text_array[1];  // only valid if G_BT_command='z'
				G_BT_command3 = text_array[2];  // only valid if G_BT_command='z'

				if (G_BT_previous_command != G_BT_command)
				{
					G_BT_previous_command = G_BT_command;
				}



				if (G_BT_previous_command3 != G_BT_command3)
				{
					G_BT_previous_command3 = G_BT_command3;
				}

				Serial.print(F("G_message="));
				Serial.println(G_message);
				Serial.print(F("stringSize="));
				Serial.println(stringSize);
				Serial.println("");
				Serial.print(F("text_array[0]="));
				Serial.println(text_array[0]);
				Serial.print(F("text_array[1]="));
				Serial.println(text_array[1]);
				Serial.print(F("text_array[2]="));
				Serial.println(text_array[2]);
				Serial.print(F("text_array[3]="));
				Serial.println(text_array[3]);
				Serial.print(F("text_array[4]="));
				Serial.println(text_array[4]);
				Serial.print(F("text_array[5]="));
				Serial.println(text_array[5]);
				Serial.print(F("text_array[6]="));
				Serial.println(text_array[6]);
				Serial.println(F(""));




				// remove the first character from "text_array" , shift text_array down by 1
				for (int n = 0; n < stringSize + 1; ++n)
				{
					text_array[n] = text_array[n + 1];
				}

				if (G_BT_command == 'z')  // remove the first character from "text_array" , shift text_array down by 1
				{
					for (int n = 0; n < stringSize + 1; ++n)
					{
						text_array[n] = text_array[n + 1];
					}

				}

				if ((G_BT_command == 'z') && (G_BT_command2 == 'z')) // remove the first character from "text_array" , shift text_array down by 1
				{
					for (int n = 0; n < stringSize + 1; ++n)
					{
						text_array[n] = text_array[n + 1];
					}
				}


				Serial.println(F("--->CHECK_BLUE_TOOTH: position 2"));
				Serial.print(F("G_message="));
				Serial.println(G_message);
				Serial.print(F("G_BT_command="));
				Serial.println(G_BT_command);
				Serial.print(F("G_BT_command2="));
				Serial.println(G_BT_command2);
				Serial.print(F("G_BT_command3="));
				Serial.println(G_BT_command3);
				Serial.print(F("text_array="));
				Serial.println((char*)text_array);
				Serial.print(F("stringSize="));
				Serial.println(stringSize);
				Serial.println(F("__________leaving CHECK_BLUE_TOOTH___________"));
				Serial.println("");


				///// prevent multiple BT command: note: this code is located here in order to decode BT command J=mouse pad
				//byte skip = BT_DELAY_FILTER();  // filter out multiple fast BT transfers to prevent a CRASH if commands issued too fast during SCROLL_TEXT

				//if (skip == 1)
				//{
				//	Serial.println("");
				//	Serial.println(F("++++  CHECK_BLUE_TOOTH:  executing a RETURN()"));
				////	Serial.print(F("G_BT_command ="));
				////	Serial.println(G_BT_command);
				//	Serial.println("");


				//	return 0; // no BT message
				//} // BT buffer was flushed don't execute command


				return 1;   // signal entire message captured in G_message
			}
		}
	}



	//Serial.println(F("__________END of CHECK_BLUE_TOOTH___________"));
	//Serial.println("");

	return 0;  // no BT message
}

//**************************************************************************************************************************
//byte CHECK_BLUE_TOOTH()  // check if there is a message coming in on Blue Tooth, rv=1 if yes:  BT command returned as G_BT_command
//{
//	G_message = "";
//
//	if (SerialBT.available())
//	{
//		Serial.println("_______ CHECK_BLUE_TOOTH:  incomming BT ___________");
//	}
//
//	while (SerialBT.available())
//	{
//		G_incomingChar = SerialBT.read();
//
//		
//		Serial.print("G_incomingChar=");
//		Serial.println(G_incomingChar);
//
//
//		if (G_incomingChar != '\n') {
//		
//			G_message += String(G_incomingChar);
//
//			Serial.print("accumulating message: G_message=");
//			Serial.println(G_message);
//			
//		}
//		else  // end of message
//		{
//
//			int stringSize = G_message.length();
//
//			G_message.toCharArray(text_array, stringSize);  // convert message to my text_array
//
//			G_BT_command = text_array[0];
//
//			// remove the first character from "text_array" , shift text_array down by 1
//			for (int n = 0; n < stringSize + 1; ++n)
//			{
//				text_array[n] = text_array[n + 1];
//			}
//
//			Serial.println("");
//			Serial.print("final G_message=");
//			Serial.println(G_message);
//			Serial.print("G_BT_command=");
//			Serial.println(G_BT_command);
//			Serial.println("__________leaving CHECK_BLUE_TOOTH___________");
//			Serial.println("");
//
//
//			return 1;   // signal entire message captured in G_message
//		}
//	}
//
//
//
//	return 0;  // no BT message
//}
//**************************************************************************************************************************
void SHOW_BLUE_TOOTH_MESSAGE(int hue)  // show the BLUE TOOTH message
{
	if (G_BT_message_flag == 1)
	{

		/*Serial.print("message got=");
		Serial.println(G_message);
		Serial.println("");*/

		//	HALL_MEASURE3(22);  //find G_max_bins

		int stringSize = G_message.length();

		G_message.toCharArray(text_array, stringSize);  // convert message to my text_array

		/*Serial.print("text_array=");
		Serial.println(text_array);
		Serial.println("");*/

		/*Serial.print("message_flag=");
		Serial.println(message_flag);
		Serial.println("");*/


		//int hue = 1;  // white
		stringSize = strlen(text_array);

		SCROLL_TEXT(text_array, stringSize, 1, 1, hue, 0, 0, 1, 0);

		G_BT_message_flag = 0;
		G_message = "";
	}
}


//**************************************************************************************************************************
void BLUE_TOOTH_COMMAND_HANDLER(byte allow_transfer_flag)  // check for BLUE TOOTH command and handle the command
// set allow_transfer_flag=1 if BT_and_DC_CHECKandDO() is allowed
// GUI3 reset = zB@    //  GUI4 refresh =  zzj@    //
{
	allow_transfer_flag = 1;
	unsigned long delta_BTCH_SKIP_TIME = millis() - G_BTCH_SKIP_TIME; // time since last time G_SKIP_BTCH=1


	if (G_SKIP_BTCH == 1) // this was added to make sure MINI shows properly maintain the original image if a 2nd MINI show is selected while the first MINI show is playing
	{
		if (G_SKIP_BTCH_previous == 0)
		{
			G_SKIP_BTCH_previous = 1;

			G_BTCH_SKIP_TIME = millis();  // record time stamp

			delta_BTCH_SKIP_TIME = 0;
		}

		// I added this timer feature because (for reasons not understood) sometimes G_SKIP_BTCH would get stuck at 1
		if (delta_BTCH_SKIP_TIME < 5000)  // 5 seconds 
		{
			return;
		}

	}

	G_SKIP_BTCH = 0;
	G_SKIP_BTCH_previous = 0;

	if (G_BT_command != ' ')  // reset the start time with any BT command : to allow automatic exit from CREATE MODE if idling in  CREATE MODE
	{

		G_CREATE_MODE_start_time = millis();

	}



	int stringSize = strlen(text_array);
	//byte do_not_clear_flag = 0; // set to one to not clear BT command...

	Serial.println(F("@@@@ BTCH: start of BLUE_TOOTH_COMMAND_HANDLER @@@@"));
	Serial.print(F("allow_transfer_flag="));
	Serial.println(allow_transfer_flag);
	Serial.print(F("G_BT_command="));
	Serial.println(G_BT_command);
	Serial.print(F("G_BT_command2="));
	Serial.println(G_BT_command2);
	Serial.print(F("G_BT_command3="));
	Serial.println(G_BT_command3);
	Serial.println("");
	Serial.print(F("G_CREATE_mode="));
	Serial.println(G_CREATE_mode);
	Serial.print(F("G_GUI="));
	Serial.println(G_GUI);
	Serial.print(F(" G_continuous_SPECIAL_mode="));
	Serial.println(G_continuous_SPECIAL_mode);
	Serial.print(F(" G_CREATE_MODE_start_time="));
	Serial.println(G_CREATE_MODE_start_time);
	Serial.println("");

	//Serial.println(F(""));
	//Serial.print(F("$$$$$$$$$ BTCH top: G_dim= "));
	//Serial.println(G_dim);
	//Serial.println(F(""));

	/// ************ for TEST ONLY /////////
	//G_CREATE_mode = 0;  // added to see if fixes freeze
	///////////////////////

	// &&&&&&&&&&&&&&&  BT COMMANDS &&&&&&&&&&&&&&&&&&&&&&&&
	// next available z command letter = zZ  (however reserve Z for future expansion) 
	// next available zz command letter = zzt  
	// extras: N, zQ,   zzZ
	// TEXT receive characters used: !, A, B, C, D, S   
	//	receive character:  ! = GUI1 SHOW #
	//						A = SPEED slider
	//                      B = CYCLE slider
	//                      C = TRANS slider
	//                      D = EFFECT slider
	//				        S = Geometry  select in GUI3
	//						E = (TOUCH 2) in GUI3
	//						F = MURGETRIOD CONTROLLER
	//						G = GUI3 RING IMAGE slider value
	//						H = BT connect indicator
	//						I = current PRODUCTION number for GUI4 and GUI3
	//						J = PRODUCTION to load in GUI4
	//						K = SHOW to load in GUI4
	//						L = CREATE MODE indicator in GUI4
	//						M = Final SHOW indicator in GUI4, color indicator in GUI3
	//						N = Production Name in GUI4
	//						O = MIC gain in GUI4
	//                      P = music detect signal in GUI4
	//						Q = HEAD COM in GUI4
	//						R = SOUND DETECT in GUI4



	// note: 1,2,3,4,5 are used to receive SAVEs from MASTER 

	// &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

	//// turn CREATE MODE on if GUI2 active and most any control is touched
	// don't turn on CREATE mode if GUI botton pressed, or CREATE mode switch changed, or RESET button pressed

	byte skip_flag = 0; // don't turn on CREATE mode if = 1
	static byte skip_once_flag;


	G_BT_cmd = 0;  // NOTE: this is not the same as G_BT_command


	if ((G_GUI == 2) || (G_GUI == 3)) // if skip_flag=1 the CREATE mode will not be entered by specificed GUI action
	{

		//		if ((G_BT_command == 'g') && (G_GUI == 3))  // a patch to prevent CREATE MODE from turning back on once its turned off...I don't know why "g" is being sent by GUI after a RESET when CREATE MODE is turned off
		//		{
			//		skip_flag = 1;
			//		SerialBT.flush();
		//		}

		if (G_GUI == 4)  // production/show control GUI
		{
			skip_flag = 2;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'h'))  // PRODUCTION button
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'N'))  // play saves switch
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'V'))  // GUI3 HAPPY BD
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'C'))  // GUI button
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'B'))  // RESET button
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'K') || (G_BT_command == 'L'))  // CREATE switch
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'M')   // UNDO button
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'l')   // WHITE button
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'O')   // CLEAR button
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'q')   // BRIIGHTNESS slider
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'H')   // color slider
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'K'))  // a SAVE button
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'L'))  // a LOAD button
		{
			skip_flag = 1;
		}

		if (G_BT_command == 't')   // SPECIAL slider
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'f')   // SPEED slider
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'M'))  // EFFECT slider
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'h'))
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'G')  // play pervous show for GUI4
		{
			skip_flag = 1;
		}

		if (G_BT_command == 'F')  // play next show for GUI4
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'i'))
		{
			skip_flag = 1;
		}


		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'j'))  // GUI4 RESET
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'k'))  // return to GUI3 from GUI4
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'V'))  // GUI4 production lock on
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'W'))  // GUI4 production lock off
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'X'))  // GUI4 show lock on
		{
			skip_flag = 1;
		}

		if ((G_BT_command == 'z') && (G_BT_command2 == 'Y'))  // GUI4 show lock off
		{
			skip_flag = 1;
		}

		Serial.print(F("BTCH: skip_flag ="));
		Serial.println(skip_flag);
		Serial.print(F("BTCH: G_CREATE_mode ="));
		Serial.println(G_CREATE_mode);
		Serial.println("");

		//	if (skip_flag == 0)  // OK to turn off PLAY SAVES mode
		{
			//		TURN_OFF_PLAY_SAVES_MODE();  // turn off on any BT command
		}


		//if ((skip_flag == 0) && (G_CREATE_mode == 0) && (skip_once_flag == 88)) // OK to turn on CREATE mode
			// 88 is a random value that do_once_flag is un-likely to have when initialized...this prevents the first  RESET causing CREATE mode to enter

		if ((skip_flag == 0) && (G_CREATE_mode == 0) && (G_GUI != 4)) // OK to turn on CREATE mode
		{

			Serial.print(F("BTCH: just before TURN_ON_CREATE_MODE"));
			Serial.println("");

			G_do_CREATE_mode = 1;  // flag that CREATE mode needs to be turned on
			TURN_ON_CREATE_MODE();  // turns on CREATE mode if SLAVE has control




			if (allow_transfer_flag == 1)
			{
				CLEAR_ALL_LEDS();
				SHOW_slow();

				BT_and_DC_CHECKandDO();
			}

		}

		skip_once_flag = 88;  // 88 is a random value that do_once_flag is un-likely to have when initialized

	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  zz Simplified GUI2 & GUI3 & GUI4 commands ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  zz Simplified GUI2 & GUI3 commands ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

	Serial.println(F(""));
	Serial.println(F(" BTCH: before command checks"));
	Serial.println(F(""));


	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 's'))   // GUI4 turn OFF MUSIC only mode  zzs
	{
		G_music_only_switch = 0;
	}

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'r'))   // GUI4 turn ON MUSIC only mode   zzr
	{
		G_music_only_switch = 1;
		MIC_ON_OFF(1);  // turn on MIC
		MODIFY_GUI4(8);  // turn on MIC switch
	}


	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'q'))   // GUI4 MIC gain slider  zzq
	{
		G_MIC_gain = atoi(text_array);  // get the dimming value from the slider

		SerialBT.print("*O");  // update GUI4 text
		SerialBT.print(int(G_MIC_gain));
		SerialBT.print("*");

		G_MIC_gain = G_MIC_gain / 100;
	}

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'p'))   // GUI4 previous SHOW arrow  zzp
	{
		--G_next_show;

		int number_shows_in_production = TOTAL_SHOWS_IN_PRODUCTION();

		if (G_next_show < 1)
		{
			G_next_show = number_shows_in_production;  // roll over to last show in production; 
		}



		//if (G_next_show < 1) { G_next_show = 1; }

		SerialBT.print("*K");  // update GUI4 text
		SerialBT.print(G_next_show);
		SerialBT.print("*");
	}


	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'o'))   // GUI4 next SHOW arrow
	{
		++G_next_show;

		int number_shows_in_production = TOTAL_SHOWS_IN_PRODUCTION();

		if (G_next_show > number_shows_in_production)
		{
			G_next_show = 1;  // roll over to 1; 
		}



		//switch (G_production) 
		//{
		//	case 1:
		//		if (G_next_show > NUMBER_OF_PRODUCTION1_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION1_SHOWS ; }
		//		break;
		//	case 2:
		//		if (G_next_show > NUMBER_OF_PRODUCTION2_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION2_SHOWS ; }
		//		break;
		//	case 3:
		//		if (G_next_show > NUMBER_OF_PRODUCTION3_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION3_SHOWS ; }
		//		break;
		//	case 4:
		//		if (G_next_show > NUMBER_OF_PRODUCTION4_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION4_SHOWS ; }
		//		break;
		//	case 5:
		//		if (G_next_show > NUMBER_OF_PRODUCTION5_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION5_SHOWS ; }
		//		break;

		//	default:
		//		// statements
		//		break;
		//}


		SerialBT.print("*K");  // update GUI4 text
		SerialBT.print(G_next_show);
		SerialBT.print("*");
	}



	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'n'))   // MIC enable OFF GUI4  zzn
	{

		MIC_ON_OFF(0); // turn mic off
		G_music_only_switch = 0;
		MODIFY_GUI4(21);  // turn off MUSIC ONLY switch
	}



	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'm'))   // MIC enable ON GUI4   zzm
	{

		MIC_ON_OFF(1); // turn mic ON

	}


	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'l'))   // LOAD SHOW button  zzl  
	{

		switch (G_production)
		{
		case 1:
			if (G_next_show > NUMBER_OF_PRODUCTION1_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION1_SHOWS; }
			break;
		case 2:
			if (G_next_show > NUMBER_OF_PRODUCTION2_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION2_SHOWS; }
			break;
		case 3:
			if (G_next_show > NUMBER_OF_PRODUCTION3_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION3_SHOWS; }
			break;
		case 4:
			if (G_next_show > NUMBER_OF_PRODUCTION4_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION4_SHOWS; }
			break;
		case 5:
			if (G_next_show > NUMBER_OF_PRODUCTION5_SHOWS) { G_next_show = NUMBER_OF_PRODUCTION5_SHOWS; }
			break;

		default:
			// statements
			break;
		}

		G_forced_show = 0;
		MODIFY_GUI4(4);  // turn off SHOW LOCK switch

		if (G_next_show != G_show_num)
		{
			SerialBT.print("*K");  // update GUI4 text
			SerialBT.print(G_next_show);
			SerialBT.print("*");

			G_show_num = G_next_show;
			G_interceeded_flag = 1;  // force the selected show in SHOW handler

		}




	}


	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'k'))   // LOAD PRODUCTION button  zzk
	{

		if ((G_production == 3) && (G_next_production != 3))  // make sure production 3 terminates
		{
			G_production3_counts = NUMBER_OF_TIMES_TO_EXECUTE_PRODUCTION3;
		}

		if (G_production != G_next_production)  // G_next_production is set by GUI4 LOAD
		{
			G_production = G_next_production;  //G_next_production is set in GUI4

			G_force_production_end = 1;
		}



		if (G_production >= FIRST_SOUND_PRODUCTION)  // sound production
		{
			//MODIFY_GUI4(8);  // set to MIC to enable
			MIC_ON_OFF(1);
			G_force_sound_productions = 1;  // enable sound productions
		}
		else
		{
			G_force_sound_productions = 0;
		}

		G_forced_production = 0;
		MODIFY_GUI4(2);  // turn off PRODUCTION LOCK

		G_forced_show = 0;
		MODIFY_GUI4(4);  // turn off SHOW LOCK

		G_next_show = 1;

		SerialBT.print("*K");  // update GUI4 text SHOW to LOAD
		SerialBT.print(G_next_show);
		SerialBT.print("*");


		RESET(2);

		G_start_next_production_flag = 1;  // insures G_next_production is executed

		G_music_start_time = 0;  // flag that this variable needs to be initialized ... prevents skipping SOUND productions, after a LOAD,  if executing PRODUCTIONS < 2

		Serial.print(F(" ---->>>>  zzk: G_production=  "));
		Serial.println(G_production);
		Serial.print(F("G_next_production=  "));
		Serial.println(G_next_production);
		Serial.print(F("G_force_show_end=  "));
		Serial.println(G_force_production_end);
		Serial.print(F("G_force_sound_productions=  "));
		Serial.println(G_force_sound_productions);
		Serial.print(F(""));
	}


	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'j'))   // REFRESH GUI4    zzj
	{
		REFRESH_GUI4();
		
		
	}




	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'i'))   // previous PRODUCTION button   zzi
	{
		//G_production = 2;  // specify which show to do : 1=DO_SHOW() or 2=DO_SHOW2()

		//G_GUI = 4;

		--G_next_production;

		if (G_next_production < 1)
		{
			G_next_production = 1;
		}


		SerialBT.print("*J");  // update GUI4 text
		SerialBT.print(G_next_production);
		SerialBT.print("*");

		//G_show_num = 253;  // set to last show 

	}


	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'h'))   // next PRODUCTION to LOAD button for GUI4  zzh
	{


		++G_next_production;

		if (G_next_production > NUMBER_OF_PRODUCTIONS)  // at this time there are 5 productions
		{
			G_next_production = NUMBER_OF_PRODUCTIONS;
		}

		SerialBT.print("*J");  // update GU4I text
		SerialBT.print(G_next_production);
		SerialBT.print("*");

		//	G_show_num = 253;  // set to last show 


	}



	///////////////////////////////////////////////////////////////////////////////////////////////////////////// 

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'g'))   // GUI3 FUN button : left arrow  zzg
	{

		GENERATE_IMAGE_IF_NONE(2);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		MINI_SHOW_5(3);

		//FATTEN_HOZ(1, 1);  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels
		//SHOW_slow();
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////// cdl

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'f'))   // GUI3 FUN button : right arrow   zzf
	{
		//FATTEN_HOZ(2, 1);  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels

		GENERATE_IMAGE_IF_NONE(1);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		MINI_SHOW_6(30);


	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////  

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'e'))   // GUI3 FUN button: up arrow   zze
	{

		//FATTEN_VERT(2, 1);  //FATTEN pixels by adding new pixels to dir=top down (1) or dir =bottom up (2)  , keep=1 to keep parent pixels

		GENERATE_IMAGE_IF_NONE(4);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		MINI_SHOW_7(30);



	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'd'))   // GUI3 FUN button: down arrow 
	{

		GENERATE_IMAGE_IF_NONE(3);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle
		MINI_SHOW_8(4);

	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'c'))   // GUI3 FUN button down-right arrow:   zzc
	{
		GENERATE_IMAGE_IF_NONE(2);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		MINI_SHOW_4(1);

	}



	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'b'))   // GUI3 FUN button up-left arrow: STAR mode 5    zzb
	{
		GENERATE_IMAGE_IF_NONE(1);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		STAR(15, 3);
	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'a'))   // GUI3 FUN button up-left arrow: STAR mode 5    zza
	{
		GENERATE_IMAGE_IF_NONE(4);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		STAR(15, 5);
	}


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'Y'))   // GUI3 proceedural button show , X button   zzY
	{
		//SAVE_BACKGROUND();

		GENERATE_IMAGE_IF_NONE(3);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		MINI_SHOW_3(8);

	}




	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'X'))   // GUI3 proceedural button show , O button   zzX
	{
		//	SAVE_BACKGROUND();
		GENERATE_IMAGE_IF_NONE(2);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		MINI_SHOW_2(3);

	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'W'))   // GUI3 proceedural button show , triangle button   zzW
	{
		GENERATE_IMAGE_IF_NONE(1);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle
		MINI_SHOW_1(10);


	}


	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'V'))   // GUI3: HAPPY BD text button   zzV
	{

		CONTINUOUS_SPECIAL_MODE_OFF();
		G_special_char_select = 1;

		String msg = "****HAPPY BIRTHDAY****";
		msg.toCharArray(scroll_text_array, sizeof(scroll_text_array));
		//stringSize = strlen(text_array);

		G_TEXT_flag = 1;  // need this variable to prevent false TEXT display 



		stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
		SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, -1, 0, 0, 2, 0);


		int duration = 45;

		RING_with_IMAGE(63, 0, duration, 2, 2, 0);

	}



	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'U'))   // GUI3: RANDOM RING button    zzU
	{

		// SIGNAL(213);  // generate a PURPLE test signal


		// select an image from the stored bitmaps

		int tot_num_bitmaps = BMP_MAP[0];   // store the total number of bitmaps at position 0
		int random_image = 1;
		byte random_depth = random(2, 10);
		int duration = 40;
		byte random_effect = random(0, 2);

		byte good_image_flag = 0;  // this is set to 1 if a non-excluded image is found

		while (good_image_flag == 0)
		{
			random_image = random(1, tot_num_bitmaps);
			good_image_flag = 1;

			for (int n = 0; n < BITmaps2ExcludeFromRandomRing; ++n)
			{
				if (random_image == bitmaps2exclude[n])
				{
					good_image_flag = 0;
				}
			}

		}

		RING_with_IMAGE(random_image, 0, duration, 2, random_depth, random_effect);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'T'))   // GUI3: 8 way RING pad     zzT
		//if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'T')&&(G_once_flag==0))   // GUI3: 8 way RING pad 
	{

		int position = atoi(text_array);  //  8way switch position

		Serial.print(F("++++  BTCH: command zzT: START:8way position ="));
		Serial.println(position);
		Serial.println("");

		if (position != 0)
		{

			//	SIGNAL(171, 3);  // generate a BLUE test signal
			//	SIGNAL(0, 3);  // generate a RED test signal

				//G_once_flag = 1; 


			byte skip = 0;

			TURN_OFF_PLAY_SAVES_MODE();
			//G_PLAY_SAVES_MODE_ON = 0;  // turn off play saves 
			G_special_saved_flag = 0;  // only show one character

			SEND_CYCLE_SLIDER(0);  // turn off cycle generator


			Serial.print(F("++++  BTCH: command zzT:1  position ="));
			Serial.println(position);
			Serial.print(F("++++  BTCH: G_special_slider ="));
			Serial.println(G_special_slider);
			Serial.println("");



			skip = BT_DELAY_FILTER();  // filter out multiple fast BT transfers to prevent a CRASH if commands issued too fast
			if ((skip == 1) && (position != 0))
			{
				Serial.println("");
				Serial.print(F("++++  BTCH: command zzT: executing a RETURN()"));
				Serial.println("");
				return;
			} // BT buffer was flushed don't execute command


			Serial.println("");
			Serial.print(F("++++  BTCH: zzT command:2   position ="));
			Serial.println(position);
			Serial.print(F("G_continuous_SPECIAL_mode ="));
			Serial.println(G_continuous_SPECIAL_mode);
			Serial.print(F("G_special ="));
			Serial.println(G_special);
			Serial.print(F("G_CREATE_mode ="));
			Serial.println(G_CREATE_mode);
			Serial.print(F("G_special_slider ="));
			Serial.println(G_special_slider);
			Serial.println("");


			byte depth2 = 2;
			byte depth4 = 4;
			byte depth8 = 8;

			G_continuous_SPECIAL_mode = 1;
			G_continuous_SPECIAL_mode_was_ON = 1;

			//	if (position == 0)  // position 0 is sent last from 8way

				//		G_BT_data_arrival = 0; // needed here to allow SHOW_fast to dispaly:  commented out on 11/29/21

				//switch (G_previous_position)
			switch (position)
			{
			case 0:
				//G_continuous_SPECIAL_mode = 0;
				//G_continuous_SPECIAL_mode_was_ON = 1;

				//Serial.print(F("BTCH: G_continuous_SPECIAL_mode="));
				//Serial.println(G_continuous_SPECIAL_mode);

				//for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)
				//{
				//	scroll_text_array[n] = '\0';
				//}
				break;
			case 1:
				G_cont_special_depth = depth2; // sets display depth in continuous special mode
				G_cont_special_effect = 0; // sets display EFFECT in continuous special mode
				break;
			case 2:
				G_cont_special_depth = depth8; // sets display depth in continuous special mode
				G_cont_special_effect = 1; // sets display EFFECT in continuous special mode, shift down 1
				break;
			case 3:
				G_cont_special_depth = depth8; // sets display depth in continuous special mode
				G_cont_special_effect = 2; // sets display EFFECT in continuous special mode, shift up 1
				break;
			case 4:
				G_cont_special_depth = depth2; // sets display depth in continuous special mode
				G_cont_special_effect = 5; // sets display EFFECT in continuous special mode, swap colors
				break;
			case 5:
				G_cont_special_depth = depth4; // sets display depth in continuous special mode
				G_cont_special_effect = 3; // sets display EFFECT in continuous special mode, vertical rainbow
				break;
			case 6:
				G_cont_special_depth = depth8; // sets display depth in continuous special mode
				G_cont_special_effect = 0; // sets display EFFECT in continuous special mode, horizontal rainbow (2 hue increment)
				break;
			case 7:
				G_cont_special_depth = depth4; // sets display depth in continuous special mode
				G_cont_special_effect = 0; // sets display EFFECT in continuous special mode, vertical rainbow
				break;
			case 8:
				G_cont_special_depth = depth8; // sets display depth in continuous special mode
				G_cont_special_effect = 4; // sets display EFFECT in continuous special mode, horizontal rainbow (5 hue increment)
				break;


			default:
				G_cont_special_depth = depth2; // sets display depth in continuous special mode
				G_cont_special_effect = 0; // sets display EFFECT in continuous special mo
				// if nothing else matches, do the default
				// default is optional
				break;
			}


			Serial.println(F("++++BTCH: zzT command :3  3rd POSITION  +++++"));
			Serial.print(F("++++BTCH: zzT command : G_continuous_SPECIAL_mode="));
			Serial.print(G_continuous_SPECIAL_mode);
			Serial.println("");

			// turn on continuous special mode
			if ((G_CREATE_mode == 1) && (G_continuous_SPECIAL_mode == 1))  // only allow continuous special mode in CREATE mode
			{

				//G_continuous_SPECIAL_mode = 1;
				//G_continuous_SPECIAL_mode_was_ON = 1;

				//Serial.print(F("BTCH: G_continuous_SPECIAL_mode="));
				//Serial.println(G_continuous_SPECIAL_mode);


				int encoded_image_number = GET_RINGED_IMAGE();
				int image_flag = 0; // if image_flag==0 then the image number refers to a FONT image 
				// if image_flag==1 then the image number refers to a saved image 

				int img = 0;
				int duration = 45;

				Serial.println("++++BTCH: zzT command:4  4th POSITION  +++++");
				Serial.print("encoded_image_number=");
				Serial.println(encoded_image_number);
				Serial.println("");

				if (encoded_image_number == 1) { image_flag = 0; }  // text image

				if ((encoded_image_number > 1000) && (encoded_image_number < 3000))
				{
					image_flag = 1;  // saved images start at 1001 and are passed with G_special_char_select, pre-made images are flaged with G_special_char_select=3000
					img = encoded_image_number - 1000;
				}



				if (image_flag == 0) // text image
				{


					Serial.println("++++BTCH: zzT command:5  5th POSITION  +++++");
					Serial.print("");

					//		G_TEXT_flag = 1;  // added 11/29/21 as an experiment
					SHOW_255();
				}
				else  // saved image
				{

					//	duration = 15;

					//	SIGNAL(0, 1);  // RED
					//	delay(100);
					RING_with_IMAGE(img, 0, duration, image_flag, G_cont_special_depth, G_cont_special_effect);

					//	SIGNAL(83, 1);  //GREEN



						//	RING_with_IMAGE(img, 0, 5, 0, 1, 0);  // experimental the above line is the correct version
				}



			}


			CONTINUOUS_SPECIAL_MODE_OFF();  // turn off continuous special mode

		}

	}






	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'S'))   // GUI3: 8 way COLOR pad    zzS
	{
		byte image_generated; // equals 1 if an image was generated

		G_BT_cmd = 3; // arbitrary number assignment

		SEND_CYCLE_SLIDER(0);  // turn off cycle generator

		image_generated = GENERATE_IMAGE_IF_NONE(1);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		if ((image_generated == 0) && (G_BT_cmd_previous != G_BT_cmd)) // save image if first time using this 8way and if no random image was generated
		{
			SAVE_DISPLAY_to_BUFFER();  // allow for an undo
		}

		G_BT_cmd_previous = G_BT_cmd;

		//G_PLAY_SAVES_MODE_ON = 0;  // turn off play saves 
		TURN_OFF_PLAY_SAVES_MODE();
		G_transformation = atoi(text_array);  // get the transformation value from the control pad
		DO_COLOR_TRANSFORMATION(G_transformation, 1);
		SHOW_slow();
	}



	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'R'))   // GUI3: 8 way TRANSLATE pad   zzR
	{
		byte image_generated; // equals 1 if an image was generated

		G_BT_cmd = 2; // arbitrary number assignment

		SEND_CYCLE_SLIDER(0);  // turn off cycle generator

		image_generated = GENERATE_IMAGE_IF_NONE(3);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		if ((image_generated == 0) && (G_BT_cmd_previous != G_BT_cmd)) // save image if first time using this 8way and if no random image was generated
		{
			SAVE_DISPLAY_to_BUFFER();  // allow for an undo
		}

		G_BT_cmd_previous = G_BT_cmd;


		//G_PLAY_SAVES_MODE_ON = 0;  // turn off play saves
		TURN_OFF_PLAY_SAVES_MODE();
		G_transformation = atoi(text_array);  // get the transformation value from the slider
		DO_TRANSFORMATION(G_transformation);
		SHOW_slow();
	}




	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'Q'))   // GUI3: CYCLE 8way pad  zzQ
	{
		byte image_generated; // equals 1 if an image was generated

		G_BT_cmd = 1; // arbitrary number assignment

		G_cycle = atoi(text_array);  // get the transformation value from the slider

		image_generated = GENERATE_IMAGE_IF_NONE(4);  // generate a random image if there isn't any displayed
		// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle

		if ((image_generated == 0) && (G_BT_cmd_previous != G_BT_cmd)) // save image if first time using this 8way and if no random image was generated
		{
			SAVE_DISPLAY_to_BUFFER();  // allow for an undo
			SAVE_BACKGROUND();
		}


		//G_cycle = text_array[3] - 48;  // convert 8way pad position ascii to a value,  48=ascii 0 

		Serial.println("");
		Serial.print(F("%%%%%--->  BTCH: zzQ command:   G_cycle ="));
		Serial.println(G_cycle);
		Serial.print(F("G_pervious_cycle ="));
		Serial.println(G_pervious_cycle);
		Serial.print(F("BT message: G_message ="));
		Serial.println(G_message);
		Serial.println("");

		// turn off previous cycle generator
	//G_PLAY_SAVES_MODE_ON = 0;  // turn off play saves
		TURN_OFF_PLAY_SAVES_MODE();
		G_cycle_gen_on = 0;

		//SEND_CYCLE_SLIDER(G_pervious_cycle);
		SEND_CYCLE_SLIDER(0);  // turn off previous cycles

		if ((G_pervious_cycle != 6) || (G_pervious_cycle != 7))// Xbounce, Ybounce ... prevent overwriting bounce array 
		{
			SET_BOUNCE_ARRAY(1);
		}

		if (G_pervious_cycle != 8) // Xbounce ... prevent overwriting bounce array 
		{
			SET_BOUNCE_ARRAY(1);
			SET_BOUNCE_ARRAY_X(0, 5, -1);
			SET_BOUNCE_ARRAY_X(15, 21, -1);
		}


		G_pervious_cycle = G_cycle;

		// turn on cycle generator
		G_cycle_gen_on = 1;  // set to 1 to turn on cycle generator


		SEND_CYCLE_SLIDER(G_cycle);



	}
	else  //need to turn off it stuck ON...which happens
	{
		G_cycle_gen_on = 0;
		SEND_CYCLE_SLIDER(0);  // turn off previous cycles
	}



	/////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'P'))   // continuous image EFFECT   zzP
	{
		int image_effect = atoi(text_array);  // get the special character selection from slider
		byte depth1 = 1;
		byte depth2 = 4;
		byte depth3 = 8;


		switch (image_effect)
		{
		case 0:
			G_cont_special_depth = depth1; // sets display depth in continuous special mode
			G_cont_special_effect = 0; // sets display EFFECT in continuous special mode
			break;
		case 1:
			G_cont_special_depth = depth2; // sets display depth in continuous special mode
			G_cont_special_effect = 0; // sets display EFFECT in continuous special mode
			break;
		case 2:
			G_cont_special_depth = depth3; // sets display depth in continuous special mode
			G_cont_special_effect = 0; // sets display EFFECT in continuous special mode
			break;
		case 3:
			G_cont_special_depth = depth1; // sets display depth in continuous special mode
			G_cont_special_effect = 1; // sets display EFFECT in continuous special mode
			break;
		case 4:
			G_cont_special_depth = depth2; // sets display depth in continuous special mode
			G_cont_special_effect = 1; // sets display EFFECT in continuous special mode
			break;
		case 5:
			G_cont_special_depth = depth3; // sets display depth in continuous special mode
			G_cont_special_effect = 1; // sets display EFFECT in continuous special mode
			break;
		case 6:
			G_cont_special_depth = depth1; // sets display depth in continuous special mode
			G_cont_special_effect = 2; // sets display EFFECT in continuous special mode
			break;
		case 7:
			G_cont_special_depth = depth2; // sets display depth in continuous special mode
			G_cont_special_effect = 2; // sets display EFFECT in continuous special mode
			break;
		case 8:
			G_cont_special_depth = depth3; // sets display depth in continuous special mode
			G_cont_special_effect = 2; // sets display EFFECT in continuous special mode
			break;
		case 9:
			G_cont_special_depth = depth1; // sets display depth in continuous special mode
			G_cont_special_effect = 3; // sets display EFFECT in continuous special mode
			break;
		case 10:
			G_cont_special_depth = depth2; // sets display depth in continuous special mode
			G_cont_special_effect = 3; // sets display EFFECT in continuous special mode
			break;
		case 11:
			G_cont_special_depth = depth3; // sets display depth in continuous special mode
			G_cont_special_effect = 3; // sets display EFFECT in continuous special mode
			break;
		case 12:
			G_cont_special_depth = depth1; // sets display depth in continuous special mode
			G_cont_special_effect = 4; // sets display EFFECT in continuous special mode
			break;
		case 13:
			G_cont_special_depth = depth2; // sets display depth in continuous special mode
			G_cont_special_effect = 4; // sets display EFFECT in continuous special mode
			break;
		case 14:
			G_cont_special_depth = depth3; // sets display depth in continuous special mode
			G_cont_special_effect = 4; // sets display EFFECT in continuous special mode
			break;
		case 15:
			G_cont_special_depth = depth1; // sets display depth in continuous special mode
			G_cont_special_effect = 5; // sets display EFFECT in continuous special mode
			break;
		case 16:
			G_cont_special_depth = depth2; // sets display depth in continuous special mode
			G_cont_special_effect = 5; // sets display EFFECT in continuous special mode
			break;
		case 17:
			G_cont_special_depth = depth3; // sets display depth in continuous special mode
			G_cont_special_effect = 6; // sets display EFFECT in continuous special mode
			break;

		case 18:
			G_cont_special_depth = depth3; // sets display depth in continuous special mode
			G_cont_special_effect = 7; // sets display EFFECT in continuous special mode
			break;

		default:
			G_cont_special_depth = depth1; // sets display depth in continuous special mode
			G_cont_special_effect = 0; // sets display EFFECT in continuous special mo
			// if nothing else matches, do the default
			// default is optional
			break;
		}

	}





	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'O'))   // PLAY SAVES switch OFF   zzO
	{
		//G_PLAY_SAVES_MODE_ON = 0;

		TURN_OFF_PLAY_SAVES_MODE();

		//DC_OUT_array[0] = 50;
		//DC_OUT_array[1] = 0;
		//DC_SEND();


		G_EFFECT_slider = NUM_RANDOM_IMAGES;

		if (G_EFFECT_slider != G_EFFECT_slider_previous)
		{
			MODIFY_GUI2(5); // preset EFFECT slider
			G_EFFECT_slider_previous = G_EFFECT_slider;
		}



	}




	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'N'))   // PLAY SAVES switch ON   zzN
	{
		byte there_are_saved_images = 0;

		// check if there are SAVED images
		for (byte n = 1; n < maximum_number_of_SAVED_images + 1; ++n)
		{
			if (G_SAVED[n] == 1)
			{
				there_are_saved_images = 1;
			}
		}

		Serial.println("");
		Serial.print(F("BTCH: zzN : there_are_saved_images= "));
		Serial.println(there_are_saved_images);
		Serial.println("");


		if ((there_are_saved_images == 1) && (G_executing_CREATE_mode == 1)) // allow for PLAY SAVES switch to be on in CREATE MODE
		{
			/*DC_OUT_array[0] = 50;
			DC_OUT_array[1] = 1;
			DC_SEND();*/

			G_PLAY_SAVES_MODE_ON = 1;

			G_SPEED_slider = 6;  // also set in MASTER with MODIFY_GUI2(4)

			G_EFFECT_slider = 10; // also set in MASTER with MODIFY_GUI2(5)

			if (G_EFFECT_slider != G_EFFECT_slider_previous)
			{
				MODIFY_GUI2(5); // preset EFFECT slider
				G_EFFECT_slider_previous = G_EFFECT_slider;
			}


			//NOTE: G_SPEED_slider and G_EFFECT_slider in SLAVE are set in PLAY_SAVES_SHOW() in SLAVE
			MODIFY_GUI2(4); // preset SPEED slider
			//MODIFY_GUI2(5); // preset EFFECT slider

			// turn off CYCLE switch
			G_CYCLE_ON = 0;
			//DC_OUT_array[1] = 0;
			G_cycle_gen_on = 0;  // set to 1 to turn on cycle generator
			SEND_CYCLE_SLIDER(G_pervious_cycle);
			MODIFY_GUI2(6); // turn off cycle slider switch

			//turn off TRANS switch
			G_TRANS_SWITCH = 0;
			MODIFY_GUI2(7); // turn off TRANS slider switch

			//turn off COLOR slider switch
			G_COLOR_CYCLE_SWITCH_ON = 0;
			// turn off cycle generator
			//DC_OUT_array[1] = 0;
			G_color_cycle_gen_on = 0;  // set to 1 to turn on cycle generator
			SEND_COLOR_SLIDER(G_pervious_color_cycle);
			MODIFY_GUI2(8); // turn off COLOR slider switch

			CONTINUOUS_SPECIAL_MODE_OFF();

		}
		else
		{
			MODIFY_GUI2(3); // turn off PLAY SAVES switch, needed as PLAY SAVES may not be on
			MODIFY_GUI3(3); //turn off PLAY SAVES switch, needed as PLAY SAVES may not be on
			TURN_OFF_PLAY_SAVES_MODE();
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'M'))   // CYCLE COLOR button   zzM
	{
		if (G_COLOR_CYCLE_SWITCH_ON == 0)  // only execute if color CYCLE switch is OFF
		{

			// turn on color cycle generator
			//DC_OUT_array[1] = 1;
			G_color_cycle_gen_on = 1;  // set to 1 to turn on cycle generator
			G_pervious_color_cycle = G_COLOR_cycle;
			SEND_COLOR_SLIDER(G_COLOR_cycle);

			/*DC_OUT_array[0] = 49;
			DC_SEND();*/

			G_COLOR_CYCLE_BUTTON_pressed = 1;
		}


	}


	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'L'))   // CYCLE COLOR switch off   zzL
	{

		G_COLOR_CYCLE_SWITCH_ON = 0;

		// turn on cycle generator
		//DC_OUT_array[1] = 0;
		G_color_cycle_gen_on = 0;  // set to 1 to turn on cycle generator

		SEND_COLOR_SLIDER(G_pervious_color_cycle);
	}





	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'K'))   // CYCLE COLOR switch on   zzK
	{

		G_COLOR_CYCLE_SWITCH_ON = 1;

		// turn on cycle generator
		//DC_OUT_array[1] = 1;
		G_color_cycle_gen_on = 1;  // set to 1 to turn on cycle generator

		G_pervious_color_cycle = G_COLOR_cycle;

		SEND_COLOR_SLIDER(G_COLOR_cycle);
	}





	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'J'))   // send COLOR slider (note: not the same as HUE slider)   zzJ
	{
		G_COLOR_cycle = atoi(text_array);  // get the color transformation value from the slider

		SerialBT.print("*E");  // update GUI2 text
		SerialBT.print(G_COLOR_cycle);
		SerialBT.print("*");

		if (G_COLOR_CYCLE_SWITCH_ON == 1)  // allow for immediate change in cycle generator
		{

			// turn off previous cycle generator
			//DC_OUT_array[1] = 0;
			G_color_cycle_gen_on = 0;  // set to 1 to turn on cycle generator

			SEND_COLOR_SLIDER(G_pervious_cycle);

			G_pervious_color_cycle = G_COLOR_cycle;

			// turn on color cycle generator
			//DC_OUT_array[1] = 1;
			G_color_cycle_gen_on = 1;  // set to 1 to turn on cycle generator

			SEND_COLOR_SLIDER(G_COLOR_cycle);

		}

	}



	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'I'))   // TRANS switch OFF   zzI
	{
		/*DC_OUT_array[0] = 47;
		DC_OUT_array[1] = 0;
		DC_SEND();*/

		G_TRANS_SWITCH = 0;
	}



	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'H'))   // TRANS switch ON   zzH
	{
		/*DC_OUT_array[0] = 47;
		DC_OUT_array[1] = 1;
		DC_SEND();*/

		G_TRANS_SWITCH = 1;
	}




	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'G'))   // CYCLE  button   zzG
	{
		if (G_CYCLE_ON == 0)  // only execute if CYCLE switch is OFF
		{

			// turn on cycle generator
			//DC_OUT_array[1] = 1;
			G_cycle_gen_on = 1;  // set to 1 to turn on cycle generator
			G_pervious_cycle = G_cycle;
			SEND_CYCLE_SLIDER(G_cycle);

			/*DC_OUT_array[0] = 46;
			DC_SEND();*/

			G_CYCLE_BUTTON_pressed = 1;
		}
	}


	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'F'))   // CYCLE  switch off   zzF
	{

		G_CYCLE_ON = 0;

		// turn off previous cycle
		//DC_OUT_array[1] = 0;
		G_cycle_gen_on = 0;  // set to 1 to turn on cycle generator

		SEND_CYCLE_SLIDER(G_pervious_cycle);

	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'E'))   // CYCLE  switch on    zzE
	{

		G_CYCLE_ON = 1;

		// turn on cycle generator
		//DC_OUT_array[1] = 1;
		G_cycle_gen_on = 1;  // set to 1 to turn on cycle generator

		G_pervious_cycle = G_cycle;

		SEND_CYCLE_SLIDER(G_cycle);
	}




	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'D'))   // CYCLE slider    zzD
	{
		G_cycle = atoi(text_array);  // get the transformation value from the slider

		SerialBT.print("*B");  // update GUI2 text
		SerialBT.print(G_cycle);
		SerialBT.print("*");

		if (G_CYCLE_ON == 1)  // allow for immediate change in cycle generator
		{

			// turn off previous cycle generator
			//DC_OUT_array[1] = 0;
			G_cycle_gen_on = 0;  // set to 1 to turn on cycle generator

			SEND_CYCLE_SLIDER(G_pervious_cycle);

			G_pervious_cycle = G_cycle;

			// turn on cycle generator
			//DC_OUT_array[1] = 1;
			G_cycle_gen_on = 1;  // set to 1 to turn on cycle generator

			SEND_CYCLE_SLIDER(G_cycle);

		}

	}





	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'C'))   // change GUI command    zzC
	{
		byte skip = 0;

		if (G_GUI == 4)
		{

			//Serial.println(F(""));
			//Serial.print(F("zzC start: G_dim= "));
			//Serial.println(G_dim);
			//Serial.println(F(""));
			
			skip = 1; // don't execute the next IF
			G_GUI = 3;

			GUI3();

			/// add code to highlight SAVED lights and set the SHAPE slider and COLOR slider correctly
			MODIFY_GUI3(1);  // set brightness
			MODIFY_GUI3(4);  // update slider text
			SET_HUE_COLOR_INDICATOR();



		}

		if ((G_GUI == 3) && (skip == 0))
		{
			//G_GUI = 4;

			//GUI4();

			REFRESH_GUI4();  // set G_GUI=4 and refresh settings

			delay(50);

			

		}


		Serial.println(F(""));
		Serial.println(F("@@@@@@@@@@ BTCH:   GUI change command"));
		Serial.print(F("G_GUI="));
		Serial.println(G_GUI);
		Serial.print(F("100*G_MIC_gain="));
		Serial.println(int(100 * G_MIC_gain));
		Serial.print(F(" G_dim= "));
		Serial.println(G_dim);
		Serial.println(F(""));

	

	}


	///////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'B'))   // TRANSFORMATION button    zzB
	{
		switch (G_transformation) {
		case 1:
			//DC_OUT_array[0] = 23;  // FLIP
			FLIP_DISPLAY();
			break;
		case 2:
			//DC_OUT_array[0] = 24;  // XY swap
			XY_SWAP();
			break;
		case 3:
			//DC_OUT_array[0] = 25;  // side flip
			SIDE_FLIP_DISPLAY();
			break;
		case 4:
			//DC_OUT_array[0] = 29;  // flip vertically around mid display
			FLIP_MID_VERT();
			break;
		case 5:
			//DC_OUT_array[0] = 30;  // flip horizontally around mid display
			FLIP_MID_HOZ();
			break;
		case 6:
			//DC_OUT_array[0] = 31;  // square flip horizontal
			FLIP_SQUARE_HOZ();
			break;
		case 7:
			//DC_OUT_array[0] = 32;  // square flip vertical
			FLIP_SQUARE_VERT();
			break;
		default:
			// statements
			break;
		}

		SHOW_slow();

		//	DC_SEND();
	}



	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'z') && (G_BT_command3 == 'A'))   // TRANSFORMATION slider  zzA
	{
		G_transformation = atoi(text_array);  // get the transformation value from the slider

		SerialBT.print("*C");  // update GUI2 text
		SerialBT.print(G_transformation);
		SerialBT.print("*");

		/*DC_OUT_array[0] = 48;
		DC_OUT_array[1] = G_transformation;
		DC_SEND();*/

	}

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ end of zz commands ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'Y'))   // turn off SHOW lock for GUI4   zY
	{
		G_forced_show = 0;
		//G_GUI = 4;
		MODIFY_GUI4(4);

	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'X'))   // turn on SHOW lock for GUI4  zX
	{
		G_forced_show = G_show_num;
		//G_GUI = 4;
		MODIFY_GUI4(3);

	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'W'))   // turn off PRODUCTION lock for GUI4   zW
	{
		G_forced_production = 0;
		//G_GUI = 4;
		MODIFY_GUI4(2);

	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'V'))   // turn on PRODUCTION lock for GUI4  zV
	{

		G_forced_production = G_production;
		//G_GUI = 4;
		MODIFY_GUI4(1);
	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'U'))   // TURN off HALL SYNC  zU
	{
		G_Hall_sync = 0;

		//DC_OUT_array[0] = 52;
		//DC_OUT_array[1] = 0;  // off
		//DC_SEND();

	}

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ end of zz commands ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'T'))   // TURN on HALL SYNC  zT
	{
		G_Hall_sync = 1;

		//DC_OUT_array[0] = 52;
		//DC_OUT_array[1] = 1;  // on
		//DC_SEND();

	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'S'))   // RAND HUE OFF  zS
	{
		//DC_OUT_array[0] = 45;  // RAND HUE 
		//DC_OUT_array[1] = 0;  // off
		//DC_SEND();

		G_RAND_HUE = 0;

	}
	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'R'))   // RAND HUE ON  zR
	{
		//DC_OUT_array[0] = 45;  // RAND HUE 
		//DC_OUT_array[1] = 1;  // ON
		//DC_SEND();

		G_RAND_HUE = 1;

	}

	////////////////////////////////////////////////////////////////

	if ((G_BT_command == 'z') && (G_BT_command2 == 'Q'))   // not implimented  zQ
	{
		//DC_OUT_array[0] = 44; // not implimented
		//DC_SEND();

	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'P'))   // GEN command zP
	{
		//DC_OUT_array[0] = 43; // initiate a GEN command 
		//DC_SEND();

		G_GEN = 1;
		G_EFFECT_slider = NUM_RANDOM_IMAGES; // sets the number of random images drawn

		while (G_geometery == 1)  // DOTs mode
		{
			G_geometery = random(0, 4);  // chose a geometry other than DOTS
		}

		MODIFY_GUI3(4);
		MODIFY_GUI3(8);  // update geometry slider
		MODIFY_GUI3(9);  // turn on RANDOM HUE switch
		G_RAND_HUE = 1;
	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'O'))   // cycle saves off  zO
	{
		//DC_OUT_array[0] = 42;
		//DC_OUT_array[1] = 0; // turn off 
		//DC_SEND();

		G_CYCLE_SAVES = 0;

	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'N'))  // cycle saves on  zN
	{
		//DC_OUT_array[0] = 42;
		//DC_OUT_array[1] = 1; // turn on 
		//DC_SEND();

		G_CYCLE_SAVES = 1;
	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'M'))  // EFFECT slider  zM
	{
		// remove the first character from "text_array" = "z" , shift text_array down by 1
		/*for (int n = 0; n < stringSize + 1; ++n)
		{
			text_array[n] = text_array[n + 1];
		}*/

		byte effect = atoi(text_array);  // get the effect value from the slider

		SerialBT.print("*D");  // update GUI2 text
		SerialBT.print(effect);
		SerialBT.print("*");

		//DC_OUT_array[0] = 41;  // EFFECT slider
		//DC_OUT_array[1] = speed;  // send speed data:  1 to 10 
		//DC_SEND();

		G_EFFECT_slider = effect;
	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'L'))  // LOAD zL
	{
		//DC_OUT_array[0] = 40;

		if (G_BT_command3 == '1')
		{
			//DC_OUT_array[1] = 1;  // load 1
			LOAD_SAVE(1);  // load leds_save1[] into all panels
		}
		if (G_BT_command3 == '2')
		{
			//DC_OUT_array[1] = 2;  // load 2
			LOAD_SAVE(2);  // load leds_save2[] into all panels
		}
		if (G_BT_command3 == '3')
		{
			//DC_OUT_array[1] = 3;  // load 3
			LOAD_SAVE(3);  // load leds_save3[] into all panels
		}
		if (G_BT_command3 == '4')
		{
			//DC_OUT_array[1] = 4;  // load 4
			LOAD_SAVE(4);  // load leds_save4[] into all panels
		}
		if (G_BT_command3 == '5')
		{
			//DC_OUT_array[1] = 5;  // load 5
			LOAD_SAVE(5);  // load leds_save5[] into all panels
		}

		SHOW_slow();
		//DC_SEND();

		Serial.print(F("="));
		Serial.println(F("BTCH: LOAD command "));
		//DUMP_LED_ARRAY(leds_saved[1], NUM_LEDS);
		Serial.print(F("="));

	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'K'))  // SAVE   zK
	{
		//DC_OUT_array[0] = 39;

		G_KEEP = 1;  // keep generate command creation
		byte image_num = 0;
		byte non_zero_flag = 0;

		if (G_BT_command3 == '1')
		{
			image_num = 1;  // save 1
		}
		if (G_BT_command3 == '2')
		{
			image_num = 2;  // save 2
		}
		if (G_BT_command3 == '3')
		{
			image_num = 3;  // save 3
		}
		if (G_BT_command3 == '4')
		{
			image_num = 4;  // save 4
		}
		if (G_BT_command3 == '5')
		{
			image_num = 5;  // save 5
		}


		// save and check for non-zero save
		for (int n = 0; n < NUM_LEDS; ++n)
		{

			leds_saved[image_num][n] = leds1[n];
			if ((leds1[n].r > 0) || (leds1[n].g > 0) || (leds1[n].b > 0))
			{
				non_zero_flag = 1;
			}

		}




		/*if (leds1 > 0)
		{
			non_zero_flag = 1;
		}*/

		Serial.println(F("BTCH: SAVE command "));
		Serial.print(F("non_zero_flag="));
		Serial.println(non_zero_flag);
		Serial.print(F("image_num="));
		Serial.println(image_num);
		Serial.println("");

		//	DUMP_LED_ARRAY(leds1, NUM_LEDS);





			// only allow cycling of non-zero images in CREATE_MODE

		if (non_zero_flag == 1)// non-zero data saved
		{
			G_SAVED[image_num] = 1;
		}
		else
		{
			G_SAVED[image_num] = 0;
		}

		/////////////////
		byte at_least_one_SAVED_image = 0;

		for (byte n = 1; n < maximum_number_of_SAVED_images + 1; ++n)  // turn the appropriate SAVE indicator light to the correct color
		{
			if (G_SAVED[n] == 1)
			{
				//String BT_string2send = String("*MR" + String(leds1[0].r) + "G" + String(leds1[0].g) + "B" + String(leds1[0].b) + "*");

				String BT_string2send = String("*" + String(n) + "R" + String(255) + "G" + String(255) + "B" + String(255) + "*");  // send WHITE to indicator
				SerialBT.print(BT_string2send);  // turn indicator to HUE color

				at_least_one_SAVED_image = 1;
			}
			else
			{
				String BT_string2send = String("*" + String(n) + "R" + String(0) + "G" + String(0) + "B" + String(0) + "*");  // send DARK to indicator
				SerialBT.print(BT_string2send);  // turn indicator to HUE color
			}

		}

		if (at_least_one_SAVED_image == 0)
		{
			Serial.println(F("BTCH: TURN_OFF_PLAY_SAVES_MODE() "));
			Serial.println("");

			TURN_OFF_PLAY_SAVES_MODE();
		}

		//DC_SEND();

	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'J'))  // AUTO DIM switch OFF   zJ
	{
		//DC_OUT_array[0] = 37;
		//DC_OUT_array[1] = 0; // turn off AUTO-DIM
		//DC_SEND();

		G_AUTO_DIM = 0;

	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'I'))  // AUTO DIM switch ON   zI
	{
		//DC_OUT_array[0] = 37;
		//DC_OUT_array[1] = 1; // turn on AUTO-DIM
		//DC_SEND();

		G_AUTO_DIM = 1;
	}



	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'H'))  // CONT_GEN function off   zH
	{
		//DC_OUT_array[0] = 38;
		//DC_OUT_array[1] = 0; // turn off random CONG_GEN generator
		//DC_SEND();

		G_CONT_GEN = 0;
	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'G'))  // CONT_GEN function ON   zG
	{
		//DC_OUT_array[0] = 38;
		//DC_OUT_array[1] = 1; // turn on random CONT_GEN generator
		//DC_SEND();

		G_GEN = 1;
		G_CONT_GEN = 1;
	}


	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'F'))  // Vroll switch OFF   zF
	{
		//DC_OUT_array[0] = 36;
		//DC_OUT_array[1] = 0; // turn off vertical roll
		//DC_SEND();

		G_Vroll = 0;
	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'E'))  // Vroll switch ON   zE
	{
		//DC_OUT_array[0] = 36;
		//DC_OUT_array[1] = 1; // turn on vertical roll
		//DC_SEND();

		G_Vroll = 1;
	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'D'))  // Hroll switch OFF   zD
	{
		//DC_OUT_array[0] = 35;
		//DC_OUT_array[1] = 0; // turn of horizontal roll
		//DC_SEND();

		G_Hroll = 0;
	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'C'))  // Hroll switch ON  zC
	{
		//DC_OUT_array[0] = 35;
		//DC_OUT_array[1] = 1; // turn on horizontal roll
		//DC_SEND();

		G_Hroll = 1;
	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'B'))  // RESET the GUI positions   zB
	{

		RESET(1);



	}

	////////////////////////////////////////////////////////////////
	if ((G_BT_command == 'z') && (G_BT_command2 == 'A'))  // FLIP_SQUARE_HOZ  zA
	{
		//DC_OUT_array[0] = 32;  // QUAD flip the display
		//DC_SEND();

		FLIP_SQUARE_VERT();
		SHOW_slow();

	}


	////////////////////////////////////////////////////////////////
	if (G_BT_command == 'y')  // QUAD flip  y@
	{
		//DC_OUT_array[0] = 31;  // QUAD flip the display
		//DC_SEND();

		FLIP_SQUARE_HOZ();
		SHOW_slow();

	}

	////////////////////////////////////////////////////////////////
	if (G_BT_command == 'x')  // flip DIAG2  x@
	{
		//DC_OUT_array[0] = 30;  // flip the display around the middle of the display... vertically
		//DC_SEND();

		FLIP_MID_HOZ();
		SHOW_slow();

	}

	////////////////////////////////////////////////////////////////
	if (G_BT_command == 'w')  // flip the display around the middle of the display... vertically  w@
	{
		//DC_OUT_array[0] = 29;  // flip the display around the middle of the display... vertically
		//DC_SEND();

		FLIP_MID_VERT();
		SHOW_slow();

	}


	////////////////////////////////////////////////////////////////
	if (G_BT_command == 'v')  // turn off "continuous special" mode  v@
	{
		/*DC_OUT_array[0] = 28;
		DC_OUT_array[1] = 0;
		DC_SEND();*/

		G_continuous_SPECIAL_mode = 0;

		Serial.print(F("DC_CHECK_AND_DO: G_continuous_SPECIAL_mode="));
		Serial.println(G_continuous_SPECIAL_mode);

		for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)
		{
			scroll_text_array[n] = '\0';
		}

	}

	////////////////////////////////////////////////////////////////
	//if ((G_BT_command == 'u') && (G_special_slider > 0) && (G_CREATE_mode == 1))  // turn on "continuous special" mode
	if (G_BT_command == 'u')  // turn on "continuous special" mode  u@
	{
		//Serial.println(F("---------> BTCH  BTC=u  <----------"));	
		//Serial.println("");

		if ((G_CREATE_mode == 1) && (G_special_slider > 0))  // only allow continuous special mode in CREATE mode
		{
			/*DC_OUT_array[0] = 28;
			DC_OUT_array[1] = 1;
			DC_SEND();*/

			G_continuous_SPECIAL_mode = 1;
			G_continuous_SPECIAL_mode_was_ON = 1;

			Serial.print(F("BTCH: G_continuous_SPECIAL_mode="));
			Serial.println(G_continuous_SPECIAL_mode);

			if (allow_transfer_flag == 1)  // this prevents delay when continuous special mode selected
			{
				SHOW_255();
			}
		}
		else
		{
			CONTINUOUS_SPECIAL_MODE_OFF();  // turn off continuous special mode
		}
	}


	/////////////////////////////////////////////////////////////
	if (G_BT_command == 't')  //add special TEXT characters/pictures to TEXT...SLIDER   t@
	{
		//SIGNAL(42); // YELLOW signal

		G_special_slider = atoi(text_array);  // get the special character selection from slider

		if (G_GUI == 3)
		{
			SerialBT.print("*G");  // update GUI text
			SerialBT.print(G_special_slider);
			SerialBT.print("*");
			delay(50);
		}

		if (G_GUI != 3)
		{
			GET_RINGED_IMAGE();
		}

		Serial.print(F("BTCH: t: G_special_slider ="));
		Serial.println(G_special_slider);
		Serial.println("");

		//G_special_saved_flag = 0;

		//switch (G_special_slider)
		//{
		//case 0:

		//	if (G_GUI != 3)
		//	{
		//		CONTINUOUS_SPECIAL_MODE_OFF();
		//	}
		//	else
		//	{
		//		G_special = '*';
		//	}
		//	break;
		//case 1:
		//	G_special = '*';
		//	break;
		//case 2:
		//	G_special = '%';
		//	break;
		//case 3:
		//	G_special = '#';
		//	break;
		//case 4:
		//	G_special = '^';
		//	break;
		//case 5:
		//	G_special = '~';
		//	break;
		//default:

		//	// if nothing else matches, do the default
		//	// default is optional
		//	G_special = '*';
		//	break;
		//}

		////if (G_special_slider < 6)  // select special character mapping
		////{
		//G_special_char_select = 1;
		////}


		//if (G_special_slider > 5)  // select a G_SAVED image ... both halfs
		//{
		//	int saved_image = 0;


		//	saved_image = G_special_slider - 5;

		//	if (G_SAVED[saved_image] == 1)  // a valid image
		//	{
		//		G_special_char_select = 1000 + saved_image;


		//		G_special_saved_flag = 1;  // use leds_saved '*' and '%'  both
		//	}
		//	else
		//	{
		//		for (byte k = saved_image + 1; k < 6;++k) // search for next higher valid saved image
		//		{
		//			if (G_SAVED[k] == 1)  // a valid image
		//			{
		//				G_special_char_select = 1000 + k;


		//				G_special_saved_flag = 1;  // use leds_saved '*' and '%'  both
		//			}
		//		}

		//		if (G_special_saved_flag == 0)  // no higher saved image found ... search for lower saved image ... search backwards
		//		{
		//			for (byte k = saved_image - 1; k > 0;--k)
		//			{
		//				if (G_SAVED[k] == 1)  // a valid image
		//				{
		//					G_special_char_select = 1000 + k;


		//					G_special_saved_flag = 1;  // use leds_saved '*' and '%'  both
		//				}
		//			}
		//		}

		//	}

		//	if (G_special_saved_flag == 0) // no saved images found so use a built in image
		//	{
		//		switch (G_special_slider - 5)
		//		{
		//		case 0:
		//			CONTINUOUS_SPECIAL_MODE_OFF();
		//			break;
		//		case 1:
		//			G_special = '*';
		//			break;
		//		case 2:
		//			G_special = '%';
		//			break;
		//		case 3:
		//			G_special = '#';
		//			break;
		//		case 4:
		//			G_special = '^';
		//			break;
		//		case 5:
		//			G_special = '~';
		//			break;
		//		default:

		//			// if nothing else matches, do the default
		//			// default is optional
		//			break;
		//		}
		//	}


		//}


	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 's')  //turn OFF cycle between XY, invert, flip modes   s@
	{
		/*DC_OUT_array[0] = 27;
		DC_OUT_array[1] = 0;
		DC_SEND();*/

		G_cycle_XYflipInvert_mode = 0;
	}


	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'r')  //turn ON cycle between XY, invert, flip modes  r@
	{
		/*DC_OUT_array[0] = 27;
		DC_OUT_array[1] = 1;
		DC_SEND();*/

		G_cycle_XYflipInvert_mode = 1;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'q')  // dim the SLOW LEDs   q@
	{
		int dim = 0;

		// dimming from slider = 1 to 10
		dim = atoi(text_array);  // get the dimming value from the slider: note 510 = max brightness, 

		dim = 510 - dim;  // reverse slider direction;  note: max slider value = 510 = max brightness,  

		if (dim > 126)  // stretch out the dimmest
		{
			G_dim = (dim / 3) + 84;   // maximum slider dim=510 but max G_dim can only be 254 --> 254=(510/3)+84

		}
		else
		{
			G_dim = dim;
		}

		Serial.println(F(" "));
		Serial.print(F("BTCH: q command: G_dim ="));
		Serial.println(G_dim);
		Serial.println(F(" "));

		//DC_OUT_array[0] = 26;  // DIM LEDs
		//DC_OUT_array[1] = G_dim;
		//DC_SEND();

		for (int n = 0; n < NUM_LEDS; ++n)  // first set to maximum G_brightness then dim
		{

			//FastLED.setBrightness(G_dim);

			leds1[n].maximizeBrightness();
			leds1[n].fadeLightBy(G_dim); // Dim a color 

			leds2[n].maximizeBrightness();
			leds2[n].fadeLightBy(G_dim); // Dim a color 

			leds3[n].maximizeBrightness();
			leds3[n].fadeLightBy(G_dim); // Dim a color 

			leds4[n].maximizeBrightness();
			leds4[n].fadeLightBy(G_dim); // Dim a color 
		}

		SHOW_slow();

	}


	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'p')  // turn on/off FLIP mode  p@
	{

		//DC_OUT_array[0] = 25;  // SIDE FLIP mode
		//DC_SEND();

		SIDE_FLIP_DISPLAY();
		SHOW_slow();
	}


	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'o')  // show TEXT button "3"   o@
	{
		CONTINUOUS_SPECIAL_MODE_OFF();
		G_special_char_select = 1;

		String msg = "WOW !!";
		msg.toCharArray(scroll_text_array, sizeof(scroll_text_array));
		//stringSize = strlen(text_array);

		G_TEXT_flag = 1;  // need this variable to prevent false TEXT display 


		if (allow_transfer_flag == 1)  // show text immediately
		{
			stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
			SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0, 2, 0);
		}

	}

	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'n')  // show TEXT button "B"   n@
	{
		CONTINUOUS_SPECIAL_MODE_OFF();
		G_special_char_select = 1;

		String msg = "****BE HAPPY****";
		msg.toCharArray(scroll_text_array, sizeof(scroll_text_array));
		//stringSize = strlen(text_array);

		G_TEXT_flag = 1;  // need this variable to prevent false TEXT display 


		if (allow_transfer_flag == 1)  // show text immediately
		{
			stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
			SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0, 2, 0);
		}

	}
	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'm')  // show TEXT button "A"   m@
	{
		CONTINUOUS_SPECIAL_MODE_OFF();
		G_special_char_select = 1;

		String msg = "MURGETROID";
		msg.toCharArray(scroll_text_array, sizeof(scroll_text_array));
		//stringSize = strlen(text_array);

		G_TEXT_flag = 1;  // need this variable to prevent false TEXT display 


		if (allow_transfer_flag == 1)  // show text immediately
		{
			stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
			SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0, 2, 0);
		}

	}

	// next available command letter = l, N
	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'l')  // show TEXT button "C"   l@
	{
		CONTINUOUS_SPECIAL_MODE_OFF();
		G_special_char_select = 1;

		String msg = "HELLO";
		msg.toCharArray(scroll_text_array, sizeof(scroll_text_array));
		//stringSize = strlen(text_array);

		G_TEXT_flag = 1; // allow for text display in SHOW255()

		if (allow_transfer_flag == 1)  // show text immediately
		{

			stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array


			SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0, 2, 0);
		}

	}

	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'k')  // show TEXT button "2"   k@
	{
		CONTINUOUS_SPECIAL_MODE_OFF();
		G_special_char_select = 1;

		String msg = "%%JOY%%";
		msg.toCharArray(scroll_text_array, sizeof(scroll_text_array));
		//stringSize = strlen(text_array);

		G_TEXT_flag = 1; // allow for text display in SHOW255()

		if (allow_transfer_flag == 1)  // show text immediately
		{

			stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
			SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0, 2, 0);
		}

	}

	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'j')  // show TEXT button "1"   j@
	{
		CONTINUOUS_SPECIAL_MODE_OFF();
		G_special_char_select = 1;

		String msg = "~~LOVE~~";
		msg.toCharArray(scroll_text_array, sizeof(scroll_text_array));

		//stringSize = strlen(text_array);
		G_TEXT_flag = 1;  // allow for text display in SHOW255()

		if (allow_transfer_flag == 1)  // show text immediately
		{

			stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array
			SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0, 2, 0);
		}

	}



	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'i')  // turn on/off XYswap   i@
	{

		//DC_OUT_array[0] = 24;  //XYswap mode
		//DC_SEND();

		XY_SWAP();
		SHOW_slow();
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'h')  // turn on/off FLIP mode   n@
	{

		//DC_OUT_array[0] = 23;  //FLIP mode
		//DC_SEND();

		FLIP_DISPLAY();
		SHOW_slow();
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'g')  // draw geometery slider   g@
	{
		byte geometry = atoi(text_array);  // get the geometry value from the slider

		//DC_OUT_array[0] = 22;  // speed slider
		//DC_OUT_array[1] = geometry;  // send speed data:  1 to 10 
		//DC_SEND();

		G_geometery = geometry;  // 0 = line, 1=dots, 2=circle, 3=rectangle
		G_end_flag = 0;

		//SIGNAL(0, 4);
		//delay(500);

		MODIFY_GUI3(4);  // update slider text

	}


	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'f')  // SPEED slider   f@
	{
		G_SPEED_slider = atoi(text_array);  // get the speed value from the slider

		SerialBT.print("*A");  // update GUI text
		SerialBT.print(G_SPEED_slider);
		SerialBT.print("*");

		//DC_OUT_array[0] = 15;  // speed slider
		//DC_OUT_array[1] = speed;  // send speed data:  1 to 10 
		//DC_SEND();




	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'e')  // turn off STAR mode in CREATE mode, also see b  e@
	{

		//DC_OUT_array[0] = 21;  //STAR mode
		//DC_OUT_array[1] = 2;  // turn off hue STAR mode
		//DC_SEND();

		G_STAR_flag = 2; // turn off hue STAR mode
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'd')  // turn off rotate colors in SLAVE in CREATE mode, also see P   d@
	{

		//DC_OUT_array[1] = 2;  // turn off hue cycle mode
		//DC_OUT_array[0] = 14;  // cycle hues colors in CREATE mode	
		//DC_SEND();

		G_rotate_color = 0;


	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'c')  // turn off cycle hue colors in SLAVE in CREATE mode, also see Q  c@
	{

		//DC_OUT_array[1] = 2;  // turn off hue cycle mode
		//DC_OUT_array[0] = 16;  // cycle hues colors in CREATE mode	
		//DC_SEND();

		G_hue_cycle_vert = 0;


	}


	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'b')  // turn on/off STAR mode   b@
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 21;  // STAR mode control
		//DC_OUT_array[1] = 1;  // turn on STAR mode
		//DC_SEND();

		G_STAR_flag = 1;

	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'a')  // turn off panel 4   a@
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 20;  // panel 4 control 
		//DC_OUT_array[1] = 2;  // turn off panel 4
		//DC_SEND();

		G_panel4_on = 0;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'Z')  // turn on panel 4
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 20;  // panel 4 control 
		//DC_OUT_array[1] = 1;  // trun on panel 1
		//DC_SEND();

		G_panel4_on = 1;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'Y')  // turn off panel 3
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 19;  // panel 3 control 
		//DC_OUT_array[1] = 2;  // trun off panel 3
		//DC_SEND();

		G_panel3_on = 0;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'X')  // turn on panel 3
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 19;  // panel 3 control 
		//DC_OUT_array[1] = 1;  // trun on panel 3
		//DC_SEND();

		G_panel3_on = 1;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'W')  // turn off panel 2
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 18;  // panel 2 control 
		//DC_OUT_array[1] = 2;  // trun off panel 2
		//DC_SEND();

		G_panel2_on = 0;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'V')  // turn on panel 2
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 18;  // panel 2 control 
		//DC_OUT_array[1] = 1;  // trun on panel 2
		//DC_SEND();

		G_panel2_on = 1;



	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'U')  // turn off panel 1
	{
		//***************** DON COM  *********************
		//DC_OUT_array[0] = 17;  // panel 1 control 
		//DC_OUT_array[1] = 2;  // turn off panel 1
		//DC_SEND();

		G_panel1_on = 0;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'R')  // turn on panel 1
	{
		////***************** DON COM  *********************
		//DC_OUT_array[0] = 17;  // panel 1 control 
		//DC_OUT_array[1] = 1;  // trun on panel 1
		//DC_SEND();

		G_panel1_on = 1;
	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'Q')  // turn on cycle hue colors in SLAVE in CREATE mode also see c
	{


		//***************** DON COM  *********************

		//DC_OUT_array[1] = 1;  // turn on hue cycle mode
		//DC_OUT_array[0] = 16;  // turn on cycle hues colors in CREATE mode	
		//DC_SEND();

		G_hue_cycle_vert = 1;
	}



	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'P')  // turn on rotate colors in SLAVE in CREATE mode, also see d
	{

		//***************** DON COM  *********************
		//DC_OUT_array[1] = 1;  // turn on rotate colors	
		//DC_OUT_array[0] = 14;  // turn on rotate colors in CREATE mode	
		//DC_SEND();

		G_rotate_color = 1;


	}

	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'O')  // clear ALL LED button
	{
		Serial.print(F("BTCH: O command:    G_message="));
		Serial.println(G_message);

		//***************** DON COM  *********************
		//DC_OUT_array[0] = 13;  // clear all LEDs in CREATE mode
		//DC_OUT_array[1] = 0;  // no meaning
		//DC_SEND();


		G_KEEP = 0;  // clear flag
		for (int n = 0; n < NUM_LEDS; ++n)
		{
			//	leds_background[n] = (0, 0, 0);
			leds_saved[0][n] = 0;  // background image

		}


		if (G_panel1_on == 1)
		{
			for (int n = 0; n < NUM_LEDS; ++n)
			{
				leds1[n] = (0, 0, 0);

			}
		}

		if (G_panel2_on == 1)
		{
			for (int n = 0; n < NUM_LEDS; ++n)
			{
				leds2[n] = (0, 0, 0);
			}
		}
		if (G_panel3_on == 1)
		{
			for (int n = 0; n < NUM_LEDS; ++n)
			{
				leds3[n] = (0, 0, 0);
			}
		}

		if (G_panel4_on == 1)
		{
			for (int n = 0; n < NUM_LEDS; ++n)
			{
				leds4[n] = (0, 0, 0);
			}
		}

		// clear the undo stack
		G_pointer = 0;
		G_pointer_rollover_flag = 0;

		SHOW_slow();
	}



	///////////////////////////////////////////////////////////////
	//if (G_BT_command == 'N')  // REMOVE LED button
	//{
	//	/*Serial.print("BTCH: N command:    G_message=");
	//	Serial.println(G_message);*/

	//	//***************** DON COM  *********************
	//	DC_OUT_array[0] = 12;  // remove an LED CREATE mode
	//	DC_OUT_array[1] = 0;  // no meaning
	//	DC_SEND();
	//}


	///////////////////////////////////////////////////////////
	if (G_BT_command == 'M')  // UNDO 
	{
		//Serial.print(F("BTCH: M command:    G_message="));
		//Serial.println(G_message);

		////***************** DON COM  *********************
		//DC_OUT_array[0] = 11;  // UNDO
		//DC_OUT_array[1] = 0;  // 
		//DC_SEND();

		if (G_UNDO_stored > 0)
		{
			LOAD_DISPLAY_from_BUFFER(); // load panel with leds_buffer specified in the last position of the UNDO_stored_array
		}
		else
		{
			UNDO(0);
		}
	}


	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'L')  // SHOW button,     CREATE switch = OFF,  execute the SHOW using current PRODUCTION   L@
	{
		//	Serial.print(F("BTCH: L command:    G_message="));
		//	Serial.println(G_message);

			// first turn off continuous special mode 
			// only allow "continuous special mode" in CREATE mod
		CONTINUOUS_SPECIAL_MODE_OFF();

		TURN_OFF_PLAY_SAVES_MODE();

		for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)
		{
			text_array[n] = '\0';
			scroll_text_array[n] = '\0';
		}

		G_continuous_SPECIAL_mode = 0;


		int production_save = G_production;

		RESET(1);  // don't reset brightness

		G_production = production_save;  // necessary as RESET changes G_production

		//LABEL_PRODUCTION_BUTTON();
		SerialBT.print("*I");  // update GUI text
		SerialBT.print(G_production);
		SerialBT.print("*");

		UPDATE_PRODUCTION_NAME();

		for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)  // to prevent CRASH
		{
			text_array[n] = '\0';
			scroll_text_array[n] = '\0';
		}

		String BT_string2send = "*FMURGETROID CONTROLLER*";
		SerialBT.print(BT_string2send);  // send to GUI

		//////////// now turn off CREATE mode
		//***************** DON COM  *********************

		//DC_OUT_array[0] = 8;  // turn off CREATE mode
		//DC_OUT_array[1] = 0;  // no meaning
		//DC_SEND();

		G_CREATE_mode = 0;
		G_do_CREATE_mode = 0;

		if (G_GUI == 4)  // production/show control
		{
			SerialBT.print("*L");  // update GUI4 text for CREATE MODE
			SerialBT.print("off");
			SerialBT.print("*");
		}



	}

	/////////////////////////////////////////////////////////////

	if (G_BT_command == 'K')  // CREATE switch = ON
	{
		Serial.print(F("BTCH: K command:    G_message="));
		Serial.println(G_message);


		G_do_CREATE_mode = 1;  // flag that CREATE mode needs to be turned on
		TURN_ON_CREATE_MODE();  // turns on CREATE mode if SLAVE has control

		CLEAR_ALL_LEDS();
		SHOW_slow();

	}

	/////////////////////////////////////////////////////////////

	if (G_BT_command == 'J')  // send mouse pad 
	{
		Serial.print(F("BTCH: J command:    G_message="));
		Serial.println(G_message);


		G_BT_cmd = 4; // arbitrary but unique number assigned to this command; 



		if (G_BT_cmd_previous != G_BT_cmd)  // only execute first time into this command
		{
			//	SIGNAL(0);


			G_BT_cmd_previous = G_BT_cmd;

			CONTINUOUS_SPECIAL_MODE_OFF();  // turn it off to speed up MOUSE trace
			MODIFY_GUI2(9);  // turn off RANDOM HUE switch
			MODIFY_GUI3(5); // turn off RANDOM HUE switch

			SEND_CYCLE_SLIDER(0);  // turn off cycle generator
		}

		// send XY coordinates to SLAVE
		//G_scroll_speed= atoi(text_array);

		char temp_array[3];
		int X = 0;  // must be int as there are negative values
		int Y = 0;
		byte position = 1;  // of text_array

		// extract X and Y from format : X##Y##
		temp_array[0] = text_array[1];

		if (text_array[2] != 'Y')  // which means text_array[2]=Y
		{
			position = 3; // flag that Y not detected
			temp_array[1] = text_array[2];
			temp_array[2] = '\n';
		}
		else
		{
			position = 2;
			temp_array[1] = '\n';
		}

		X = atoi(temp_array);



		++position;
		temp_array[0] = text_array[position];

		++position;

		if (text_array[position] != '\n')
		{
			temp_array[1] = text_array[position];
			temp_array[2] = '\n';

		}
		else
		{
			temp_array[1] = '\n';
		}

		Y = atoi(temp_array);



		// normalize X and Y to be in range 0 to 21 
		if (X < 0) { X = 0; }
		if (X >= NUM_LEDS_FAST) { X = NUM_LEDS_FAST - 1; }
		if (Y < 0) { Y = 0; } // top is minimum
		if (Y >= NUM_LEDS_FAST) { Y = NUM_LEDS_FAST - 1; }

		Y = NUM_LEDS_FAST - Y - 1;  // reverse 

		//Serial.print(F("BTCH: J command: normalized   X="));
		//Serial.println(X);
		//Serial.print(F("BTCH: J command: normalized   Y="));
		//Serial.println(Y);

		if ((G_CREATE_mode == 1) && ((G_X_previous != (byte)X) || ((G_Y_previous != (byte)Y))))  // send XY data via DON_COM only if X or Y has changed
		{


			// check time interval between last XY pair received and now
			unsigned long lag = 100;  // sets time trigger between XY pairs, was 500
			unsigned long delta_time = millis() - G_time;

			//	G_RAND_HUE = 0;  // turn off random hue mode

			G_time = millis();

			if (delta_time > lag)
			{
				G_X_previous = G_X;
				G_Y_previous = G_Y;
			}


			G_X = (byte)X;  // X data
			G_Y = (byte)Y;  // Y data



			//Serial.println(F("  DCDAD:     "));
			//Serial.print(F("G_X="));
			//Serial.println(G_X);
			//Serial.print(F("G_X_previous="));
			//Serial.println(G_X_previous);
			//Serial.print(F("G_Y="));
			//Serial.println(G_Y);
			//Serial.print(F("G_Y_previous="));
			//Serial.println(G_Y_previous);
			//Serial.print(F("delta_time="));
			//Serial.println(delta_time);
			//Serial.println("");

			if (((G_X - G_X_previous) != 0) || (G_Y - G_Y_previous) != 0) // do nothing if delta X=0 and delta Y =0
			{

				DRAW_in_CREATE();

			}


			G_X_previous = (byte)X;
			G_Y_previous = (byte)Y;


		}



	}



	/////////////////////////////////////////////////////////////
	if (G_BT_command == 'I')  // change color to white
	{
		String BT_string2send = String("*MR255G255B255*");    // white
		SerialBT.print(BT_string2send);  // turn indicator to HUE color
		G_hue = -1;  // flag white color
		MODIFY_GUI3(5); // turn off random hue
		MODIFY_GUI2(9); // turn off random hue

		//DC_OUT_array[0] = 10;  // HUE data
		//DC_OUT_array[1] = 0;  // irrelavent
		//DC_OUT_array[2] = 1;  // FLAG WHITE

		////***************** DON COM  *********************
		//DC_SEND();
	}

	////////////////////////////////////////////////////////////

	if (G_BT_command == 'H')  // change HUE
	{
		SET_HUE_COLOR_INDICATOR();

	}



	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'G')  // play previous show   G@
	{
		SerialBT.print("*LR0G255B0*");  // turn indicator GREEN

		//DC_OUT_array[0] = 6;  // advance to next show
		//DC_OUT_array[1] = 0;  // no meaning

		////***************** DON COM  *********************
		//DC_SEND();

		G_repeat_show_flag = 0;

		--G_show_num;
		--G_show_num;

		if (G_show_num < 0)
		{
			G_show_num = 1;
		}

		SerialBT.print("*!");  // update GUI4 text
		SerialBT.print(G_show_num);
		SerialBT.print("*");



	}


	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'F')  // advance to next show  F@
	{

		SerialBT.print("*LR0G255B0*");  // turn indicator GREEN

		//DC_OUT_array[0] = 5;  // advance to next show
		//DC_OUT_array[1] = 0;  // no meaning

		////***************** DON COM  *********************
		//DC_SEND();

		if (G_repeat_show_flag == 0)
		{
			++G_show_num;
		}
		G_repeat_show_flag = 0;



		SerialBT.print("*!");  // update GUI4 text
		SerialBT.print(G_show_num);
		SerialBT.print("*");


	}



	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'E')  // pause/repeat show command E@
	{
		SerialBT.print("*LR255G0B0*");  // turn indicator RED

		//DC_OUT_array[0] = 4;  // repeat current show
		//DC_OUT_array[1] = 0;  // no meaning

		////***************** DON COM  *********************
		//DC_SEND();

		G_repeat_show_flag = 1;



	}

	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'D')   //  D@
	{
		G_banner = atoi(text_array);

		Serial.print(F("BTCH:   G_banner="));
		Serial.println(G_banner);

	}
	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'C')   //    C@
	{
		G_scroll_speed = atoi(text_array);

		Serial.print(F("BTCH:  G_scroll_speed="));
		Serial.println(G_scroll_speed);

	}


	////////////////////////////////////////////////////////////
	if (G_BT_command == 'A')  // PRODUCTION 2 = test show   A@
	{
		//DC_OUT_array[0] = 3;  // do production
		//DC_OUT_array[1] = 2;

		////DC_SEND_ARRAY();  // next show should be 1
		//DC_SEND();


		G_beginning_SHOW_flag = 0;
		G_show_num = 1;

		G_production = 2;
		//G_show_num = 0;   // show handler will increment 1
	}

	////////////////////////////////////////////////////////////
	if (G_BT_command == 'B')  // PRODUCTION 1 = main show
	{
		//DC_OUT_array[0] = 3;  // do production
		//DC_OUT_array[1] = 1;

		G_production = 1;
		G_show_num = 1;

		//G_show_num = 0;  // show handler will increment 1

		//DC_SEND();
	}

	////////////////////////////////////////////////////////////	
	if (G_BT_command == 'T')  // show TEXT command
	{
		if (allow_transfer_flag == 1)  // show text immediately
		{
			Serial.print(F("BTCH: text_array="));
			Serial.println((char*)text_array);  //from blue tooth
			Serial.println("");

			G_TEXT_flag = 1;  // allow for text display in SHOW255()

			strcpy(scroll_text_array, text_array);
			stringSize = ADD_SPECIAL_TEXT();

			SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, 0, 1, 0);

		}

	}


	///////////////////////////////////////////////////////////
	if (G_BT_command == 'S')  // do SLAVE SHOW command
	{

		String slave_show_num = String(text_array);
		byte next_show = slave_show_num.toInt();  // convert to integer


		if (SERIAL_MON == 1)
		{
			Serial.println("");
			Serial.println(F("+++++++++++++++++++++++++++++++++++++++++BLUE_TOOTH_COMMAND_HANDLER"));
			Serial.print(F("slave_show_num= "));
			Serial.println(slave_show_num);
			Serial.print(F("next_show= "));
			Serial.println(next_show);
			Serial.println("");
		}


		//DC_OUT_array[0] = 1;  // command to show bitmap
		//DC_OUT_array[1] = next_show;

		////***************** DON COM  *********************
		//DC_SEND();


		G_interceeded_flag = 1;   // flag that a show was inserted into the normal flow

		//	DC_SEND_ARRAY();  // next show should be 1

		/*if (allow_transfer_flag == 1)
		{
			Serial.println(F("BTCH: just before TRANSFER2_SLOW: end of BTCH: allow_transfer_flag=1"));
			BT_and_DC_CHECKandDO();
			Serial.println(F("BTCH: just after TRANSFER2_SLOW: end of BTCH: allow_transfer_flag=1"));
		}*/
	}



	//////////////////////////////////////////////////////////////////////
	/// &&&&&&&&&&&&&&&  end of command handler &&&&&&&&&&&&&& ///
	//////////////////////////////////////////////////////////////////////

	G_BT_message_flag = 0;   // set to 0 because command is handled

	if ((G_BT_command != 'z') || (G_BT_command2 != 'z') || (G_BT_command3 != 'N'))  // NOT turn on PLAY SAVES
	{
		TURN_OFF_PLAY_SAVES_MODE();  // turn off on any BT command
	}

	G_BT_command = ' ';
	G_BT_command2 = ' ';
	G_BT_command3 = ' ';

	G_BT_cmd_previous = G_BT_cmd;  // this is needed for UNDO of 8way controls in GUI3


	G_message = "";



	//	SerialBT.flush();  // I put this in as a precaution in case many BT commands were issued in sucession, 11/7/21






		//Serial.print("BTCH:  G_BT_message_flag= ");
		//Serial.println(G_BT_message_flag);
		//Serial.print("BTCH:  G_BT_command= ");
		//Serial.println(G_BT_command);
		//Serial.print("BTCH:  G_return_sent_flag= ");
		//Serial.println(G_return_sent_flag);

	//Serial.println(F(""));
	//Serial.print(F("$$$$$$$$$ BTCH END: G_dim= "));
	//Serial.println(G_dim);
	//Serial.println(F(""));

	

	Serial.print("BTCH END:  G_continuous_SPECIAL_mode= ");
	Serial.println(G_continuous_SPECIAL_mode);
	Serial.print(F("G_dim= "));
	Serial.println(G_dim);
	Serial.println(F("BTCH: LEAVING ))))))))))))))))))))))))))))"));
	Serial.println("");
}



////////////////
void DC_CHECK_AND_DO()  // check for DON_COM command and execute it
{

	if (DC_ON == 0)
	{
		return;
	}

	G_DC_received_flag = DC_RECEIVE_ARRAY();
	DC_COMMAND_HANDLER();

	/*if ((SERIAL_MON == 1) && (G_DC_received_flag == 1))
	{
		Serial.print("TF2S waiting: G_DC_received_flag= ");
		Serial.println(G_DC_received_flag);
		Serial.println("");
	}*/

}


///////////////////////////////////////////////////
void DC_SEND()  // guarantee that the DC_SEND_ARRAY is sent and received
{

	if (DC_ON == 0) { return; }

	Serial.println(F("--------------- DC_SEND ---------------"));
	Serial.println("");

	byte rv = DC_SEND_ARRAY();

	Serial.print(F("rv="));
	Serial.println(rv);
	Serial.println("");


	//***************** DON COM  *********************
	if (rv == 0)  // make sure DC data is sent: 
	{
		DC_CHECK_AND_DO();

		Serial.println(F(" DC_SEND:rv=0:   before 2nd DC_SEND_ARRAY()"));
		DC_SEND_ARRAY();

	}

	Serial.println(F("---------------leaving DC_SEND ---------------"));
	Serial.println("");
}

////////////////////////////////////////////////////////////////////////
void GUI()
{
	Serial.println("IN GUI function");
	//delay(1000);

	SerialBT.println("*.kwl");
	SerialBT.println("clear_panel()");
	SerialBT.println("set_grid_size(25,14)");
	SerialBT.println("add_text(3,8,large,L,ROTATE,245,240,245,)");
	SerialBT.println("add_text(5,8,large,L,STAR,245,240,245,)");
	SerialBT.println("add_text(1,6,medium,L,RED,255,0,0,)");
	SerialBT.println("add_text(2,6,medium,L,YELLOW,245,240,0,)");
	SerialBT.println("add_text(4,6,medium,L,GREEN,0,240,0,)");
	SerialBT.println("add_text(6,6,medium,L,BLUE,0,0,245,)");
	SerialBT.println("add_text(8,6,medium,L,RED,245,0,0,)");
	SerialBT.println("add_text(7,8,large,L,CYCLE,245,240,245,)");
	SerialBT.println("add_text(1,8,large,L,HUES,245,240,245,)");
	SerialBT.println("add_text(22,0,large,L,MURGETROID,245,240,245,)");
	SerialBT.println("add_text(22,1,large,L,BE HAPPY,245,240,245,)");
	SerialBT.println("add_text(24,6,large,L,slow,245,240,245,)");
	SerialBT.println("add_text(21,6,large,L,fast,245,240,245,)");
	SerialBT.println("add_text(23,13,xlarge,R,Present Show =,245,240,245,)");
	SerialBT.println("add_text(18,8,medium,L,CONTINUOUS SPECIAL,245,240,245,)");
	SerialBT.println("add_text(6,13,large,L,SQR1,245,240,245,)");
	SerialBT.println("add_text(8,13,large,L,SQR2,245,240,245,)");
	SerialBT.println("add_text(4,13,large,L, MHOZ,245,240,245,)");
	SerialBT.println("add_text(18,9,large,L,AUTO-DIM,245,240,245,)");
	SerialBT.println("add_text(10,13,large,L,FLIP,245,240,245,)");
	SerialBT.println("add_text(12,13,large,C,XYswap,245,240,245,)");
	SerialBT.println("add_text(0,12,large,L,SPEED,245,240,245,)");
	SerialBT.println("add_text(1,10,large,C,Hroll,245,240,245,)");
	SerialBT.println("add_text(3,10,large,L,Vroll,245,240,245,)");
	SerialBT.println("add_text(7,0,large,L,CLEAR,245,240,245,)");
	SerialBT.println("add_text(7,2,large,L,CREATE,245,240,245,)");
	SerialBT.println("add_text(8,5,medium,L,WHITE,245,240,245,)");
	SerialBT.println("add_text(9,0,xlarge,L,RESET,245,240,245,)");
	SerialBT.println("add_text(12,6,large,L,RECT,245,240,245,)");
	SerialBT.println("add_text(12,7,large,L,CIRCLE,245,240,245,)");
	SerialBT.println("add_text(12,8,large,L,LINE,245,240,245,)");
	SerialBT.println("add_text(12,9,large,L,DRAW,245,240,245,)");
	SerialBT.println("add_text(13,0,large,L,panel 1,245,240,245,)");
	SerialBT.println("add_text(17,0,large,L,panel 2,245,240,245,)");
	SerialBT.println("add_text(20,0,large,L,LOVE,245,240,245,)");
	SerialBT.println("add_text(20,1,large,L,JOY,245,240,245,)");
	SerialBT.println("add_text(13,1,large,L,panel 3,245,240,245,)");
	SerialBT.println("add_text(17,1,large,L,panel 4,245,240,245,)");
	SerialBT.println("add_text(18,6,large,L,SPECIAL,245,240,245,)");
	SerialBT.println("add_text(14,4,large,L,CYCLE SAVES,245,240,245,)");
	SerialBT.println("add_text(18,4,large,L,BANNER,245,240,245,)");
	SerialBT.println("add_text(22,4,large,L,SCROLL SPEED,245,240,245,)");
	SerialBT.println("add_text(11,2,large,C,SAVE,245,240,245,)");
	SerialBT.println("add_text(6,10,large,L,CONT_GEN,245,240,245,)");
	SerialBT.println("add_text(9,3,xlarge,L,UNDO,245,240,245,)");
	SerialBT.println("add_text(15,7,xlarge,R,GEN,245,240,245,)");
	SerialBT.println("add_text(14,5,large,L,RAND HUE,245,240,245,)");
	SerialBT.println("add_text(20,2,large,C,WOW!,245,240,245,)");
	SerialBT.println("add_text(22,2,large,L,HELLO,245,240,245,)");
	SerialBT.println("add_text(12,11,xlarge,L,MURGETROID CONTROLLER,255,171,0,)");
	SerialBT.println("add_text(11,3,large,C,LOAD,245,240,245,)");
	SerialBT.println("add_text(2,13,large,L,MVERT,245,240,245,)");
	SerialBT.println("add_text(14,13,large,L,SideFlip,245,240,245,)");
	SerialBT.println("add_text(24,10,large,L,GUI,245,240,245,)");
	SerialBT.println("add_text(10,10,large,L,EFFECT,245,240,245,)");
	SerialBT.println("add_text(24,13,xlarge,L,1,245,240,245,!)");
	SerialBT.println("add_text(18,12,large,L,HALL sync,245,240,245,)");
	SerialBT.println("add_text(20,10,large,L,BRIGHTNESS,245,240,245,)");
	SerialBT.println("add_button(21,0,18,m,@)");
	SerialBT.println("add_button(24,12,5,F,@)");
	SerialBT.println("add_button(20,12,4,G,@)");
	SerialBT.println("add_button(4,12,13,x,@)");
	SerialBT.println("add_button(6,12,21,y,@)");
	SerialBT.println("add_button(8,12,22,zA,@)");
	SerialBT.println("add_button(22,12,8,E,@)");
	SerialBT.println("add_button(12,12,6,i,@)");
	SerialBT.println("add_button(7,1,20,O,@)");
	SerialBT.println("add_button(7,5,7,I,@)");
	SerialBT.println("add_button(9,1,28,zB,@)");
	SerialBT.println("add_button(9,4,27,M,@)");
	SerialBT.println("add_button(21,1,19,n,@)");
	SerialBT.println("add_button(19,0,21,j,@)");
	SerialBT.println("add_button(14,2,23,zK3,@)");
	SerialBT.println("add_button(16,2,19,zK5,@)");
	SerialBT.println("add_button(14,3,23,zL3,@)");
	SerialBT.println("add_button(15,3,18,zL4,@)");
	SerialBT.println("add_button(16,3,19,zL5,@)");
	SerialBT.println("add_button(14,8,29,zP,@)");
	SerialBT.println("add_button(19,1,22,k,@)");
	SerialBT.println("add_button(19,2,23,o,@)");
	SerialBT.println("add_button(21,2,20,l,@)");
	SerialBT.println("add_button(12,2,21,zK1,@)");
	SerialBT.println("add_button(13,2,22,zK2,@)");
	SerialBT.println("add_button(12,3,21,zL1,@)");
	SerialBT.println("add_button(13,3,22,zL2,@)");
	SerialBT.println("add_button(15,2,18,zK4,@)");
	SerialBT.println("add_button(2,12,11,w,@)");
	SerialBT.println("add_button(14,12,5,p,@)");
	SerialBT.println("add_button(10,12,3,h,@)");
	SerialBT.println("add_button(23,10,14,zzC,@)");
	SerialBT.println("add_switch(3,9,2,P@,d@,0,0)");
	SerialBT.println("add_switch(5,9,2,b@,e@,0,0)");
	SerialBT.println("add_switch(23,7,3,A@,B@,0,0)");
	SerialBT.println("add_switch(7,9,2,r@,s@,0,0)");
	SerialBT.println("add_switch(16,9,2,zI@,zJ@,0,1)");
	SerialBT.println("add_switch(1,9,2,Q@,c@,0,0)");
	SerialBT.println("add_switch(1,11,2,zC@,zD@,0,0)");
	SerialBT.println("add_switch(3,11,2,zE@,zF@,0,0)");
	SerialBT.println("add_switch(7,3,1,K@,L@,0,0)");
	SerialBT.println("add_switch(11,0,2,R@,U@,0,1)");
	SerialBT.println("add_switch(15,0,2,V@,W@,0,1)");
	SerialBT.println("add_switch(11,1,2,X@,Y@,0,1)");
	SerialBT.println("add_switch(15,1,2,Z@,a@,0,1)");
	SerialBT.println("add_switch(6,11,2,zG@,zH@,0,0)");
	SerialBT.println("add_switch(14,6,2,zR@,zS@,0,1)");
	SerialBT.println("add_switch(12,4,2,zN@,zO@,0,0)");
	SerialBT.println("add_switch(16,12,2,zT@,zU@,0,1)");
	SerialBT.println("add_switch(16,8,2,u@,v@,0,0)");
	SerialBT.println("add_slider(1,7,8,0,255,0,H,@,1)");
	SerialBT.println("add_slider(21,5,2,1,5,1,C,@,1)");
	SerialBT.println("add_slider(11,6,3,0,3,0,g,@,1)");
	SerialBT.println("add_slider(17,5,1,0,5,0,D,@,1)");
	SerialBT.println("add_slider(9,8,3,1,10,5,zM,@,1)");
	SerialBT.println("add_slider(0,8,4,1,10,1,f,@,1)");
	SerialBT.println("add_slider(17,7,2,0,10,0,t,@,1)");
	SerialBT.println("add_slider(16,10,1,1,510,1,q,@,1)");
	SerialBT.println("add_touch_pad(0,0,6,-3,23,0,0,J,@)");
	SerialBT.println("add_led(9,6,2,M,255,0,0)");
	SerialBT.println("add_led(23,12,1,L,0,255,0)");
	SerialBT.println("add_send_box(17,3,8,1234,T,@)");
	SerialBT.println("set_panel_notes(MURGETROID 3 Controller,by Don Wile,8/24/20,)");
	SerialBT.println("run()");
	SerialBT.println("*");



	// this is necessary because the BT Electronics app sends position settings of the controls after
	// I send it the new GUI...this causes a false CREATE mode detection
	delay(1000);
	//SerialBT.flush();
	FLUSH_BT_BUFFER();


}

/////////////////////////////////////
void GUI4()  //  PRODUCTION and SHOW control
{
	SerialBT.println("*.kwl");
	SerialBT.println("clear_panel()");
	SerialBT.println("set_grid_size(25,14)");
	SerialBT.println("add_text(12,2,xlarge,L,SHOW # =,245,240,245,)");
	SerialBT.println("add_text(11,11,medium,L,previous SHOW,245,240,245,)");
	SerialBT.println("add_text(10,1,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,2,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,3,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,4,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,5,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,6,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,7,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,8,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,9,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,10,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(10,11,xlarge,L,l,245,240,245,)");
	SerialBT.println("add_text(3,0,xlarge,L,return to GUI3,245,240,245,)");
	SerialBT.println("add_text(11,9,large,L,SHOW to LOAD =,245,240,245,)");
	SerialBT.println("add_text(6,4,large,L,lock,245,240,245,)");
	SerialBT.println("add_text(7,7,xlarge,C, PRODUCTION,127,126,255,)");
	SerialBT.println("add_text(7,8,xlarge,C,LOCK,122,123,255,)");
	SerialBT.println("add_text(2,8,xlarge,C,ENABLE,245,113,113,)");
	SerialBT.println("add_text(2,7,xlarge,C,MIC,245,127,128,)");
	SerialBT.println("add_text(0,4,large,L,enabled,245,240,245,)");
	SerialBT.println("add_text(2,2,xlarge,L,PRODUCTION # =,245,240,245,)");
	SerialBT.println("add_text(2,9,large,L,PROD. to LOAD =,245,240,245,)");
	SerialBT.println("add_text(2,11,medium,L,previous PROD.,245,240,245,)");
	SerialBT.println("add_text(5,11,large,L,LOAD,245,240,245,)");
	SerialBT.println("add_text(7,11,medium,L,next PROD.,245,240,245,)");
	SerialBT.println("add_text(14,0,xlarge,L,REFRESH GUI,245,240,245,)");
	SerialBT.println("add_text(12,4,large,L,lock,245,240,245,)");
	SerialBT.println("add_text(16,3,xlarge,L,CREATE MODE =,102,240,100,)");
	SerialBT.println("add_text(17,4,large,L,turn off CREATE mode,245,240,245,)");
	SerialBT.println("add_text(5,13,xlarge,L,----- PRODUCTION/SHOW CONTROL: GUI4 -----,255,88,0,)");
	SerialBT.println("add_text(21,0,xlarge,L,BT,122,124,245,)");
	SerialBT.println("add_text(18,2,xlarge,L,Final SHOW =,245,240,245,)");
	SerialBT.println("add_text(14,11,large,L,LOAD,245,240,245,)");
	SerialBT.println("add_text(6,9,xlarge,L,1,245,240,245,J)");
	SerialBT.println("add_text(17,6,large,L,min,245,240,245,)");
	SerialBT.println("add_text(22,6,large,L,max,245,240,245,)");
	SerialBT.println("add_text(18,5,xlarge,L,MIC gain:,255,120,120,)");
	SerialBT.println("add_text(15,9,xlarge,L,1,245,240,245,K)");
	SerialBT.println("add_text(16,11,medium,L,next SHOW,245,240,245,)");
	SerialBT.println("add_text(21,5,large,L,50,245,127,128,O)");
	SerialBT.println("add_text(15,2,xlarge,L,8,245,240,245,!)");
	SerialBT.println("add_text(2,3,large,L,MAIN SHOW,106,240,109,N)");
	SerialBT.println("add_text(22,2,xlarge,L,28,245,240,245,M)");
	SerialBT.println("add_text(20,8,xlarge,L,MUSIC DETECT,245,240,245,)");
	SerialBT.println("add_text(21,3,xlarge,L,off,245,240,245,L)");
	SerialBT.println("add_text(20,12,xlarge,L,HEAD COM,245,240,245,)");
	SerialBT.println("add_text(21,10,large,L,SOUND DETECT,245,240,245,)");
	SerialBT.println("add_text(7,2,xlarge,L,1,245,240,245,I)");
	SerialBT.println("add_text(13,7,xlarge,C,SHOW LOCK,113,114,255,)");
	SerialBT.println("add_text(20,7,large,L,MUSIC mode only,255,92,91,)");
	SerialBT.println("add_button(3,10,4,zzi,@)");
	SerialBT.println("add_button(5,10,16,zzk,@)");
	SerialBT.println("add_button(7,10,5,zzh,@)");
	SerialBT.println("add_button(16,10,5,zzo,@)");
	SerialBT.println("add_button(12,10,4,zzp,@)");
	SerialBT.println("add_button(16,4,17,L,@)");
	SerialBT.println("add_button(14,10,16,zzl,@)");
	SerialBT.println("add_button(1,0,27,zzC,@)");
	SerialBT.println("add_button(12,0,28,zzj,@)");
	SerialBT.println("add_switch(7,4,3,zV@,zW@,0,0)");
	SerialBT.println("add_switch(13,4,3,zX@,zY@,0,0)");
	SerialBT.println("add_switch(2,4,3,zzm@,zzn@,0,1)");
	SerialBT.println("add_switch(18,7,2,zzr@,zzs@,0,0)");
	SerialBT.println("add_slider(18,6,1,0,100,50, zzq, @,1)");
	SerialBT.println("add_led(19,0,2,H,0,0,255)");
	SerialBT.println("add_led(18,8,2,P,0,0,0)");
	SerialBT.println("add_led(18,11,2,Q,0,0,0)");
	SerialBT.println("add_led(20,10,1,R,0,0,0)");
	SerialBT.println("set_panel_notes(,,,)");
	SerialBT.println("run()");
	SerialBT.println("*");











	// this is necessary because the BT Electronics app sends position settings of the controls after
	// I send it the new GUI...this causes a false CREATE mode detection
	delay(1000);
	//SerialBT.flush();
	FLUSH_BT_BUFFER();


}

/////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
void GUI3()  // SIMPLIEST GUI
{
	SerialBT.println("*.kwl");
	SerialBT.println("clear_panel()");
	SerialBT.println("set_grid_size(24,15)");
	SerialBT.println("add_text(8,14,xlarge,L,MURGETROID CONTROLLER,255,171,0,F)");
	SerialBT.println("add_text(0,13,xlarge,L,SHAPE,245,240,245,)");
	SerialBT.println("add_text(0,8,medium,L,DOTS,255,105,0,S)");
	SerialBT.println("add_text(4,13,xlarge,C,CYCLE,245,240,245,)");
	SerialBT.println("add_text(8,13,xlarge,C,TRANSLATE,245,240,245,)");
	SerialBT.println("add_text(12,13,xlarge,C,COLOR,245,240,245,)");
	SerialBT.println("add_text(16,13,xlarge,C,RING,245,240,245,)");
	SerialBT.println("add_text(16,8,large,C,RING IMAGE,245,240,245,)");
	SerialBT.println("add_text(19,8,large,L,RANDOM RING,245,240,245,)");
	SerialBT.println("add_text(9,3,xlarge,L,UNDO,245,240,245,)");
	SerialBT.println("add_text(16,2,medium,L,WHITE,245,240,245,)");
	SerialBT.println("add_text(17,1,large,L,RANDOM HUE,245,240,245,)");
	SerialBT.println("add_text(7,2,medium,L,RED,255,0,0,)");
	SerialBT.println("add_text(9,2,medium,R,YELLOW,245,240,0,)");
	SerialBT.println("add_text(10,2,medium,L,GREEN,0,240,0,)");
	SerialBT.println("add_text(12,2,medium,L,BLUE,0,0,245,)");
	SerialBT.println("add_text(14,2,medium,L,RED,245,0,0,)");
	SerialBT.println("add_text(6,1,large,L,HUE,245,240,245,)");
	SerialBT.println("add_text(21,7,large,L,HAPPY BD,245,240,245,)");
	SerialBT.println("add_text(21,6,large,L,HELLO,245,240,245,)");
	SerialBT.println("add_text(21,4,large,L,MURGETROID,245,240,245,)");
	SerialBT.println("add_text(21,3,large,L,WOW!,245,240,245,)");
	SerialBT.println("add_text(21,2,large,L,JOY,245,240,245,)");
	SerialBT.println("add_text(21,1,large,L,LOVE,245,240,245,)");
	SerialBT.println("add_text(13,4,large,C,SAVE,255,171,0,)");
	SerialBT.println("add_text(13,6,large,C,LOAD,245,240,245,)");
	SerialBT.println("add_text(2,8,xlarge,L,PLAY SAVES,255,171,0,)");
	SerialBT.println("add_text(9,6,large,C,-------------FUN-------------,245,240,245,)");
	SerialBT.println("add_text(9,8,large,L,RANDOM IMAGE,245,240,245,)");
	SerialBT.println("add_text(13,7,xlarge,L,CLEAR,245,128,0,)");
	SerialBT.println("add_text(22,9,xlarge,R,CREATE,245,240,245,)");
	SerialBT.println("add_text(21,10,xlarge,L,SHOW,245,240,245,)");
	SerialBT.println("add_text(22,11,xlarge,R,RESET,245,240,245,)");
	SerialBT.println("add_text(1,7,large,L,[ TOUCH 1 POINT & DRAG ],0,162,255,E)");
	SerialBT.println("add_text(19,9,large,L,1,245,0,67,G)");
	SerialBT.println("add_text(13,3,large,L,BT,245,240,245,)");
	SerialBT.println("add_text(18,10,medium,L,SHOW=,245,240,245,)");
	SerialBT.println("add_text(18,11,medium,L,PROD=,245,240,245,)");
	SerialBT.println("add_text(19,10,medium,R,6,245,240,245,!)");
	SerialBT.println("add_text(19,11,medium,L,1,245,240,245,I)");
	SerialBT.println("add_text(23,12,large,L,GUI,245,240,245,)");
	SerialBT.println("add_text(21,5,large,L,BE HAPPY,245,240,245,)");
	SerialBT.println("add_text(18,12,large,L,BRIGHTNESS ,245,240,245,)");
	SerialBT.println("add_text(21,12,small,L,MAX,245,240,245,)");
	SerialBT.println("add_button(18,8,16,zzU,@)");
	SerialBT.println("add_button(7,3,27,M,@)");
	SerialBT.println("add_button(15,2,7,I,@)");
	SerialBT.println("add_button(20,7,8,zzV,@)");
	SerialBT.println("add_button(20,6,20,l,@)");
	SerialBT.println("add_button(20,4,18,m,@)");
	SerialBT.println("add_button(20,3,23,o,@)");
	SerialBT.println("add_button(20,2,22,k,@)");
	SerialBT.println("add_button(20,1,21,j,@)");
	SerialBT.println("add_button(18,4,19,zK5,@)");
	SerialBT.println("add_button(18,6,19,zL5,@)");
	SerialBT.println("add_button(17,4,18,zK4,@)");
	SerialBT.println("add_button(17,6,18,zL4,@)");
	SerialBT.println("add_button(16,4,23,zK3,@)");
	SerialBT.println("add_button(16,6,23,zL3,@)");
	SerialBT.println("add_button(15,4,22,zK2,@)");
	SerialBT.println("add_button(15,6,22,zL2,@)");
	SerialBT.println("add_button(14,4,21,zK1,@)");
	SerialBT.println("add_button(14,6,21,zL1,@)");
	SerialBT.println("add_button(9,5,6,zzY,@)");
	SerialBT.println("add_button(8,5,7,zzX,@)");
	SerialBT.println("add_button(7,5,9,zzW,@)");
	SerialBT.println("add_button(8,7,11,zzb,@)");
	SerialBT.println("add_button(7,7,10,zza,@)");
	SerialBT.println("add_button(7,8,29,zP,@)");
	SerialBT.println("add_button(9,7,13,zzc,@)");
	SerialBT.println("add_button(10,7,3,zzd,@)");
	SerialBT.println("add_button(10,5,2,zze,@)");
	SerialBT.println("add_button(11,7,5,zzf,@)");
	SerialBT.println("add_button(11,5,4,zzg,@)");
	SerialBT.println("add_button(13,8,28,O,@)");
	SerialBT.println("add_button(23,9,17,K,@)");
	SerialBT.println("add_button(20,11,15,zB,@)");
	SerialBT.println("add_button(23,10,16,L,@)");
	SerialBT.println("add_button(20,5,19,n,@)");
	SerialBT.println("add_button(23,13,14,zzC,@)");
	SerialBT.println("add_switch(15,1,2,zR@,zS@,0,1)");
	SerialBT.println("add_switch(2,9,1,zzN@,zzO@,0,0)");
	SerialBT.println("add_slider(0,9,3,0,4,1,g,@,1)");
	SerialBT.println("add_slider(15,9,2,1,10,1,t,@,1)");
	SerialBT.println("add_slider(7,1,8,0,255,0,H,@,1)");
	SerialBT.println("add_slider(18,13,1,1,510,408, q, @,1)");
	SerialBT.println("add_8way_pad(7,10,1,5,2,6,3,7,4,8,0,0,zzR,@)");
	SerialBT.println("add_8way_pad(11,10,1,5,2,6,3,7,4,8,0,0,zzS,@)");
	SerialBT.println("add_8way_pad(15,10,1,5,2,6,3,7,4,8,0,0,zzT,@)");
	SerialBT.println("add_touch_pad(0,1,6,-3,23,0,0,J,@)");
	SerialBT.println("add_8way_pad(3,10,1,5,2,6,3,7,4,8,0,300,zzQ,@)");
	SerialBT.println("add_led(18,5,1,5,0,0,0)");
	SerialBT.println("add_led(17,5,1,4,0,0,0)");
	SerialBT.println("add_led(15,5,1,2,0,0,0)");
	SerialBT.println("add_led(14,5,1,1,0,0,0)");
	SerialBT.println("add_led(17,2,2,M,255,0,0)");
	SerialBT.println("add_led(12,3,1,H,0,255,0)");
	SerialBT.println("add_led(16,5,1,3,0,0,0)");
	SerialBT.println("set_panel_notes(MURGETROID Controller,by Don Wile,8/24/20,)");
	SerialBT.println("run()");
	SerialBT.println("*");









	// this is necessary because the BT Electronics app sends position settings of the controls after
	// I send it the new GUI...this causes a false CREATE mode detection
	delay(1000);
	//SerialBT.flush();
	FLUSH_BT_BUFFER();

}

////////////////////////////////////////////////////////////////////////
void GUI2()  // this is a simplified GUI
{
	SerialBT.println("*.kwl");
	SerialBT.println("clear_panel()");
	SerialBT.println("set_grid_size(23,13)");
	SerialBT.println("add_text(1,10,large,L,DOTS,245,240,245,)");
	SerialBT.println("add_text(1,11,large,L,LINE,245,240,245,)");
	SerialBT.println("add_text(1,9,large,L,CIRCLE,245,240,245,)");
	SerialBT.println("add_text(1,8,large,L,RECT,245,240,245,)");
	SerialBT.println("add_text(8,9,large,L,TRANS,245,240,245,)");
	SerialBT.println("add_text(6,9,large,L,CYCLE,245,240,245,)");
	SerialBT.println("add_text(16,1,medium,L,WHITE,245,240,245,)");
	SerialBT.println("add_text(12,5,large,C,LOAD,245,240,245,)");
	SerialBT.println("add_text(10,9,large,L,COLOR,245,240,245,)");
	SerialBT.println("add_text(3,12,large,L,SPEED,245,240,245,)");
	SerialBT.println("add_text(5,12,large,L,EFFECT,245,240,245,)");
	SerialBT.println("add_text(13,9,xlarge,L,CLEAR,245,240,245,)");
	SerialBT.println("add_text(7,1,medium,L,RED,255,0,0,)");
	SerialBT.println("add_text(14,1,medium,L,RED,245,0,0,)");
	SerialBT.println("add_text(6,0,large,L,HUE,245,240,245,)");
	SerialBT.println("add_text(9,2,xlarge,L,UNDO,245,240,245,)");
	SerialBT.println("add_text(12,3,large,C,SAVE,245,240,245,)");
	SerialBT.println("add_text(3,7,large,C,1,245,240,245,A)");
	SerialBT.println("add_text(8,4,large,C,1,245,240,245,C)");
	SerialBT.println("add_text(6,4,large,C,1,245,240,245,B)");
	SerialBT.println("add_text(10,4,large,C,1,245,240,245,E)");
	SerialBT.println("add_text(8,12,xlarge,L,MURGETROID CONTROLLER,255,171,0,F)");
	SerialBT.println("add_text(12,2,large,L,PLAY SAVES,245,240,245,)");
	//SerialBT.println("add_text(19,9,large,L,CREATE,245,240,245,)");    ///
	SerialBT.println("add_text(1,6,large,L,CREATE,245,240,245,)");
	SerialBT.println("add_text(16,9,xlarge,L,RESET,245,240,245,)");
	SerialBT.println("add_text(5,7,large,C,5,245,240,245,D)");
	SerialBT.println("add_text(9,1,medium,R,YELLOW,245,240,0,)");
	SerialBT.println("add_text(12,1,medium,L,BLUE,0,0,245,)");
	SerialBT.println("add_text(10,1,medium,L,GREEN,0,240,0,)");
	SerialBT.println("add_text(22,12,large,L,GUI,245,240,245,)");
	SerialBT.println("add_text(11,6,large,L,GENERATE IMAGE,245,240,245,)");
	SerialBT.println("add_text(17,8,large,L,CONTINUOUS TEXT IMAGE,245,240,245,)");
	SerialBT.println("add_text(18,10,small,R,MAX,245,240,245,)");
	SerialBT.println("add_text(19,10,medium,L,BRIGHTNESS,245,240,245,)");
	SerialBT.println("add_text(17,0,large,L,RANDOM HUE,245,240,245,)");
	SerialBT.println("add_text(21,0,large,L,LOVE,245,240,245,)");
	SerialBT.println("add_text(21,1,large,L,JOY,245,240,245,)");
	SerialBT.println("add_text(21,2,large,L,WOW!,245,240,245,)");
	SerialBT.println("add_text(20,3,large,L,MURGETROID,245,240,245,)");
	SerialBT.println("add_text(20,4,large,L,BE HAPPY,245,240,245,)");
	SerialBT.println("add_text(20,5,large,L,HELLO,245,240,245,)");
	SerialBT.println("add_text(15,6,large,L,IMAGE TEXT,245,240,245,)");
	SerialBT.println("add_text(19,6,large,L,IMAGE EFFECT,245,240,245,)");
	SerialBT.println("add_button(6,10,15,zzG,@)");
	SerialBT.println("add_button(15,1,7,I,@)");
	SerialBT.println("add_button(17,5,19,zL5,@)");
	SerialBT.println("add_button(16,5,18,zL4,@)");
	SerialBT.println("add_button(15,5,23,zL3,@)");
	SerialBT.println("add_button(14,5,22,zL2,@)");
	SerialBT.println("add_button(13,5,21,zL1,@)");
	SerialBT.println("add_button(8,10,17,zzB,@)");
	SerialBT.println("add_button(10,10,14,zzM,@)");
	SerialBT.println("add_button(7,2,27,M,@)");
	SerialBT.println("add_button(13,3,21,zK1,@)");
	SerialBT.println("add_button(14,3,22,zK2,@)");
	SerialBT.println("add_button(15,3,23,zK3,@)");
	SerialBT.println("add_button(16,3,18,zK4,@)");
	SerialBT.println("add_button(17,3,19,zK5,@)");
	SerialBT.println("add_button(22,11,14,zzC,@)");
	SerialBT.println("add_button(16,10,28,zB,@)");
	SerialBT.println("add_button(12,7,29,zP,@)");
	SerialBT.println("add_button(20,0,21,j,@)");
	SerialBT.println("add_button(20,1,22,k,@)");
	SerialBT.println("add_button(20,2,23,o,@)");
	SerialBT.println("add_button(19,3,18,m,@)");
	SerialBT.println("add_button(19,4,19,n,@)");
	SerialBT.println("add_button(19,5,20,l,@)");
	SerialBT.println("add_button(13,10,26,O,@)");
	SerialBT.println("add_switch(8,11,2,zzH@,zzI@,0,0)");
	SerialBT.println("add_switch(6,11,2,zzE@,zzF@,0,0)");
	SerialBT.println("add_switch(10,11,2,zzK@,zzL@,0,0)");
	SerialBT.println("add_switch(15,2,2,zzN@,zzO@,0,0)");
	//SerialBT.println("add_switch(21,9,1,K@,L@,0,0)");
	SerialBT.println("add_switch(1,7,1,K@,L@,0,0)");
	SerialBT.println("add_switch(15,8,2,u@,v@,0,0)");
	SerialBT.println("add_switch(15,0,2,zR@,zS@,0,1)");  //
	SerialBT.println("add_slider(0,8,3,0,3,1,g,@,1)");
	SerialBT.println("add_slider(3,8,3,1,10,1,f,@,1)");
	SerialBT.println("add_slider(7,0,8,0,255,0,H,@,1)");
	SerialBT.println("add_slider(15,7,2,0,10,0,t,@,1)");
	SerialBT.println("add_slider(5,8,3,1,10,5,zM,@,1)");
	SerialBT.println("add_slider(6,5,4,1,5,1,zzD,@,1)");
	SerialBT.println("add_slider(8,5,4,1,7,1,zzA,@,1)");
	SerialBT.println("add_slider(10,5,4,1,3,1,zzJ,@,1)");
	SerialBT.println("add_slider(18,11,1,1,510,1,q,@,1)");
	SerialBT.println("add_slider(19,7,1,0,18,0,zzP,@,1)");   //
	SerialBT.println("add_touch_pad(0,0,6,-3,23,0,0,J,@)");
	SerialBT.println("add_led(17,1,2,M,255,0,0)");
	SerialBT.println("add_led(13,4,1,1,0,0,0)");
	SerialBT.println("add_led(14,4,1,2,0,0,0)");
	SerialBT.println("add_led(15,4,1,3,0,0,0)");
	SerialBT.println("add_led(16,4,1,4,0,0,0)");
	SerialBT.println("add_led(17,4,1,5,0,0,0)");
	SerialBT.println("set_panel_notes(MURGETROID 3 Controller,by Don Wile,8/24/20,)");
	SerialBT.println("run()");
	SerialBT.println("*");




	// turn the SAVE indicator lights ON or OFF
	for (byte n = 1; n < maximum_number_of_SAVED_images + 1; ++n)  // turn the appropriate SAVE indicator light to the correct color
	{
		if (G_SAVED[n] == 1)
		{
			//String BT_string2send = String("*MR" + String(leds1[0].r) + "G" + String(leds1[0].g) + "B" + String(leds1[0].b) + "*");

			String BT_string2send = String("*" + String(n) + "R" + String(255) + "G" + String(255) + "B" + String(255) + "*");  // send WHITE to indicator
			SerialBT.print(BT_string2send);  // turn indicator to HUE color
		}
		else
		{
			String BT_string2send = String("*" + String(n) + "R" + String(0) + "G" + String(0) + "B" + String(0) + "*");  // send DARK to indicator
			SerialBT.print(BT_string2send);  // turn indicator to HUE color
		}

	}

	// this is necessary because the BT Electronics app sends position settings of the controls after
	// I send it the new GUI...this causes a false CREATE mode detection
	delay(1000);
	//SerialBT.flush();
	FLUSH_BT_BUFFER();


}

/////////////////////////////////////////////////////////////////////////
void MODIFY_GUI1(byte element)  // force some GUI elements to be in the correct state
{
	if (G_GUI != 1) { return; }

	if (element == 1)
	{
		// turn off the "continuous special" switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(16, 8)");
		SerialBT.println("add_switch(16,8,2,u@,v@,0,0)");  ////
		SerialBT.println("*");
	}

	if (element == 2)
	{
		// turn on CREATE mode switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(7,3)");
		SerialBT.println("add_switch(7,3,1,K@,L@,0,1)");  ////
		SerialBT.println("*");
	}

	if (element == 3)  // modify brightness slider control position
	{
		int slider_level = 0;

		// set BRIGHTNESS control
		if (G_dim > 126)
		{
			slider_level = 3 * (G_dim - 84);  // reverse of dimming equation found in BLUE_TOOTH_COMMAND_HANDLER
		}
		else
		{
			slider_level = G_dim;
		}

		String dimming = String(slider_level);
		String output = String("add_slider(16,10,1,1,510," + dimming + ", q, @,1)");



		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(16, 10)");
		SerialBT.println(output);
		SerialBT.println("*");


	}



}

/////////////////////////////////////////////////////////////////////////
void MODIFY_GUI2(byte element)  // force some GUI2 elements to be in the correct state
{
	if (G_GUI != 2) { return; }

	if (element == 1)
	{
		// turn off the "continuous special" switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(15, 8)");
		SerialBT.println("add_switch(15,8,2,u@,v@,0,0)");////
		SerialBT.println("*");
	}

	if (element == 2)
	{
		// turn on CREATE mode switch
		SerialBT.println("*.kwl");
		//SerialBT.println("clear_location(21, 9)");
		SerialBT.println("clear_location(1, 7)");
		//SerialBT.println("add_switch(21,9,1,K@,L@,0,1)");  ///
		SerialBT.println("add_switch(1,7,1,K@,L@,0,1)");  ///
		SerialBT.println("*");
	}

	if (element == 3)
	{
		// turn off 'PLAY SAVES' switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(15, 2)");
		SerialBT.println("add_switch(15,2,2,zzN@,zzO@,0,0)"); ////
		SerialBT.println("*");
	}


	if (element == 4)
	{
		// pre-set SPEED slider to 6
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(3, 8)");
		SerialBT.println("add_slider(3,8,3,1,10,6,f,@,1)"); ////  preset to 6
		SerialBT.println("*");
	}

	if (element == 5)
	{
		// pre-set EFFECT slider to G_EFFECT_slider
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(5, 8)");
		//SerialBT.println("add_slider(5,8,3,1,10,10,zM,@,1)"); ////  preset to 10


		String myString1 = "add_slider(5,8,3,1,10,";
		String myString2 = ", zM, @,1)";
		myString1 = myString1 + G_EFFECT_slider + myString2;
		SerialBT.println(myString1);
		SerialBT.println("*");

		SerialBT.print("*D");  // update GUI2 text
		SerialBT.print(G_EFFECT_slider);
		SerialBT.print("*");
	}

	if (element == 6)
	{
		// pre-set cycle slider switch off
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(6, 11)");
		SerialBT.println("add_switch(6,11,2,zzE@,zzF@,0,0)"); ////  off
		SerialBT.println("*");
	}

	if (element == 7)
	{
		// set  TRANS slider switch off
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(8, 11)");
		SerialBT.println("add_switch(8,11,2,zzH@,zzI@,0,0)"); ////  off
		SerialBT.println("*");
	}

	if (element == 8)
	{
		// set  COLOR slider switch off
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(10, 11)");
		SerialBT.println("add_switch(10,11,2,zzK@,zzL@,0,0)"); ////  off
		SerialBT.println("*");
	}

	if (element == 9)
	{
		// turn off RANDOM HUE switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(15, 0)");
		SerialBT.println("add_switch(15,0,2,zR@,zS@,0,0)");  // off
		SerialBT.println("*");
		G_RAND_HUE = 0;  // turn off RANDOM HUE
	}

	if (element == 10)  // modify brightness slider control position
	{
		int slider_level = 0;

		// set BRIGHTNESS control
		if (G_dim > 126)
		{
			slider_level = 3 * (G_dim - 84);  // reverse of dimming equation found in BLUE_TOOTH_COMMAND_HANDLER
		}
		else
		{
			slider_level = G_dim;
		}

		String dimming = String(slider_level);
		String output = String("add_slider(18,11,1,1,510," + dimming + ", q, @,1)");

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(18, 11)");
		SerialBT.println(output);
		SerialBT.println("*");


	}

}

////////////////////////////////////////////////////////////////////////
int ADD_SPECIAL_TEXT()  // return the new stringSize with Special Text images added
{


	int stringSize = strlen(scroll_text_array);
	byte fill_size = 24;  // number of times special character is used
	byte num_char_added = 4;

	if (SERIAL_MON == 1)
	{
		Serial.println("");
		Serial.println(F("ADD_SPECIAL_TEXT(): ############## start"));
		Serial.print(F("stringSize= "));
		Serial.println(stringSize);
		Serial.print(F("G_special_slider= "));
		Serial.println(G_special_slider);
		Serial.print(F("G_continuous_SPECIAL_mode= "));
		Serial.println(G_continuous_SPECIAL_mode);
		Serial.print(F("G_CREATE_mode= "));
		Serial.println(G_CREATE_mode);
		Serial.print(F("G_TEXT_flag= "));
		Serial.println(G_TEXT_flag);
		Serial.print(F("G_special_saved_flag= "));
		Serial.println(G_special_saved_flag);
		Serial.println("");
	}

	// the below is needed to prevent a STACK CRASH
	if ((stringSize >= MAX_TEXT_DISPLAYED - num_char_added) || (G_continuous_SPECIAL_mode == 1))
	{
		for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)
		{
			scroll_text_array[n] = '\0';
		}

		//return 0; 
	}

	stringSize = strlen(scroll_text_array);

	//if (G_special_saved_flag == 1)  // don't add extra characters if slider is pointing to a saved image
	//{
	//	G_special_char_select = 1;
	//	return stringSize;
	//}

	// add special characters if SPECIAL slider>0
	if ((G_special_slider > 0) && (G_continuous_SPECIAL_mode == 0) && (stringSize > 0) && (G_TEXT_flag == 1))
	{

		G_TEXT_flag = 0;  // need this variable to prevent false TEXT display 

		char text_array_bak[MAX_TEXT_DISPLAYED];

		// initialize the array
		for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)
		{
			text_array_bak[n] = '\0';
		}

		for (int n = 0; n < stringSize; ++n)
		{
			text_array_bak[n + 2] = scroll_text_array[n];  // shift start 
		}

		if (G_special_saved_flag == 0)
		{
			// add special characters
			text_array_bak[stringSize + 2] = G_special;
			text_array_bak[stringSize + 3] = G_special;
			text_array_bak[0] = G_special;
			text_array_bak[1] = G_special;
		}
		else
		{
			// add special characters that will load leds_saved
			//text_array_bak[stringSize + 2] = '*';  // 1st half of saved image
			//text_array_bak[stringSize + 3] = '%';  // 2nd half of saved image

			//text_array_bak[0] = '*';
			//text_array_bak[1] = '%';

			//	text_array_bak[1] = '*';   // test only
		}

		stringSize = stringSize + num_char_added;  // account for added special characters

		// modify the text array
		for (int n = 0; n < stringSize; ++n)
		{
			scroll_text_array[n] = text_array_bak[n];
		}

		if (SERIAL_MON == 1)
		{
			Serial.println("");
			Serial.println(F("ADD_SPECIAL_TEXT(): after special char modify"));
			Serial.println((char*)scroll_text_array);
			Serial.print(F("ADD_SPECIAL_TEXT(): stringSize="));
			Serial.println(stringSize);
			Serial.println("");
		}
	}

	// only display CONTINUOUS IMAGE TEXT
	if ((G_special_slider > 0) && (G_continuous_SPECIAL_mode == 1) && (G_CREATE_mode == 1))
	{
		if (G_special_saved_flag == 0)
		{
			for (int n = 0; n < fill_size; ++n)
			{
				scroll_text_array[n] = G_special;  // fill text array with special character
			}
		}
		else
		{
			for (int n = 0; n < fill_size; n = n + 2)
			{
				scroll_text_array[n] = '*';  // fill text array with special character
				scroll_text_array[n + 1] = '%';  // fill text array with special character
				//	text_array[n + 1] = '*';  // test only
			}
		}

		scroll_text_array[fill_size] = '\0'; // terminate the array
		stringSize = strlen(scroll_text_array);

		if (SERIAL_MON == 1)
		{
			Serial.print(F("--------->>>  ADD_SPECIAL_TEXT() 2:  stringSize= "));
			Serial.println(stringSize);
			Serial.print(F("ADD_SPECIAL_TEXT() 2: text_array= "));
			Serial.println((char*)scroll_text_array);
			Serial.println("");
		}

	}

	//G_TEXT_flag = 0;  // need this variable to prevent false TEXT display 

	if (SERIAL_MON == 1)
	{
		Serial.println(F("leaving ADD_SPECIAL_TEXT() "));
		Serial.println("");
	}

	return stringSize;

}


/////////////////////////////////////////////////////////////////////////
void SHOW_255()
{

	Serial.println(F("-->SHOW_255: start "));
	Serial.println("");

	//HALL_MEASURE3(22);
	int stringSize;

	// SIGNAL(85);  // generate a GREEN test signal

   //////////  I don't understand why the following 3 lines are necessary but they help reduce the frequency 
   //////////  of a trailing false images after 8way ring followed by RANDOM RING

	SHOW_slow();
	delay(300);  // note: 100 does not work
	SHOW_slow();

	////////////////////////////

	stringSize = ADD_SPECIAL_TEXT();  // add special image Text characters to text_array

	//stringSize = strlen(text_array);  // new string size

	Serial.println(F("-->SHOW_255: before SCOLL_TEXT "));
	Serial.print(F("stringSize="));
	Serial.println(stringSize);
	Serial.print(F("G_continuous_SPECIAL_mode="));
	Serial.println(G_continuous_SPECIAL_mode);
	Serial.print(F("scroll_text_array="));
	Serial.println(scroll_text_array);
	Serial.println("");




	SCROLL_TEXT(scroll_text_array, stringSize, 1, G_scroll_speed, G_hue, G_banner, G_continuous_SPECIAL_mode, G_cont_special_depth, G_cont_special_effect);

	Serial.println(F("SHOW_255: BT_and_DC_CHECKandDO() "));
	Serial.println("");

	BT_and_DC_CHECKandDO();

	Serial.println(F("leaving SHOW_255 "));
	Serial.println("");
}


//////////////////////////////////////////////////////////////////////
void CONTINUOUS_SPECIAL_MODE_OFF()
// turn off "continuous special mode"
{


	if (G_continuous_SPECIAL_mode == 1)
	{
		//DC_OUT_array[0] = 28;   // turn off "continuous special" mode
		//DC_OUT_array[1] = 0;
		//DC_SEND();

		G_continuous_SPECIAL_mode_was_ON = 1;

		G_continuous_SPECIAL_mode = 0;

		for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)
		{
			scroll_text_array[n] = '\0';
		}

	}

	if (G_GUI == 1)
	{
		MODIFY_GUI1(1);  // turn off "continuous special" switch
	}

	if (G_GUI == 2)
	{
		MODIFY_GUI2(1);  // turn off "continuous special" switch
	}


}


////////////////////////////////////////////////////////////////////
void RESET(int skip)  // if skip=1 then don't reset brightness, if skip=2 don't reset brightness and don't reset G_production
{

	//if (G_allow_RESET  == 0) // set to 1 if RESET is to be skipped)
	//{
	//	
	//	return;
	//	
	//}

	DISPLAY_RESET_IMAGE(2);


	//SerialBT.flush();

	//////////////////
	G_CYCLE_ON = 0;
	G_COLOR_CYCLE_SWITCH_ON = 0;

	///////////////////


	G_show_num = 0; // show handler will increment 1
	if (skip != 2)
	{
		G_production = DEFAULT_PRODUCTION;

	}
	G_continuous_SPECIAL_mode = 0;
	G_special_char_select = 1;
	G_banner = 0;
	G_scroll_speed = 1;
	G_CREATE_mode = 0;
	G_cycle = 1;
	G_transformation = 1;
	G_COLOR_cycle = 1;
	G_PLAY_SAVES_MODE_ON = 0;  // set to 1 if PLAY SAVES mode is on
	G_EFFECT_slider = NUM_RANDOM_IMAGES;
	G_special_saved_flag = 0;
	G_force_sound_productions = G_force_sound_productions_original;
	G_sound_detected_flag = 0;
	G_MUSIC_detected_flag = 0; 
	G_music_only_switch = 0;

	//DC_OUT_array[0] = 33;  // RESET GUI and applicable variables
	//DC_SEND();

	G_continuous_SPECIAL_mode_was_ON = 0;


	///////////////// FROM SLAVE ////////////////////////////////////////////

	G_RESET = 1; // this is cleared by MASTER DC command 34, also cleared by SHOW_HANDLER

	G_interceeded_flag = 0;
	G_beginning_SHOW_flag = 0;
	G_show_num = 1;
	G_repeat_show_flag = 0;
	G_CREATE_mode = 0;
	G_hue = 0;  // red
	G_pointer = 0;
	G_pointer_rollover_flag = 0;
	G_rotate_color = 0;
	G_SPEED_slider = 1;
	G_hue_cycle_vert = 0;
	G_hue_cycle_hoz = 0;
	G_panel1_on = 1;
	G_panel2_on = 1;
	G_panel3_on = 1;
	G_panel4_on = 1;
	G_STAR_flag = 0;
	G_geometery = 1;
	G_end_flag = 0;

	G_cycle_XYflipInvert_mode = 0;

	G_continuous_SPECIAL_mode = 0;
	G_Vroll = 0;
	G_Hroll = 0;
	G_AUTO_DIM = 1;

	G_active_PSS_image = 0;
	G_RAND_HUE = 1;
	G_KEEP = 0;
	G_num2UNDO = 0;
	G_CYCLE_SAVES = 0;
	G_CYCLE = 0;
	G_CONT_GEN = 0;
	G_transformation = 1;
	G_TRANS_SWITCH = 0;
	G_cycle_gen_on = 0;
	G_color_cycle_gen_on = 0;
	G_Xbounce = 0;
	G_Ybounce = 0;

	G_MIRROR_HV = 0; // set to 1 for continuous horizontal mirroring

	G_MIRROR_diag = 0; // set to 1 for continuous diagonal mirroring



	G_exit_PLAY_SAVES_MODE = 0; // flag PLAY SAVES MODE to exit after the show

	//SerialBT.flush();
	FLUSH_BT_BUFFER();

	G_UNDO_stored = 0;
	G_SKIP_BTCH = 0;

	G_TIMES_SAVED_IMAGES_SHOWN = 0;



	for (int n = 0; n < MAX_TEXT_DISPLAYED; ++n)
	{
		scroll_text_array[n] = ' ';  // used when calling SCROLL_TEXT
	}

	//strcpy(scroll_text_array, "");

	// figure out how to make sure I transfer back to MASTER and start Production 1
	// update GUI generator



	if (skip == 0)
	{


		MAX_BRIGHTNESS();  // set to DEFAULT_BRIGTHNESS

		//for (int n = 0; n < NUM_LEDS; ++n)  // first set to maximum G_brightness then dim
		//{

		//	//FastLED.setBrightness(G_dim);

		//	leds1[n].maximizeBrightness();
		//	//leds1[n].fadeLightBy(G_dim); // Dim a color 

		//	leds2[n].maximizeBrightness();
		//	//leds2[n].fadeLightBy(G_dim); // Dim a color 

		//	leds3[n].maximizeBrightness();
		//	//leds3[n].fadeLightBy(G_dim); // Dim a color 

		//	leds4[n].maximizeBrightness();
		//	//leds4[n].fadeLightBy(G_dim); // Dim a color 
		//}
	}


	if (G_GUI == 1)
	{
		GUI();
		MODIFY_GUI1(3);  // set brightness
	}

	if (G_GUI == 2)
	{
		GUI2();
		MODIFY_GUI2(10);  // set brightness

	}

	if (G_GUI == 3)
	{
		GUI3();
		MODIFY_GUI3(1);  // set brightness
		MODIFY_GUI3(4);  // update slider text

	}

	if ((G_GUI == 3) || (G_GUI == 4))
	{
		SerialBT.print("*I");  // update production number
		SerialBT.print(G_production);
		SerialBT.print("*");

		UPDATE_PRODUCTION_NAME();
	}




	CONTINUOUS_SPECIAL_MODE_OFF();

	CLEAR_ALL_LEDS();
	SHOW_slow();
	//SerialBT.flush();


	///////////////////////////////  END of FROM SLAVE  ///////////////////


}

///////////////////////////////////////////////////////////////////////////
void SEND_CYCLE_SLIDER(byte position)  // DC send the GUI2 CYCLE slider value, executed in CREATE_MODE()
{
	//if (DC_OUT_array[1] == 0)  // turn off all positions
	if (G_cycle_gen_on == 0)  // turn off all positions
		//G_cycle_gen_on = 0;  // set to 1 to turn on cycle generator
	{
		//DC_OUT_array[0] = 35;  //horizontal roll generator
		//DC_SEND();
		G_Hroll = 0;

		/*DC_OUT_array[0] = 36;
		DC_SEND();*/
		G_Vroll = 0;

		/*DC_OUT_array[0] = 21;
		DC_SEND();*/

		G_STAR_flag = 0;


		/*DC_OUT_array[0] = 38;
		DC_SEND();*/

		G_CONT_GEN = 0;

		G_Xbounce = 0;
		G_Ybounce = 0;

		//G_MIRROR_HV = 0; // set to 1 for continuous horizontal mirroring
		//G_MIRROR_vert = 0; // set to 1 for continuous vertical mirroring
		//G_MIRROR_diag = 0; // set to 1 for continuous diagonal mirroring

	}
	else  // turn on appropriate function
	{
		switch (position) {
		case 0: // turn off cycle slider
			G_cycle_gen_on = 0;
			G_color_cycle_gen_on = 0;
			break;
		case 1: // turn on both hoz roll and vert roll
			//DC_OUT_array[0] = 35;  //horizontal roll generator
			//DC_SEND();
			G_Hroll = 1;
			//DC_OUT_array[0] = 36;  // vertical roll generator	
			G_Vroll = 1;
			break;
		case 2:
			//DC_OUT_array[0] = 35;  //horizontal roll generator
			G_Hroll = 1;
			break;
		case 3:
			//DC_OUT_array[0] = 36;  // vertical roll generator
			G_Vroll = 1;
			break;
		case 4:  // left
			//DC_OUT_array[0] = 21;  // star mode
			//G_EFFECT_slider = 5;
			//G_STAR_flag = 1;

			LOAD_BACKGROUND();  // background saved for 8way CYCLE pad in BT command processor

			++G_MIRROR_HV; // // controls direction of horizontal mirroring

			if (G_MIRROR_HV > 4)
			{
				G_MIRROR_HV = 1;
			}

			switch (G_MIRROR_HV) {
			case 0:
				// not used
				break;
			case 1:
				MIRROR_MID_HOZ(1);
				break;
			case 2:
				MIRROR_MID_HOZ(2);
				break;
			case 3:
				MIRROR_MID_VERT(1);
				break;
			case 4:
				MIRROR_MID_VERT(2);
				break;

			}

			SHOW_slow();

			break;
		case 5:  // upper right
			//DC_OUT_array[0] = 38; // random CONT_GEN generator
			//G_CONT_GEN = 1;
			//G_GEN = 1;
			LOAD_BACKGROUND();  // background saved for 8way CYCLE pad in BT command processor

			++G_MIRROR_diag; // // controls direction of horizontal mirroring

			if (G_MIRROR_diag > 4)
			{
				G_MIRROR_diag = 1;
			}

			MIRROR_MID_DIAG(G_MIRROR_diag);

			SHOW_slow();

			break;
		case 6:      // new X bounce
			G_Xbounce = 1;
			break;
		case 7:      // new Y bounce
			G_Ybounce = 1;
			break;
		case 8:      // uppper left
			//G_EFFECT_slider = 3;
			//G_STAR_flag = 1;
			//G_Xbounce = 2;
			LOAD_BACKGROUND();  // background saved for 8way CYCLE pad in BT command processor

			++G_MIRROR_diag; // // controls direction of horizontal mirroring

			if (G_MIRROR_diag > 4)
			{
				G_MIRROR_diag = 1;
			}

			++G_MIRROR_HV; // // controls direction of horizontal mirroring

			if (G_MIRROR_HV > 4)
			{
				G_MIRROR_HV = 1;
			}

			MIRROR_MID_DIAG(G_MIRROR_diag);

			switch (G_MIRROR_HV) {
			case 0:
				// not used
				break;
			case 1:
				MIRROR_MID_HOZ(1);
				break;
			case 2:
				MIRROR_MID_HOZ(2);
				break;
			case 3:
				MIRROR_MID_VERT(1);
				break;
			case 4:
				MIRROR_MID_VERT(2);
				break;
			}

			SHOW_slow();


			break;
		default:
			// statements
			break;
		}
	}

	//DC_SEND();
}

///////////////////////////////////////////////////////////////////////////
void SEND_COLOR_SLIDER(byte position)  // DC send the GUI2 COLOR slider value (note: this is not the HUE slider)
{
	//if (DC_OUT_array[1] == 0)  // turn off all SLIDE entries
	if (G_color_cycle_gen_on == 0)
	{
		//DC_OUT_array[0] = 14;
		//DC_SEND();
		G_rotate_color = 0;


		/*DC_OUT_array[0] = 16;
		DC_SEND();*/
		G_hue_cycle_vert = 0;

		/*DC_OUT_array[0] = 51;
		DC_SEND();*/
		G_hue_cycle_hoz = 0;

	}
	else  // turn ON appropriate function
	{

		switch (position) {

		case 1:
			//DC_OUT_array[0] = 14;  // rotate colors
			G_rotate_color = 1;
			break;
		case 2:
			//DC_OUT_array[0] = 16;  // cycle hues vertical
			G_hue_cycle_vert = 1;
			break;
		case 3:
			//DC_OUT_array[0] = 51;  // cycle hues horizontal
			G_hue_cycle_hoz = 1;
			break;

		default:
			// statements
			break;
		}
	}

	//DC_SEND();
}


////////////////////////////////////////////////////////////////////////
void TURN_ON_CREATE_MODE()
// turn on CREATE mode if SLAVE has control
{
	//if (G_do_CREATE_mode == 1)
	if ((G_do_CREATE_mode == 1) && (G_CREATE_mode == 0))   // changed 8/11/22
	{
		//if (digitalRead(BOARD_SYNC_IN) == LOW)  // SLAVE has control ... OK to turn on CREATE mode
		//{
		G_do_CREATE_mode = 0;   // clear flag that says enter CREATE mode when SLAVE has control
		G_CREATE_mode = 1;  // CREATE mode entered

		Serial.println(F("TURN_ON_CREATE_MODE: TURN_OFF_PLAY_SAVES_MODE "));
		Serial.println("");

		TURN_OFF_PLAY_SAVES_MODE();

		MODIFY_GUI2(2);  // turn on CREATE mode switch
		//MODIFY_GUI3(2);  // turn on create mode switch

		//clear all saved images
		for (byte n = 0; n < maximum_number_of_SAVED_images + 1; ++n)
		{
			G_SAVED[n] = 0;
		}

		// turn SAVE indicator lights off
		for (byte n = 1; n < maximum_number_of_SAVED_images + 1; ++n)
		{
			String BT_string2send = String("*" + String(n) + "R" + String(0) + "G" + String(0) + "B" + String(0) + "*");  // send DARK to indicator
			SerialBT.print(BT_string2send);  // turn indicator to HUE color
		}



		/////////////////////  turn on CREATE mode  /////////////////////////////////

		//DC_OUT_array[0] = 7;  // turn on CREATE mode
		//DC_OUT_array[1] = 0;  // no meaning
		//DC_SEND();
		G_CREATE_mode = 1;
		G_LOAD_DEFAULT_CREATE_MODE_IMAGE_flag = 1;  // load default image

		G_pointer = 0;   // clear the STACK
		G_pointer_rollover_flag = 0;

		//clear all saved images
		for (byte n = 0; n < maximum_number_of_SAVED_images + 1; ++n)
		{
			G_SAVED[n] = 0;
		}

		for (int n = 0; n < NUM_LEDS; ++n)
		{

			for (byte k = 0; k < 6; ++k)
			{
				leds_saved[k][n] = 0;  // clear saved images
			}
		}


		String BT_string2send = "*FSAVE upto 5 images then 'PLAY SAVES'*";
		SerialBT.print(BT_string2send);  // send instructions to GUI




		//}


	}
}

////////////////////////////////////////////////////////////////////////
void TURN_OFF_PLAY_SAVES_MODE() // turn off PLAY SAVES mode if it is on
{

	

	//	if (G_PLAY_SAVES_MODE_ON == 1)
	{
		G_PLAY_SAVES_MODE_ON = 0;
		//	G_exit_PLAY_SAVES_MODE = 1; 

		MODIFY_GUI2(3); // turn off PLAY SAVES switch
		MODIFY_GUI3(3); //turn off PLAY SAVES switch

		Serial.println(F("TURN_OFF_PLAY_SAVES_MODE()"));
		Serial.println("");

		//Serial.println(F(""));
		//Serial.print(F("$$$$$$$$$ TOPSM TOP: G_dim= "));
		//Serial.println(G_dim);
		//Serial.println(F(""));

		//	SIGNAL(0, 4);
		//	delay(500);   // not sure this is needed to insure PLAY SAVES turns off

			/*DC_OUT_array[0] = 50;
			DC_OUT_array[1] = 0;
			DC_SEND();*/


		if (G_EFFECT_slider != NUM_RANDOM_IMAGES)
		{
			//G_EFFECT_slider = 5; // also set in MASTER with MODIFY_GUI2(5)
			//DC_OUT_array[0] = 7; // change EFFECT slider position
			//DC_OUT_array[1] = G_EFFECT_slider;
			//DC_SEND();

			/*Serial.println(F(" "));
			Serial.println(F("--------->  TURN_OFF_PLAY_SAVES_MODE));
			Serial.print(F("G_EFFECT_slider= "));
			Serial.println(G_EFFECT_slider);
			Serial.println(F(" "));*/

			//G_EFFECT_slider = DC_IN_array[1];

			if (G_EFFECT_slider != G_EFFECT_slider_previous)
			{
				MODIFY_GUI2(5); // preset EFFECT slider
				G_EFFECT_slider_previous = G_EFFECT_slider;
			}
		}
	}

	//Serial.println(F(""));
	//Serial.print(F("$$$$$$$$$ TOPSM end: G_dim= "));
	//Serial.println(G_dim);
	//Serial.println(F(""));
}



//////////////////////////////////////////////////////////////////////
//********************************************************************************************************************************************
void LOAD_BMP_SAVED_2BUFFER(int bmp, int panel)   // load the LED array into 1 panel,  with the passed bitmap number, bitmap numbers start with 1000 or 2000, panel = 1 or 2
// this function will load data from leds_saved[6][NUM_LEDS] into the specified panel
// bmp is 1001,1002,1003,1004,1005 for leds_saved 1,2,3,4,5 : first 11 columns
// bmp is 2001,2002,2003,2004,2005 for leds_saved 1,2,3,4,5 : last 11 columns

{
	int ind = 0;

	int L_led_adr = 0;
	int led_adr = 0;
	byte second_half_flag = 0;  // set to 1 if 2nd half of bmp is to be loaded
	G_UNDO_stored = 0;  // flag that leds_buffer1 or leds_buffer2 can't be used for UNDO

	byte predefined_image = 1;  // for testing only...sets which manufactured image to load

	if ((bmp > 2000) && (bmp < 3000))  // saved image
	{
		second_half_flag = 1;
		bmp = bmp - 2000;
	}

	if ((bmp > 1000) && (bmp < 2000))  // saved image
	{
		bmp = bmp - 1000;
	}



	if (SERIAL_MON == 1)
	{
		Serial.println(F(""));
		Serial.println(F("<<<<<<<<<<< LOAD_BMP_SAVED_2BUFFER  >>>>>>>>>>>>>"));
		Serial.print(F("LBS: adjusted # bmp="));
		Serial.println(bmp);
		Serial.print(F("LBS: panel="));
		Serial.println(panel);
		Serial.print(F("LBS: second_half_flag="));
		Serial.println(second_half_flag);
		Serial.println(F(""));
	}

	//// ---------------------->>>>>   FOR TESTING ONLY : pre-load leds_saved[bmp][adr];  ////
	//for (int n = 0; n < NUM_LEDS; ++n)
	//{
	//	leds_saved[1][n] = 0;  // clear array
	//}

	//CLEAR_FONT_BUFFER_1();
	//LOAD_BMP_PANEL(54, 1);    /// test image

	//for (int row = 0; row < 22; ++row)  // first half
	//{
	//	for (int col = 0; col < 11; ++col)
	//	{
	//		int adr_from = GET_LED_ADR(row, col);
	//		int adr_to = GET_LED_ADR(row, col);
	//		leds_saved[1][adr_to] =leds1[adr_from] ;
	//	}
	//}
	//
	//

	//CLEAR_FONT_BUFFER_1();
	//LOAD_BMP_PANEL(55, 1);    /// test image

	//for (int row = 0; row < 22; ++row)   // 2nd half
	//{
	//	for (int col = 0; col < 11; ++col)
	//	{
	//		int adr_from = GET_LED_ADR(row, col);
	//		int adr_to = GET_LED_ADR(row, col+11);
	//		leds_saved[1][adr_to] = leds1[adr_from];
	//	}
	//}

	////////////////////////////////////////////////////////////////////////////////////


	//if (SERIAL_MON == 1)
	//{
	//	Serial.println(F(""));
	//	Serial.println(F("LBS: combined image: leds_saved[1]"));

	//	DUMP_LED_ARRAY(leds_saved[1], NUM_LEDS);

	//}




	//	//----> below doesn't work...causes big blanks in display...don't know why?
	//	//led_adr = modify_adr(G_upside_down, 0, ((NUM_LEDS)-adr));   //make image right side up or upside down and backwards


	//	//---->below this works
	//	led_adr = modify_adr(G_upside_down, 0, adr );   //make image right side up or upside down




	int offset = 11;

	if (panel == 1)
	{
		if (second_half_flag == 1)
		{
			offset = 11;  // load 2nd half of image
		}
		else
		{
			offset = 0;
		}


		for (int row = 0; row < 22; ++row)
		{
			for (int col = 0; col < 11; ++col)
			{
				int adr_from = GET_LED_ADR(row, col + offset);
				int adr_to = GET_LED_ADR(row, col);
				adr_to = modify_adr(0, 0, adr_to); // make image upside down

				//adr_to = adr_from; 
				leds_buffer1[adr_to] = leds_saved[bmp][adr_from];
			}
		}

	}

	if (panel == 2)
	{
		if (second_half_flag == 1)
		{
			offset = 11;  // load 2nd half of image
		}
		else
		{
			offset = 0;
		}

		for (int row = 0; row < 22; ++row)
		{
			for (int col = 0; col < 11; ++col)
			{
				int adr_from = GET_LED_ADR(row, col + offset);
				int adr_to = GET_LED_ADR(row, col);
				//adr_to = modify_adr(0, 0, adr_to); // make image upside down
				leds_buffer2[adr_to] = leds_saved[bmp][adr_from];
			}
		}

	}


	//if (SERIAL_MON == 1)
	//{
	//	Serial.println(F(""));
	//	Serial.println(F("LBS: END ^^^^^^^^ after copy to leds1 or leds2"));
	//	Serial.print(F("second_half_flag= "));
	//	Serial.println(second_half_flag);
	//	Serial.print(F("panel= "));
	//	Serial.println(panel);
	//	Serial.print(F("bmp= "));
	//	Serial.println(bmp);

	//	Serial.println(F("DUMPING leds1 "));
	//	DUMP_LED_ARRAY(leds1, NUM_LEDS);

	//	Serial.println(F("DUMPING leds2 "));
	//	DUMP_LED_ARRAY(leds2, NUM_LEDS);
	//}




}

//////////////////////////////////////////////////////////////////////
//********************************************************************************************************************************************
void LOAD_BMP_2BUFFER(int bmp, int buffer)   // load the LED array into leds_buffer#,  with the passed bitmap number, bitmap numbers start with 3000, buffer = 1 or 2
// this function will load image data into the specified panel
// note: bmp number is generated by TEXT2BMP function

{
	int ind = 0;

	int L_led_adr = 0;
	int led_adr = 0;


	byte predefined_image = 1;  // for testing only...sets which manufactured image to load

	G_UNDO_stored = 0;  // flag that leds_buffer1 or leds_buffer2 can't be used for UNDO


	//if (SERIAL_MON == 1)
	//{
	//	Serial.println(F(""));
	//	Serial.println(F("<<<<<<<<<<< LOAD_BMP_SAVED_2BUFFER  >>>>>>>>>>>>>"));
	//	Serial.print(F("LBS: adjusted # bmp="));
	//	Serial.println(bmp);
	//	Serial.print(F("LBS: panel="));
	//	Serial.println(panel);
	//	Serial.print(F("LBS: second_half_flag="));
	//	Serial.println(second_half_flag);
	//	Serial.println(F(""));
	//}




	//if (SERIAL_MON == 1)
	//{
	//	Serial.println(F(""));
	//	Serial.println(F("LBS: combined image: leds_saved[1]"));

	//	DUMP_LED_ARRAY(leds_saved[1], NUM_LEDS);

	//}




	//	//----> below doesn't work...causes big blanks in display...don't know why?
	//	//led_adr = modify_adr(G_upside_down, 0, ((NUM_LEDS)-adr));   //make image right side up or upside down and backwards


	//	//---->below this works
	//	led_adr = modify_adr(G_upside_down, 0, adr );   //make image right side up or upside down




	int offset = 11;

	if (buffer == 1)
	{
		if (G_2nd_half_flag == 1)  // set in TEXT2BMP
		{
			offset = 11;  // load 2nd half of image
		}
		else
		{
			offset = 0;
		}


		LOAD_BMP_PANEL(bmp, 5);  // this loads into leds_buffer1


		if (offset == 11)
		{
			for (int row = 0; row < 22; ++row)
			{
				for (int col = 0; col < 11; ++col)
				{
					int adr_from = GET_LED_ADR(row, col + offset);
					int adr_to = GET_LED_ADR(row, col);
					//adr_to = modify_adr(0, 0, adr_to); // make image upside down
					leds_buffer1[adr_to] = leds_buffer1[adr_from];
				}
			}
		}

	}

	if (buffer == 2)
	{
		if (G_2nd_half_flag == 1)
		{
			offset = 11;  // load 2nd half of image
		}
		else
		{
			offset = 0;
		}

		LOAD_BMP_PANEL(bmp, 6);  // this loads into leds_buffer2

		if (offset == 11)
		{

			for (int row = 0; row < 22; ++row)
			{
				for (int col = 0; col < 11; ++col)
				{
					int adr_from = GET_LED_ADR(row, col + offset);
					int adr_to = GET_LED_ADR(row, col);
					//adr_to = modify_adr(0, 0, adr_to); // make image upside down
					leds_buffer2[adr_to] = leds_buffer2[adr_from];
				}
			}
		}

	}


	//if (SERIAL_MON == 1)
	//{
	//	Serial.println(F(""));
	//	Serial.println(F(">>>>>>>>>>>>>>>>>>>>>>LB2B: END ^^^^^^^^ after copy to leds_buffer1 or leds_buffer2"));
	//	Serial.print(F("G_2nd_half_flag= "));
	//	Serial.println(G_2nd_half_flag);
	//	Serial.print(F("buffer= "));
	//	Serial.println(buffer);
	//	Serial.print(F("bmp= "));
	//	Serial.println(bmp);

	//	Serial.println(F("DUMPING leds_buffer1 "));
	//	DUMP_LED_ARRAY(leds_buffer1, NUM_LEDS);

	//	Serial.println(F("DUMPING leds_buffer2 "));
	//	DUMP_LED_ARRAY(leds_buffer2, NUM_LEDS);
	//}




}

////////////////////////////////////////////////////////////////////////////////////////////////
void DUMP_LED_ARRAY(CRGB dump[], int size)  // dump the passed LED array to the Serial Monitor
{
	if (SERIAL_MON == 0) { return; }  // only execute function if SERIAL monitior enabled

	char elements[NUM_LEDS];
	int adr = 0;

	for (int j = 0; j < NUM_LEDS; ++j)
	{
		elements[j] = '~';
	}

	for (int n = 0; n < size; ++n)  // encode the rgb elements
	{
		if (dump[n].r > 0) { elements[n] = 'R'; }  // red = 1
		if (dump[n].g > 0) { elements[n] = 'G'; }  // green = 2
		if (dump[n].b > 0) { elements[n] = 'B'; }  // blue=3
		if ((dump[n].r > 0) && (dump[n].g > 0) && (dump[n].b == 0)) { elements[n] = 'Y'; }  // yellow=4
		if ((dump[n].r > 0) && (dump[n].g > 0) && (dump[n].b > 0)) { elements[n] = 'w'; }  // white=5

		//if (leds1[n].r > 0) { elements[n] = 1; }  // red = 1
		//if (leds1[n].g > 0) { elements[n] = 2; }  // green = 2
		//if (leds1[n].b > 0) { elements[n] = 3; }  // blue=3

	}

	Serial.println(F(""));
	Serial.println(F("|||||||||||||| DUMP_LED_ARRAY  ||||||||||||||"));

	for (int row = 0; row < 22; ++row)
	{
		for (int col = 0; col < 22; ++col)
		{
			adr = GET_LED_ADR(row, col);
			Serial.print(elements[adr]);

		}
		Serial.println(F(""));
	}

	Serial.println(F("||||||||||||||  END of DUMP_LED_ARRAY  ||||||||||||||"));
	Serial.println(F(""));

}

//********************************************************************************************************************************************
int LOAD_FONT_BUFFER(int bmp, int buffer)   // load the LED array into buffer 1 or buffer 2 for use in DISPLAY_TEXT
{
	//Serial.println(F("LFB1"));

	int ind = 0;
	int H_led_adr = 0;
	int L_led_adr = 0;
	int bmp_speed = 1;

	int led_adr = 0;

	G_UNDO_stored = 0;  // flag that leds_buffer1 or leds_buffer2 can't be used for UNDO

	//Serial.println(F("---------LOAD_FONT_BUFFER  ------------"));
	//Serial.print(F("bmp="));
	//Serial.println(bmp);
	//Serial.print(F("buffer="));
	//Serial.println(buffer);
	//Serial.println(F(""));


	ind = FONT_MAP[bmp];  // point to TYPE

	//FastLED.clear();   // set to black all LEDs

	//type = pgm_read_byte_near(FONT_array + ind);   // type=   255= full bitmap, 254=differential bitmap, 253= end of BMP_array
	type = pgm_read_byte_near(font_TEXT + ind);   // type=   255= full bitmap, 254=differential bitmap, 253= end of BMP_array

	/* Serial.println("position 0 ");
	 Serial.print("PANEL=");
	 Serial.println(panel);
	 Serial.print("bmp #=");
	 Serial.println(bmp);
	 Serial.print("TYPE index,  ind=");
	 Serial.println(ind);
	 Serial.print("TYPE=");
	 Serial.println(type);
	 Serial.println(" ");*/

	++ind;
	bmp_speed = 4 * pgm_read_byte_near(font_TEXT + ind);   // reads the speed of the bitmap and multiplys it by 4

	//noInterrupts();



	if (type == 255)  //full bit map thus read RGB data
	{


		for (int adr = 0; adr < NUM_LEDS; ++adr)
		{

			if (buffer == 2)
			{
				//FLIP(1);   // flip G_upside_down
				G_upside_down = 0;

			}
			else
			{
				//FLIP(0);  // back to normal
				G_upside_down = 1;
			}


			led_adr = modify_adr(G_upside_down, H_led_adr, L_led_adr);   //make image right side up or upside down



			if (buffer == 1)
			{
				++ind;
				leds_buffer1[led_adr].r = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].g = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].b = pgm_read_byte_near(font_TEXT + ind);

				//leds_buffer1[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds_buffer1[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}
			}
			if (buffer == 2)
			{
				++ind;
				leds_buffer2[led_adr].r = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].g = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].b = pgm_read_byte_near(font_TEXT + ind);

				//leds_buffer2[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds_buffer2[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}
			}


		}

	}

	int kind = type;

	while (kind == 254) // differential bitmap
	{



		++ind;
		H_led_adr = pgm_read_byte_near(font_TEXT + ind);  // high byte of LED adr

		/*Serial.println("position 1 ");
		Serial.print("ind= ");
		Serial.println(ind);
		Serial.println("diff bitmap ");
		Serial.print("H_led_adr= ");
		Serial.println(H_led_adr);
		Serial.println(" ");*/

		if (H_led_adr <= 3)  // not a TYPE 
		{

			++ind;
			L_led_adr = pgm_read_byte_near(font_TEXT + ind); // low byte of LED adr

			if (buffer == 2)
			{
				//FLIP(1);   // flip G_upside_down
				G_upside_down = 0;

			}
			else
			{
				//FLIP(0);  // back to normal
				G_upside_down = 1;
			}



			led_adr = modify_adr(G_upside_down, H_led_adr, L_led_adr);   //make image right side up or upside down


			/*Serial.println("position 2 ");
			Serial.print("ind= ");
			Serial.println(ind);
			Serial.print("L_led_adr= ");
			Serial.println(L_led_adr);
			Serial.print("led_adr= ");
			Serial.println(led_adr);
			Serial.print("H_led_adr= ");
			Serial.println(H_led_adr);
			Serial.println(" ");*/



			if (buffer == 1)
			{
				++ind;
				leds_buffer1[led_adr].r = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].g = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer1[led_adr].b = pgm_read_byte_near(font_TEXT + ind);

				//leds_buffer1[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds_buffer1[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}

				/*Serial.println("position 3: panel 1 ");
				Serial.print("ind= ");
				Serial.println(ind);
				Serial.print("led_adr= ");
				Serial.println(led_adr);
				Serial.print("leds1[led_adr].r= ");
				Serial.println(leds1[led_adr].r);
				Serial.print("leds1[led_adr].g= ");
				Serial.println(leds1[led_adr].g);
				Serial.print("leds1[led_adr].b= ");
				Serial.println(leds1[led_adr].b);
				Serial.print("H_led_adr= ");
				Serial.println(H_led_adr);
				Serial.println(" ");*/

			}
			if (buffer == 2)
			{
				++ind;
				leds_buffer2[led_adr].r = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].g = pgm_read_byte_near(font_TEXT + ind);
				++ind;
				leds_buffer2[led_adr].b = pgm_read_byte_near(font_TEXT + ind);

				//leds_buffer2[led_adr].maximizeBrightness();  // first set to maximum G_brightness then dim
				//if (G_max_brightness == 0)
				//{
				//	leds_buffer2[led_adr].fadeLightBy(G_dim); // Dim a color 
				//}

				/*Serial.println("position 4: panel 2 ");
				Serial.print("ind= ");
				Serial.println(ind);
				Serial.print("led_adr= ");
				Serial.println(led_adr);
				Serial.print("leds2[led_adr].r= ");
				Serial.println(leds2[led_adr].r);
				Serial.print("leds2[led_adr].g= ");
				Serial.println(leds2[led_adr].g);
				Serial.print("leds2[led_adr].b= ");
				Serial.println(leds2[led_adr].b);
				Serial.print("H_led_adr= ");
				Serial.println(H_led_adr);
				Serial.println(" ");*/
			}



		}
		else
		{
			kind = 0;   // leave the while loop
		}

	}
	//interrupts();
	//BOARD_SYNC();

//	FLIP(0);  // back to normal

	/*Serial.println("LEAVING LOAD_BMP_PANEL ");
	Serial.println("************************************ ");*/

	//Serial.println(F("LFB2"));

	return bmp_speed;

}


////////////////////////////////////////////////////////////////////////
void SET_FAST()  // set to display FAST LEDs
{
	FastLED[0].setLeds(leds1, NUM_LEDS_FAST);
	FastLED[1].setLeds(leds2, NUM_LEDS_FAST);
	FastLED[2].setLeds(leds3, NUM_LEDS_FAST);
	FastLED[3].setLeds(leds4, NUM_LEDS_FAST);

	G_active = NUM_LEDS_FAST;

}

////////////////////////////////////////////////////////////////////////
void SET_SLOW()  // set to display SLOW LEDs
{
	FastLED[0].setLeds(leds1, NUM_LEDS);
	FastLED[1].setLeds(leds2, NUM_LEDS);
	FastLED[2].setLeds(leds3, NUM_LEDS);
	FastLED[3].setLeds(leds4, NUM_LEDS);

	G_active = NUM_LEDS;

}

////////////////////////////////////////////////////////////////////////
void SET_VAR(int num)  // set to display to a variable number of LEDs
{
	FastLED[0].setLeds(leds1, num);
	FastLED[1].setLeds(leds2, num);
	FastLED[2].setLeds(leds3, num);
	FastLED[3].setLeds(leds4, num);

	G_active = num;
	G_first_active_column = NUM_COLUMNS - (num / NUM_ROWS);  // first active column: active columns span from  G_first_active_column to (NUM_COLUMNS -1)
}


/**************************************************************************************************************/
byte HALL_MEASURE2(int num)  // return number of blanks to prevent roll over
{
	unsigned long start_count = 0;
	//unsigned long time_interval = 0; // Note: G_time_interval decreases as rotation speed increases
	byte max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution
	

	//SPACE
	//printD("HALL_MEASURE2: start"), 0);
	//SPACE

	 HALL_SYNC2();  // must first sychronize


	start_count = G_Hall_counts;



	//G_max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution

	if (num < 22) { num = 22; }  // set minimum number of LEDs

	//HALL_SYNC2();
	//start_count = G_Hall_counts;

		unsigned long start_timestamp = millis();


	//if ((G_Hall_sync == 1)&&(not_rotating_flag==0))  // this line causes P1S1 to be skipped!!!!
	if (G_Hall_sync == 1) 
	{
		G_max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution
		
		while ((start_count == G_Hall_counts) && (digitalRead(HEAD_COM) == 0))  // NOTE: next HALL interrupt increments G_Hall_counts
		{
			++G_max_flashes;
			//	SHOW_slow();
			SHOW_var(num);

			if ((millis() - start_timestamp) > 1000)  // this will only be true if head not rotating...added 08/19/24
			{
					SPACE
					printD("HALL_MEASURE2: NOT ROTATING"), 0);
					SPACE
				
				G_max_flashes = 12;   // arbitrary default
				break;

			}
		}
	}
	else  // no hall sync
	{
		G_max_flashes = 12;  // arbitrary default
	}

	//time_interval = millis() - time_interval;

	if (G_max_flashes % 2 != 0)  // make divisible by 2
	{
		--G_max_flashes;

	}

	//float blanks = G_max_flashes * .15;  // note: .2 was emperically determined (it might work less but needs to be greater than .2)... was .15
	int blanks = (G_max_flashes * 150) / 1000;  // note: .2 was emperically determined (it might work less but needs to be greater than .2)... was .15

	if (blanks == 0)
	{
		blanks = 1;   // arbitrairly picked

	}

	//Serial.println(F("++++++++HALL_MEASURE2  ++++++++++ "));
	//Serial.print(F("blanks= "));
	//Serial.println(blanks);
	//Serial.print(F("G_max_flashes= "));
	//Serial.println(G_max_flashes);
	//Serial.println("");

	return byte(blanks);
}

///**************************************************************************************************************/
//byte HALL_MEASURE4(int num)  // return number of blanks to prevent roll over,  ** includes FFT_COMPUTE()  **
//{
//	unsigned long start_count = 0;
//	//unsigned long time_interval = 0; // Note: G_time_interval decreases as rotation speed increases
//	byte max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution
//
//	HALL_SYNC2();
//	start_count = G_Hall_counts;
//
//
//	G_max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution
//
//	if (num < 22) { num = 22; }  // set minimum number of LEDs
//
//	//HALL_SYNC2();
//	//start_count = G_Hall_counts;
//
//
//	if (G_Hall_sync == 1)
//	{
//		while (start_count == G_Hall_counts)  // NOTE: next HALL interrupt increments G_Hall_counts
//		{
//			FFT_COMPUTE();
//			++G_max_flashes;
//			//	SHOW_slow();
//			SHOW_var(num);
//		}
//	}
//
//	//time_interval = millis() - time_interval;
//
//	if (G_max_flashes % 2 != 0)  // make divisible by 2
//	{
//		--G_max_flashes;
//
//	}
//
//	//float blanks = G_max_flashes * .15;  // note: .2 was emperically determined (it might work less but needs to be greater than .2)... was .15
//	int blanks = (G_max_flashes * 150) / 1000;  // note: .2 was emperically determined (it might work less but needs to be greater than .2)... was .15
//
//		Serial.println(F("++++++++HALL_MEASURE4  ++++++++++ "));
//		Serial.print(F("blanks= "));
//		Serial.println(blanks);
//		Serial.print(F("G_max_flashes= "));
//		Serial.println(G_max_flashes);
//		Serial.println("");
//
//	return byte(blanks);
//}




///**************************************************************************************************************/
//float HALL_MEASURE4(int num)  // return amount of time in mills for a single flash
//{
//	unsigned long start_count = 0;
//	float time_interval = 0; // Note: G_time_interval decreases as rotation speed increases
//	byte max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution
//
//	HALL_SYNC2();
//	start_count = G_Hall_counts;
//	time_interval = float(millis()); // measure system time
//
//	G_max_flashes = 0;  // keep track of number of times FastLED.show() can be called in one revolution
//
//	if (num < 22) { num = 22; }  // set minimum number of LEDs
//
//	start_count = G_Hall_counts;
//	//FastLED.clear();
//
//	if (G_Hall_sync == 1)
//	{
//		while (start_count == G_Hall_counts)  // NOTE: next HALL interrupt increments G_Hall_counts
//		{
//			++G_max_flashes;
//			//	SHOW_slow();
//			SHOW_var(num);
//		}
//	}
//
//	time_interval = (float(millis()) - time_interval)/ G_max_flashes;
//
//	//if (G_max_flashes % 2 != 0)  // make divisible by 2
//	//{
//	//	--G_max_flashes;
//
//	//}
//
//	//float blanks = G_max_flashes * .15;  // note: .2 was emperically determined (it might work less but needs to be greater than .2)... was .15
//
//		//Serial.println(F("++++++++HALL_MEASURE2  ++++++++++ "));
//		//Serial.print(F("blanks= "));
//		//Serial.println(blanks);
//		//Serial.print(F("G_max_flashes= "));
//		//Serial.println(G_max_flashes);
//		//Serial.println("");
//
//	return time_interval;
//}


//********************************************************************************
int SHOW_HANDLER(int number_of_shows)  // return the next show number
{
	//Serial.println(F(""));
	//Serial.print(F("$$$$$$$$$ 66: G_dim= "));
	//Serial.println(G_dim);
	//Serial.println(F(""));

	// detect if the BASE is trying to communicate with the HEAD through the A2D port and if YES then execute COME_HITHER_SHOW() until another BASE signal is received
	DETECT_BASE_COMMUNICATION_and_COME_HITHER();
	
	MUSIC_DETECT(MUSIC_DETECTION_INTERVAL, MUSIC_DETECTION_COUNT);  // increase sampling


	// *********************** SHOW handler  ****************************
	static int previous_production = G_production;

	G_number_of_shows = number_of_shows;  // used to display TEXT in GUI4

	if ((G_GUI == 4) && (previous_production != G_production))  // only update if production has changed
	{
		SerialBT.print("*M");  // update GUI4 text for FINAL SHOW
		SerialBT.print(G_number_of_shows);
		SerialBT.print("*");

		previous_production = G_production;

	}

	int show_num = 1;

	if (G_CREATE_mode == 0)
	{
		if (SERIAL_MON == 1)
		{
			//Serial.println("");
			Serial.print(F("---------------------------------------  start SHOW HANDLER   ------ "));
			//Serial.println("");
			//Serial.print(F("G_repeat_show_flag= "));
			//Serial.println(G_repeat_show_flag);
			//Serial.print(F("G_RESET= "));
			//Serial.println(G_RESET);
			Serial.print(F("G_CREATE_mode= "));
			Serial.println(G_CREATE_mode);
			//Serial.print(F("G_interceeded_flag= "));
			//Serial.println(G_interceeded_flag);
			//Serial.print(F("G_next_show_in_series= "));
			//Serial.println(G_next_show_in_series);
			Serial.print(F("G_production= "));
			Serial.println(G_production);
			Serial.print(F("G_forced_show= "));
			Serial.println(G_forced_show);
			Serial.print(F("G_show_num= "));
			Serial.println(G_show_num);
			Serial.println("");
		}
	}

	//DC_CHECK_AND_DO();  // check for DC and execute if DC received


	if ((G_RESET == 0) && (G_forced_show == 0))
	{
		if (G_CREATE_mode == 0)
		{


			if (G_interceeded_flag == 0)
			{
				if (G_repeat_show_flag == 0)
				{
					++G_show_num;
					show_num = G_show_num;

					//Serial.println("");
					//Serial.print(F("incrementing: G_show_num= "));
					//Serial.println(G_show_num);
					//Serial.println("");

				}
				else
				{
					show_num = G_show_num;
				}

			}
			else
			{


				show_num = G_next_show;  // added 10/05/23
				G_show_num = show_num;  // added 10/05/23
			}

			G_interceeded_flag = 0;   // clear the flag

		}
		else  // CREATE mode
		{
			show_num = 0;  // CREATE show number
		}
	}

	/////////////////////////////////////////

	//if ((G_repeat_show_flag == 0) && (G_CREATE_mode == 0))  // prevent blinking between repeat shows
	if ((G_repeat_show_flag == 0) && (G_CREATE_mode == 0) && (G_production != FIRST_SOUND_PRODUCTION) && (G_production != FIRST_SOUND_PRODUCTION + 2))  // prevent blinking between repeat shows except if production =3 
	{
		FastLED.clear();
		SHOW_slow();
	}

	if (G_show_num > number_of_shows)
	{
		G_show_num = 1;
		show_num = 1;


	}

	if (G_show_num < 1)
	{
		G_show_num = 1;
	}

	if (G_CREATE_mode == 1)
	{
		show_num = 0;
	}



	if (G_RESET == 1)
	{
		show_num = 1;
		G_show_num = 1;
		CLEAR_ALL_LEDS();
		SHOW_slow();

		G_RESET = 0;

	}

	if (G_forced_show > 0)  // forced show
	{
		if (G_forced_show <= number_of_shows)
		{
			show_num = G_forced_show;
			G_show_num = G_forced_show;
		}

		//if (G_CREATE_mode == 1)
		//{
		//	show_num = 0; // enter CREATE MODE
		//}
	}


	if (G_forced_show < 0)  // start at forced show then move on
	{
		if (G_show_num < abs(G_forced_show))
		{
			G_show_num = abs(G_forced_show);
			G_forced_show = 0;  // allow to move onto next show next time
		}
		//else
		//{
		////	show_num = G_show_num;
		//}

		show_num = G_show_num;

	}

	if (G_CREATE_mode == 1)
	{
		show_num = 0; // enter CREATE MODE

		SerialBT.print("*I");  // update GUI text
		//SerialBT.print(G_production);
		SerialBT.print("CM");
		SerialBT.print("*");

		SerialBT.print("*!");  // update GUI text
		SerialBT.print(show_num);
		SerialBT.print("*");


	}


	if (G_CREATE_mode == 0)
	{
		MODIFY_GUI4(19);  // update SHOW_NUM
		
		if (SERIAL_MON == 1)
		{
			Serial.print(F("G_CREATE_mode= "));
			Serial.println(G_CREATE_mode);
			Serial.print(F("show_num= "));
			Serial.println(show_num);
			Serial.print(F("G_show_num= "));
			Serial.println(G_show_num);
			Serial.print(F("G_forced_show= "));
			Serial.println(G_forced_show);
			Serial.println(F("==== end SHOW2 HANDLER ==== "));
			Serial.println("");
		}
	}

	G_show_num = show_num;  // added 070924

	return show_num;

	//*******************  END of SHOW HANDLER *******************
}



//////////////////////////////////////////////////////////////////////////
void CAL_SPIN2(int num)  // calibrate the spin rotation to determine the maximum number of STAR FLOAT blanks, num=number of active LEDs
// num=number of active LEDs
{

	if ((G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0))
	{
		Serial.println(F("---->CAL_SPIN2: before HALL_MEASURE2 "));
		HALL_MEASURE2(num);
		G_max_blanks = G_max_flashes;
	}
	else
	{
		G_max_blanks = 2;
	}

}

/////////////////////////////////////////////////////////////////////////
// draw a cirle
void CIRCLE(double radius, double x_center, double y_center, int hue)
//hue=999 for black LED
{
	double x;  // precise x location on circle
	double y;  // precise y location on circle
	double angle = 0;
	byte S = 255;
	byte V = 255- G_dim;  // 0524 was G_dim
	int xq = 0; // quantized x location on circle
	int yq = 0; // quantized y location on circle 
	int xq_prev = 0;  // previous quantized x
	int yq_prev = 0;  // previous quantized y
	int adr = 0;
	int adr_mod = 0;
	byte skip = 0;  // set to 1 to not plot xy pair


	if (hue == 999) // set color to black
	{
		S = 0;
		V = 0;
		hue = 0;
	}

	if (hue == -1)  // white
	{
		S = 0;
		V = 255;
		hue = 0;
	}

	for (double n = 0; n < 360; ++n)
	{
		angle = PI * n / 180;  // convert to radians

		x = x_center + (radius * sin(angle));
		y = y_center + (radius * cos(angle));

		xq = (int)x;
		yq = (int)y;

		//if (xq < 0) {xq = 0;}	
		//if (yq < 0) { yq = 0; }

		if (xq < 0) { skip = 1; }
		if (yq < 0) { skip = 1; }

		if (xq >= NUM_COLUMNS) { xq = NUM_COLUMNS - 1; }
		if (yq >= NUM_ROWS) { yq = NUM_ROWS - 1; }

		if (skip == 0)
		{
			adr = GET_XY_ADR(xq, yq);
			leds1[adr] = CHSV(hue, S, V);
			leds3[adr] = CHSV(hue, S, V);

			adr_mod = modify_adr(0, 0, adr);
			leds2[adr_mod] = CHSV(hue, S, V);
			leds4[adr_mod] = CHSV(hue, S, V);
		}

		skip = 0; // reset flag
	}

}

/**************************************************************************************************************/
int GET_XY_ADR(int x, int y)   // find the address of the LED at the X and Y locations
// note: (0,0)=bottom and inner (closest to center of spin)
// note: GET_LED_ADR(X,Y) 
{
	if (y < 0) { y = 0; }
	if (y >= NUM_ROWS) { y = NUM_ROWS - 1; }
	if (x < 0) { x = 0; }
	if (x >= NUM_COLUMNS) { x = NUM_COLUMNS - 1; }

	int adr = 0; // address of the LED
	int row = NUM_ROWS - y - 1;
	int col = NUM_COLUMNS - x - 1;

	if ((col % 2) == 0)   // even column
	{
		//adr = (col*NUM_LEDS_FAST ) + row;
		adr = (col * (NUM_LEDS_FAST)) + row;
	}
	else  // odd column
	{
		//adr = NUM_LEDS_FAST * (col + 1) - (row + 1);
		adr = (NUM_LEDS_FAST) * (col + 1) - (row + 1);
	}

	return adr;
}


//////////////////////////////////////////////////
void CREATE_MODE()  // this allows for on the fly show creation
{
	//Serial.println("");
	//Serial.print(F("--------->  CREATE MODE start: G_continuous_SPECIAL_mode="));
	//Serial.println(G_continuous_SPECIAL_mode);

	//Serial.print(F("G_CYCLE_SAVES="));
	//Serial.println(G_CYCLE_SAVES);
	//Serial.print(F("G_SAVED[1]="));
	//Serial.println(G_SAVED[1]);
	//Serial.print(F("G_SAVED[2]="));
	//Serial.println(G_SAVED[2]);
	//Serial.print(F("G_SAVED[3]="));
	//Serial.println(G_SAVED[3]);
	//Serial.print(F("G_SAVED[4]="));
	//Serial.println(G_SAVED[4]);
	//Serial.print(F("G_SAVED[5]="));
	//Serial.println(G_SAVED[5]);
	//Serial.println("");


	//	Serial.println("");
	//	Serial.println(F("--------->  CREATE MODE start   <-----------"));
		//Serial.print(F("G_Vroll= "));
		//Serial.println(G_Vroll);
		//Serial.print(F("G_STAR_flag= "));
		//Serial.println(G_STAR_flag);
	//	Serial.print(F("G_hue= "));
	//	Serial.println(G_hue);
	//	Serial.println("");



	int stringSize = 0;


	G_executing_CREATE_mode = 1;  // flag that I'm inside CREATE mode
	G_TIMES_SAVED_IMAGES_SHOWN = 0;  // holds the number of times SAVED images are shown in DO_SHOW

	//G_skip_RESET = 0; //allow for a RESET

	if (G_LOAD_DEFAULT_CREATE_MODE_IMAGE_flag == 1)
	{
		//		MODIFY_GUI3(2);  // turn on CREATE mode switch



		MODIFY_GUI2(2);  // turn on CREATE mode switch



		G_LOAD_DEFAULT_CREATE_MODE_IMAGE_flag = 0;  // reset flag so default image is only loaded once

		//FastLED.clear();
		CLEAR_ALL_LEDS();
		SHOW_slow();

		strcpy(scroll_text_array, "CREATE MODE");
		stringSize = strlen(scroll_text_array);

		G_BLOCK_BT_CHECK = 1;  // when set to 1 CHECK_BLUE_TOOTH() is skipped, this is necessary to guarantee CREATE MODE is displayed if mouse pad is used
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 0, 2, 0);
		G_BLOCK_BT_CHECK = 0;  // when set to 1 CHECK_BLUE_TOOTH() is skipped

		TURN_OFF_PLAY_SAVES_MODE();

		// ***********  CREATE mode default image  ***********
		CIRCLE(8, 0, 11, 171);  // generate a BLUE sphere in center
		LINE(0, 11, 11, 0, 0); // generate a RED line

		//G_hue = 0;  // default is RED

		SHOW_slow();

	}


	if (G_PLAY_SAVES_MODE_ON == 1)
	{
		PLAY_SAVES_SHOW(1);  // generate a production from the SAVES
	}


	if (G_CYCLE > maximum_number_of_SAVED_images) { G_CYCLE = 0; } // keep track of how many times CREATE_MODE executed
	++G_CYCLE;

	if (G_CYCLE_SAVES == 1) // cycle save mode for GUI1
	{
		int dly = G_SPEED_slider * 100;

		if (G_SAVED[G_CYCLE] > 0)
		{
			LOAD_SAVE(G_CYCLE);
			SHOW_slow();
			BT_DELAY(dly);
		}

	}


	if (G_GEN == 1)  // GEN button pressed on GUI, need to draw random LEDs
	{
		//G_EFFECT_slider = 1;   //************* FOR TEST ONLY delete it

		if (G_CONT_GEN == 0)  // CONT_GEN switch is OFF
		{
			G_GEN = 0;  // clear the button press
		}

		if (G_KEEP == 1)
		{

			SAVE_BACKGROUND();

			G_KEEP = 0;  // clear flag

		}
		else
		{
			LOAD_BACKGROUND();  // restore background	

			for (int n = 0; n < G_num2UNDO; ++n)  // clear UNDO data from the stack
			{
				// since we aren't using UNDO to undo the last G_GEN (I'm loading it) but because DRAW_in_CREATE() puts stuff on the STACK, I need to take stuff off STACK
				UNDO(1);  // this clears the stack but doesn't change LEDs...I'm not sure I need to do this STACK clean up

			}

			G_num2UNDO = 0;

		}


		for (int n = 0; n < G_EFFECT_slider; ++n)  // sets the number of things drawn
		{
			G_X = random(0, NUM_COLUMNS - 1);
			G_Y = random(0, NUM_ROWS - 1);

			if (G_geometery != 2)  // not a circle
			{
				G_X_previous = random(0, NUM_COLUMNS - 1);
				G_Y_previous = random(0, NUM_ROWS - 1);
			}
			else  // chose a maximum radius for a circle
			{
				int radius = random(7);  // sets maximum radius
				int next_x = G_X + radius;

				if (next_x >= NUM_COLUMNS)
				{
					next_x = abs(G_X - radius);
				}
				G_X_previous = next_x;
				G_Y_previous = G_Y;

			}

			/*if (G_RAND_HUE == 1)
			{
				G_hue = random(0, 213);
			}*/

			G_end_flag = 1;
			DRAW_in_CREATE();  // draw dots, lines, rectangles or circles
			SHOW_slow();

			G_num2UNDO = G_EFFECT_slider;
		}

		//		Serial.println(F("CREATE MODE: before DUMP"));
		//		DUMP_LED_ARRAY(leds1, NUM_LEDS);

	}



	if ((G_Xbounce == 1) || (G_Xbounce == 2))
	{
		//SET_BOUNCE_ARRAY(1);
		BOUNCE_X(2, 11, 0);
		SHOW_slow();
	}



	if (G_Ybounce == 1)
	{
		//SET_BOUNCE_ARRAY(1);
		BOUNCE_Y(2, 11, 0);
		SHOW_slow();
	}

	if (G_Vroll == 1)
	{
		ROLL_VERT(G_EFFECT_slider);
		SHOW_slow();
	}

	if (G_Hroll == 1)
	{
		ROLL_HOZ(G_EFFECT_slider);
		SHOW_slow();
	}

	if (G_STAR_flag == 1)  // STAR mode
	{
		STAR(15, G_EFFECT_slider);
	}


	if (G_rotate_color == 1)
	{
		//int dly = G_SPEED_slider * 100;

		//ROTATE_COLOR_SHOW(dly, 1, 3);
		//ROTATE_COLOR_SHOW(1, 1, 1);
		ROTATE_COLORS(1);
		SHOW_slow();
	}

	if (G_hue_cycle_vert == 1)
	{
		//Serial.println("");
		//Serial.println(F("CREATE MODE: before HUE_CYCLE"));
		//Serial.println("");

		HUE_CYCLE_VERT(0, G_EFFECT_slider, 0);  // change the colors each time 
		SHOW_slow();
	}

	if (G_hue_cycle_hoz == 1)
	{
		HUE_CYCLE_HOZ(0, G_EFFECT_slider, 0);  // change the colors each time 
		SHOW_slow();
	}

	if (G_cycle_XYflipInvert_mode == 1)
	{
		int dly = G_SPEED_slider * 100;

		FLIP_DISPLAY();
		SHOW_slow();
		BT_DELAY(dly);


		XY_SWAP();
		SHOW_slow();
		BT_DELAY(dly);

		SIDE_FLIP_DISPLAY();
		SHOW_slow();
		BT_DELAY(dly);

		FLIP_MID_HOZ();
		SHOW_slow();
		BT_DELAY(dly);

		FLIP_MID_VERT();
		SHOW_slow();
		BT_DELAY(dly);

		FLIP_SQUARE_HOZ();
		SHOW_slow();
		BT_DELAY(dly);

		FLIP_SQUARE_VERT();
		SHOW_slow();
		BT_DELAY(dly);

	}

	if (G_TRANS_SWITCH == 1)  // in GUI2 
	{

		DO_TRANSFORMATION(G_transformation);

		SHOW_slow();
		BT_DELAY(G_SPEED_slider * 100);
	}



	if (G_CYCLE_BUTTON_pressed == 1) // only execute generator once if pressed
	{
		G_CYCLE_BUTTON_pressed = 0;

		G_Vroll = 0;
		G_Hroll = 0;
		G_STAR_flag = 0;
		G_cycle_XYflipInvert_mode = 0;
		G_CONT_GEN = 0;


	}

	if (G_COLOR_CYCLE_BUTTON_pressed == 1)
	{
		G_COLOR_CYCLE_BUTTON_pressed = 0;

		G_rotate_color = 0;
		G_hue_cycle_vert = 0;

	}




	int dly = G_SPEED_slider * 50;
	BT_DELAY(dly);
	//BT_DELAY(100);

	if (G_continuous_SPECIAL_mode == 1)
	{
		//TRANSFER2_FAST(255);

		G_show_num = 255;
	}


	/////////////  end of CREATE_MODE  ////////////////
	G_executing_CREATE_mode = 0;

	if (G_GUI == 3)  // restore the default effect slider setting
	{
		//NOTE: I commented out the below line on Nov. 1 because 8way STAR mode was not getting correct G_EFFECT_slider setting I desired because the below line reset its value. 
		//      I don't know the effect removing the below line has on other things....I need to investiate

		//		G_EFFECT_slider = G_EFFECT_slider_default;
	}


}


//********************************************************************************
void DC_DELAY(int dly)  // check DC and insert a delay
{
	DC_CHECK_AND_DO();  // check for DC and execute if DC received
	if ((G_CREATE_mode == 0) || (G_executing_CREATE_mode == 1))
	{
		if (G_RESET == 0)
		{
			delay(dly);
		}
	}
	DC_CHECK_AND_DO();  // check for DC and execute if DC received
}

//********************************************************************************
byte BT_DELAY(int dly)  // check bluetooth and insert a delay; return a 1 if a BT message received during delay, also execute the BT command if there is one
{
	int min_delay = 50;  // sets the minimum amount of time between two checks for BT message
	int delay_increments = int(dly / min_delay);
	unsigned long start = millis();

	int delta = dly - (min_delay * delay_increments);

	if (delta > 0)  // add in small increments of delay
	{
		delay(delta);
	}

	G_BT_message_flag = CHECK_BLUE_TOOTH();

	if (G_BT_message_flag == 1)
	{
		BLUE_TOOTH_COMMAND_HANDLER(1);

		return 1;
	}

	//Serial.println("++++++++ G_RESET +++++++++++++");
	//Serial.println( G_RESET);

	if ((G_CREATE_mode == 0) || (G_executing_CREATE_mode == 1))
	{
		if (G_RESET == 0)
		{
			if (delay_increments > 0)
			{
				for (int n = 0; n < delay_increments; ++n)
				{
					delay(min_delay);



					G_BT_message_flag = CHECK_BLUE_TOOTH();
					//	G_BT_data_arrival = G_BT_message_flag;   // commented out on 11/29/21

					if (G_BT_message_flag != 0)
					{
						BLUE_TOOTH_COMMAND_HANDLER(1);
						return 1;
					}
				}
			}
			else
			{
				delay(dly);
			}
		}
	}

	//G_BT_message_flag = CHECK_BLUE_TOOTH();
	//if (G_BT_message_flag == 1)
	//{
	//	BLUE_TOOTH_COMMAND_HANDLER(1);
	//}

	/*Serial.println("");
	Serial.println("++++++++ TIME +++++++++++++");
	Serial.println(millis() - start);
	Serial.println("");*/

	return 0;
}


////********************************************************************************
// below is a known working version
//byte BT_DELAY(int dly)  // check bluetooth and insert a delay
//{
//	G_BT_message_flag = CHECK_BLUE_TOOTH();
//
//
//	if (G_BT_message_flag == 1)
//	{
//		BLUE_TOOTH_COMMAND_HANDLER(1);
//	}
//
//	if ((G_CREATE_mode == 0) || (G_executing_CREATE_mode == 1))
//	{
//		if (G_RESET == 0)
//		{
//			delay(dly);
//		}
//	}
//
//	G_BT_message_flag = CHECK_BLUE_TOOTH();
//	if (G_BT_message_flag == 1)
//	{
//		BLUE_TOOTH_COMMAND_HANDLER(1);
//	}
//	
//	
//	return 0;
//}



////////////////////////////////////////////////////////////////////////
void CLEAR_FAST_LEDS()
{
	SET_FAST();

	for (int n = 0; n < NUM_LEDS_FAST; ++n)  // these aren't LEDs but are virtual LEDs as they get copied into LEDS1..4
	{
		fast_leds1[n] = 0;
		fast_leds2[n] = 0;
		fast_leds3[n] = 0;
		fast_leds4[n] = 0;
	}

	FastLED.clear();  // clear outter

}

////////////////////////////////////////////////////////////////////////
void CLEAR_ALL_LEDS()
{
	SET_SLOW();
	for (int n = 0; n < NUM_LEDS_FAST; ++n)  // these aren't LEDs but are virtual LEDs as they get copied into LEDS1..4
	{
		fast_leds1[n] = 0;
		fast_leds2[n] = 0;
		fast_leds3[n] = 0;
		fast_leds4[n] = 0;
	}

	FastLED.clear();  // clear interior image

}


////////////////////////////////////////////////////////////////////////
void CLEAR_VAR_LEDS(int num) // clear only the number of LEDs supplied = num
{

	SET_VAR(num);

	for (int n = 0; n < num; ++n)
	{
		leds1[n] = 0;
		leds2[n] = 0;
		leds3[n] = 0;
		leds4[n] = 0;
	}

	FastLED.clear();

}



////////////////////updated 052921////////////////////////////////////////
void STAR_FLOAT(int ntf, int float_time, int rep, unsigned long blanks, int num_leds)
// float an image: ntf=number of consecutive bitmaps to float, 
// float_time= number of HALL counts to float image,  
//rep=how many times to repeat the same frame,
// blanks = number of frames before all blanks are displayed : larger number will have more LEDs lit per revolution
// num_leds=number of LEDs to activate for the display
// note: rot=125 = 360 degrees at normal speed
{

	if ((G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0) && ((G_CREATE_mode == 0) || G_executing_CREATE_mode == 1)) // only allow star float if HALL is active
	{

		/////////////////////////  for test only  ?????????????
		/*CLEAR_ALL_LEDS();
		SHOW_slow();

		LOAD_BMP(G_bmp_num);
		SHOW_var(num_leds);

		CLEAR_VAR_LEDS(num_leds);
		SHOW_var(num_leds);

		LOAD_BMP(G_bmp_num);
		SHOW_var(num_leds);
		SHOW_var(num_leds);



		return;*/
		////////////////////////////////////////////////////////





		//if ((G_cal_star_float % 10) == 0)  // prevent blinking by limiting number of times CAL_SPIN2() is called  // prevent blinking by limiting number of times CAL_SPIN2() is called
		//{
		//	CAL_SPIN2(num_leds);  // find the maximum number of blanks for STAR FLOAT ... prevents flashing
		//}
		//++G_cal_star_float;

		G_max_blanks = CALCULATED_MAX_FLASHES(num_leds);  // returns calculate G_max_flashes based on number of LEDs

		//int float_time = 20;  // how many revolutions to float image

		//noInterrupts();
//		G_Hall_counts = 0;
		//interrupts();

		//unsigned long blanks_interval = 195/ 6;   // nominal value in mills
		//G_max_blanks = HALL_MEASURE()/ blanks_interval;  // calculate the maximum number of blanks before blinking occurs

		if (blanks > G_max_blanks - 3) { blanks = G_max_blanks - 3; }  // prevent blinking if too many blanks are called for

		//blanks = 6;

		CLEAR_ALL_LEDS();

		SHOW_slow();

		unsigned long ft = READ_HALL_COUNTS() + float_time;




		while (READ_HALL_COUNTS() < ft)
		{



			for (int kk = 0; kk < blanks; ++kk)   // this determines how many blanks between images
			{

				for (int i = 0; i < ntf; ++i)
				{
					LOAD_BMP(G_bmp_num + i);

					for (int g = 0; g < rep; ++g)
					{

						SHOW_var(num_leds);

					}
				}

				//CLEAR_ALL_LEDS();

				CLEAR_VAR_LEDS(num_leds);

				SHOW_var(num_leds);

			}


			CLEAR_ALL_LEDS();

			SHOW_var(num_leds);



		}
	}

}

/////////////////////////////////////////////////////////////

// BACKUP
//void STAR_FLOAT(int ntf, int float_time, int rep, unsigned long blanks)
//// float an image: ntf=number of consecutive bitmaps to float, 
//// float_time= number of HALL counts to float image,  
////rep=how many times to repeat the same frame,
//// blanks = number of frames before all blanks are displayed : larger number will have more LEDs lit per revolution
//// note: rot=125 = 360 degrees at normal speed
//{
//
//	if ((G_Hall_sync == 1) && ((G_CREATE_mode == 0) || G_executing_CREATE_mode == 1)) // only allow star float if HALL is active
//	{
//
//		if ((G_cal_star_float % 10) == 0)  // prevent blinking by limiting number of times CAL_SPIN2() is called  // prevent blinking by limiting number of times CAL_SPIN2() is called
//		{
//			CAL_SPIN2(NUM_LEDS);  // find the maximum number of blanks for STAR FLOAT ... prevents flashing
//		}
//		++G_cal_star_float;
//
//
//		//int float_time = 20;  // how many revolutions to float image
//
//		//noInterrupts();
//		G_Hall_counts = 0;
//		//interrupts();
//
//		//unsigned long blanks_interval = 195/ 6;   // nominal value in mills
//		//G_max_blanks = HALL_MEASURE()/ blanks_interval;  // calculate the maximum number of blanks before blinking occurs
//
//		if (blanks > G_max_blanks - 3) { blanks = G_max_blanks - 3; }  // prevent blinking if too many blanks are called for
//
//		//blanks = 6;
//
//		CLEAR_ALL_LEDS();
//
//		SHOW_slow();
//
//		int ft = READ_HALL_COUNTS() + float_time;
//
//
//
//		//while (READ_HALL_COUNTS() < float_time)
//		while (READ_HALL_COUNTS() < ft)
//		{
//
//			//HALL_SYNC2();
//
//			for (int kk = 0; kk < blanks; ++kk)   // this determines how many blanks between images
//			{
//
//				for (int i = 0; i < ntf; ++i)
//				{
//					LOAD_BMP(G_bmp_num + i);
//
//					for (int g = 0; g < rep; ++g)
//					{
//
//						SHOW_slow();
//
//					}
//				}
//
//				CLEAR_ALL_LEDS();
//
//				SHOW_slow();
//
//			}
//
//
//			CLEAR_ALL_LEDS();
//
//			SHOW_slow();
//
//
//
//		}
//	}
//
//}

////******************************************************************************************
void LINE(int xs, int ys, int xe, int ye, int hue)  // draw a line from (xs,ys) to (xe,ye) with color,  erase line with color 999
{
	// erase line with color 999

	if ((xs == xe) && (ys == ye)) { return; }

	int adr;
	int adr2;
	byte S = 255;
	byte V = 255-G_dim ;  //0524  previously G_dim
	byte vert_line_flag = 0;  // this is set to 1 if a vertical line is drawn

	if (hue == 999) // set color to black
	{
		S = 0;
		V = 0;
		hue = 0;
	}

	if (hue == -1)  // white
	{
		S = 0;
		V = 255;
		hue = 0;
	}

	//Serial.println(F("++++++++++++ LINE MODE"));
	//Serial.print(F("hue="));
	//Serial.println(hue);
	//Serial.println(F(""));

	if (xs >= NUM_COLUMNS) { xs = NUM_COLUMNS - 1; }
	if (xe >= NUM_COLUMNS) { xe = NUM_COLUMNS - 1; }
	if (ys >= NUM_ROWS) { ys = NUM_ROWS - 1; }
	if (ye >= NUM_ROWS) { ye = NUM_ROWS - 1; }

	if (xs < 0) { xs = 0; }
	if (xe < 0) { xe = 0; }
	if (ys < 0) { ys = 0; }
	if (ye < 0) { ye = 0; }


	if (xs > xe)
	{
		int temp_x = xs;
		int temp_y = ys;

		xs = xe;
		ys = ye;

		xe = temp_x;
		ye = temp_y;
	}

	if ((xe == xs) && ((ye == ys)))   // if same point light it
	{
		int adr3 = XY_ADR(xs, ys);
		leds1[adr3] = CHSV(hue, S, V);  // 
		leds3[adr3] = CHSV(hue, S, V);  // 

		adr2 = modify_adr(0, 0, adr3);   //make image right side up or upside down
		leds2[adr2] = CHSV(hue, S, V);  // 
		leds4[adr2] = CHSV(hue, S, V);  // / 
	}
	else
	{

		float xs_f = float(xs);  // convert to floating
		float ys_f = float(ys);  // convert to floating
		float xe_f = float(xe);  // convert to floating
		float ye_f = float(ye);  // convert to floating
		float a = 1;

		int y;
		float yf;

		if ((xs_f - xe_f) != 0)  // guard against division by 0
		{
			a = ((ys_f - ye_f) / (xs_f - xe_f));     // calculate slope
		}
		else
		{
			a = 10000;
			vert_line_flag = 1; // draw a vertical line
		}

		float b = (ys_f - (xs_f * a));   // calculate intercept

		if (vert_line_flag == 0)
		{
			for (int x = xs; x <= xe; ++x)
			{
				yf = (a * float(x)) + b;
				y = ((int)(yf + .5));   // re-cast and round up

				if (y >= NUM_ROWS)
				{
					y = NUM_ROWS - 1;
				}

				adr = XY_ADR(x, y);
				leds1[adr] = CHSV(hue, S, V);  // 
				leds3[adr] = CHSV(hue, S, V);  // 


				adr2 = modify_adr(0, 0, adr);   //make image right side up or upside down
				leds2[adr2] = CHSV(hue, S, V);
				leds4[adr2] = CHSV(hue, S, V);

				//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
				/*if (x == xe)
				{
					Serial.println("DRAW_LINE");

					Serial.print("xs_f=");
					Serial.println(xs_f);
					Serial.print("xe_f=");
					Serial.println(xe_f);

					Serial.print("ys_f=");
					Serial.println(ys_f);
					Serial.print("ye_f=");
					Serial.println(ye_f);

					Serial.print("adr=");
					Serial.println(adr);
					Serial.print("x=");
					Serial.println(x);
					Serial.print("y=");
					Serial.println(y);
					Serial.print("yf=");
					Serial.println(yf);
					Serial.print("a=");
					Serial.println(a);
					Serial.print("b=");
					Serial.println(b);
					Serial.println("  ");
				}*/
				//&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&




				///// fill in Y blanks
				if (x > xs)  // fill in y if current y exceeds previous y by more than 1
				{
					yf = (a * float(x - 1)) + b;
					int y_previous = ((int)(yf + .5));   // re-cast and round up

					//if (y_previous >= NUM_ROWS) { y_previous = NUM_ROWS - 1; }
					//if (y_previous < 0) { y_previous = 0; }

					if ((abs(y_previous - y)) > 1)  // need to fill in y's 
					{
						byte y_s = 0;
						byte y_e = 0;

						if (y_previous > y)
						{
							y_s = y;
							y_e = y_previous;
						}
						else
						{
							y_s = y_previous;
							y_e = y;
						}

						for (byte yi = y_s + 1; yi < y_e; ++yi)
						{
							adr = GET_XY_ADR(x, yi);
							leds1[adr] = CHSV(hue, S, V);
							leds3[adr] = CHSV(hue, S, V);

							adr2 = modify_adr(0, 0, adr);
							leds2[adr2] = CHSV(hue, S, V);
							leds4[adr2] = CHSV(hue, S, V);
						}
					}

				}







			}
		}

		if (vert_line_flag == 1) // draw a vertical line
		{
			if (ys > ye)
			{
				int temp_y = ys;

				ys = ye;
				ye = temp_y;
			}


			for (int y = ys; y <= ye; ++y)
			{

				adr = XY_ADR(xs, y);
				leds1[adr] = CHSV(hue, S, V);  // 
				leds3[adr] = CHSV(hue, S, V);  // 


				adr2 = modify_adr(0, 0, adr);   //make image right side up or upside down
				leds2[adr2] = CHSV(hue, S, V);
				leds4[adr2] = CHSV(hue, S, V);
			}

		}
	}


}

/////////////////////////////////////////////////////////////////////////
// cycle the HUE of all ON LEDs each time function is called
void HUE_CYCLE_VERT(byte start_hue, byte hue_increment, byte start_over_flag)
{
	// start_hue=starting color
	// hue_increment=how many colors to skip between cycles
	// start_over_flag=set to 1 to re-start cycling hue from the start_hue color...otherwise continue cycling the colors
	// start_over_flag=2 for random starting hue


	byte hue = 0;
	int adr = 0; // led address
	int adr_mod = 0;


	if (start_over_flag == 1)
	{
		hue = start_hue;
	}

	if (start_over_flag == 0)
	{
		hue = G_hue_cycle;
	}

	if (start_over_flag == 2)
	{
		hue = random(0, 255);
	}


	// sweep a row in search of an ON LED
	for (int row = 0; row < NUM_ROWS; ++row)
	{
		hue = hue + hue_increment;

		if (hue > 255)
		{
			hue = 0;
		}

		G_hue_cycle = hue;

		for (int column = 0; column < NUM_COLUMNS; ++column)
		{
			adr = GET_LED_ADR(row, column);

			// Test if a color is lit at all (versus pure black)
			if ((leds1[adr]) && (G_panel1_on == 1))
			{
				leds1[adr] = CHSV(hue, 255, 255);
			}

			if ((leds3[adr]) && (G_panel3_on == 1))
			{
				leds3[adr] = CHSV(hue, 255, 255);
			}

			adr_mod = modify_adr(0, 0, adr);

			if ((leds2[adr_mod]) && (G_panel2_on == 1))
			{
				leds2[adr_mod] = CHSV(hue, 255, 255);
			}

			if ((leds4[adr_mod]) && (G_panel4_on == 1))
			{
				leds4[adr_mod] = CHSV(hue, 255, 255);
			}



		}
	}

}

/////////////////////////////////////////////////////////////////////////
// cycle the HUE of all ON LEDs each time function is called
void HUE_CYCLE_HOZ(byte start_hue, byte hue_increment, byte start_over_flag)
{
	// start_hue=starting color
	// hue_increment=how many colors to skip between cycles
	// start_over_flag=set to 1 to re-start cycling hue from the start_hue color...otherwise continue cycling the colors
	// start_over_flag=2 for random starting hue


	byte hue = 0;
	int adr = 0; // led address
	int adr_mod = 0;


	if (start_over_flag == 1)
	{
		hue = start_hue;
	}

	if (start_over_flag == 0)
	{
		hue = G_hue_cycle;
	}

	if (start_over_flag == 2)
	{
		hue = random(0, 255);
	}


	// sweep a row in search of an ON LED
	//for (int row = 0; row < NUM_ROWS; ++row)
	for (int column = 0; column < NUM_COLUMNS; ++column)
	{
		hue = hue + hue_increment;

		if (hue > 255)
		{
			hue = 0;
		}

		G_hue_cycle = hue;

		//for (int column = 0; column < NUM_COLUMNS; ++column)
		for (int row = 0; row < NUM_ROWS; ++row)
		{
			adr = GET_LED_ADR(row, column);

			// Test if a color is lit at all (versus pure black)
			if ((leds1[adr]) && (G_panel1_on == 1))
			{
				leds1[adr] = CHSV(hue, 255, 255);
			}

			if ((leds3[adr]) && (G_panel3_on == 1))
			{
				leds3[adr] = CHSV(hue, 255, 255);
			}

			adr_mod = modify_adr(0, 0, adr);

			if ((leds2[adr_mod]) && (G_panel2_on == 1))
			{
				leds2[adr_mod] = CHSV(hue, 255, 255);
			}

			if ((leds4[adr_mod]) && (G_panel4_on == 1))
			{
				leds4[adr_mod] = CHSV(hue, 255, 255);
			}



		}
	}

}

////******************************************************************************************
int XY_ADR(int x, int y)  // return the address of the LED given it's X and Y coordinates: (0,0)=lower left as in Cartiasian coordinates
{

	int ADR;   // LED address

	x = NUM_LEDS_PER_ROW - (x + 1);  // move the 0 point
	y = (NUM_LEDS / NUM_LEDS_PER_ROW) - (y + 1);  // move the 0 point

	ADR = GET_LED_ADR(y, x);

	return ADR;

}

/////////////////////////////////////////////////////////////////////////
// draw a cirle OR'd with existing data
void SPHERE(int radius, int x_center, int y_center, int hue)
// note use CIRCLE as this function makes funky circles some times
//hue=999 for black LED
// hue=-1 for WHITE
{
	// calculate Y as I sweep X
	int yp = 0.0;
	int yn = 0.0;
	int yp_previous = 0;
	int yn_previous = 0;
	int adr = 0;
	int adr_mod = 0;
	int radius_sqrd = 0;
	byte skip_flag = 0; // set to 1 to prevent LED lighting at top edge of circle
	byte S = 255;
	byte V = 255;

	//x_center = x_center + NUM_COLUMNS;  // need to move origin to the center of rotation

	if (hue == 999) // set color to black
	{
		S = 0;
		V = 0;
		hue = 0;
	}


	if (radius > NUM_COLUMNS) { radius = NUM_COLUMNS - 1; }

	radius_sqrd = radius * radius;

	for (byte x = 0; x <= radius; ++x)
	{
		skip_flag = 0;

		yp = y_center + (.5 + sqrt(radius_sqrd - ((x - x_center) * (x - x_center))));  // circle equation solved for y
		yn = y_center - (.5 + sqrt(radius_sqrd - ((x - x_center) * (x - x_center))));

		// guards
		if (yn < 0) { yn = 0; skip_flag = 1; }
		if (yp < 0) { yp = 0; skip_flag = 1; }
		if (yp >= NUM_ROWS) { yp = NUM_ROWS - 1;  skip_flag = 1; }
		if (yn >= NUM_ROWS) { yn = NUM_ROWS - 1; skip_flag = 1; }



		if (skip_flag == 0)
		{


			adr = GET_XY_ADR(x, yp);
			adr_mod = modify_adr(0, 0, adr);

			if (hue > -1)  // not white
			{
				leds1[adr] = CHSV(hue, S, V);
				leds3[adr] = CHSV(hue, S, V);


				leds2[adr_mod] = CHSV(hue, S, V);
				leds4[adr_mod] = CHSV(hue, S, V);
			}
			else  // white
			{
				leds1[adr] = CHSV(0, 0, 255);
				leds3[adr] = CHSV(0, 0, 255);


				leds2[adr_mod] = CHSV(0, 0, 255);
				leds4[adr_mod] = CHSV(0, 0, 255);
			}


			if (((yp_previous - yp) > 1) && (x > 0))  //check if yp jumps more than 1 row
			{
				for (int y = yp + 1; y < yp_previous; ++y)  // add verticle LEDs to fill in the blanks
				{
					adr = GET_XY_ADR(x, y);
					adr_mod = modify_adr(0, 0, adr);


					if (hue > -1)  // not white
					{
						leds1[adr] = CHSV(hue, S, V);
						leds3[adr] = CHSV(hue, S, V);


						leds2[adr_mod] = CHSV(hue, S, V);
						leds4[adr_mod] = CHSV(hue, S, V);
					}
					else  // white
					{
						leds1[adr] = CHSV(0, 0, 255);
						leds3[adr] = CHSV(0, 0, 255);


						leds2[adr_mod] = CHSV(0, 0, 255);
						leds4[adr_mod] = CHSV(0, 0, 255);
					}
				}
			}



			/////////////////////////////////// now do the same for the negative half circle

			adr = GET_XY_ADR(x, yn);
			adr_mod = modify_adr(0, 0, adr);

			if (hue > -1)  // not white
			{
				leds1[adr] = CHSV(hue, S, V);
				leds3[adr] = CHSV(hue, S, V);


				leds2[adr_mod] = CHSV(hue, S, V);
				leds4[adr_mod] = CHSV(hue, S, V);
			}
			else  // white
			{
				leds1[adr] = CHSV(0, 0, 255);
				leds3[adr] = CHSV(0, 0, 255);


				leds2[adr_mod] = CHSV(0, 0, 255);
				leds4[adr_mod] = CHSV(0, 0, 255);
			}

			//if (((yp_previous - yp) > 1) && (x > 0))  //check if yp jumps more than 1 row
			if (((yn - yn_previous) > 1) && (x > 0))  //check if yp jumps more than 1 row
			{
				for (int y = yn_previous + 1; y < yn; ++y)  // add verticle LEDs to fill in the blanks
				{
					adr = GET_XY_ADR(x, y);
					adr_mod = modify_adr(0, 0, adr);

					if (hue > -1)  // not white
					{
						leds1[adr] = CHSV(hue, S, V);
						leds3[adr] = CHSV(hue, S, V);


						leds2[adr_mod] = CHSV(hue, S, V);
						leds4[adr_mod] = CHSV(hue, S, V);
					}
					else  // white
					{
						leds1[adr] = CHSV(0, 0, 255);
						leds3[adr] = CHSV(0, 0, 255);


						leds2[adr_mod] = CHSV(0, 0, 255);
						leds4[adr_mod] = CHSV(0, 0, 255);
					}
				}
			}


		}
		else
		{
			adr = GET_XY_ADR(x, yp);
			leds1[adr] = 0;
			leds3[adr] = 0;

			adr_mod = modify_adr(0, 0, adr);
			leds2[adr_mod] = 0;
			leds4[adr_mod] = 0;

			//

			adr = GET_XY_ADR(x, yn);

			leds1[adr] = 0;
			leds3[adr] = 0;

			adr_mod = modify_adr(0, 0, adr);
			leds2[adr_mod] = 0;
			leds4[adr_mod] = 0;
		}

		yp_previous = yp;
		yn_previous = yn;
	}


}

//********************************************************************************************************************************************
void LOAD_SHOW_BMP(int bmp)   // load a bitmap then show it
{
	if (G_CREATE_mode == 0)
	{
		LOAD_BMP(bmp);
		SHOW_slow();
	}

}

/////////////////////////////////////////////////////////////////////
void PLAY_SAVES_SHOW(byte reset_when_done)  // continue playing show of SAVED images as long as G_PLAY_SAVES_MODE_ON=1
// if reset_when_done =1 then after PLAY_SAVES_SHOW completes all play_saves_count's ... do a RESET()
{

#define MAXIMUM_TIME_IN_PSS 2*60000   // 2 minuets

	byte bt = 0;

	int forced_show_number = 0;  // for debugging, if other than 0 the SHOW will only play the forced_show_number
	int duration = PLAY_SAVES_SHOW_REPEATS;  // sets how many times to cycle through PLAY SAVES SHOW before going back to normal DO_SHOW (with a RESET)

	int number_of_shows = 10;  // sets the maximum number of SHOWs
	//int image_num = 1;  // which saved image to process
	int show_num = 0;
	int next_show_num = 1;
	int cycle = 0;  // keeps track of how many times we pass through WHILE loop
	int play_saves_count = 0;  //keeps track of how many times we cycle through all the PLAY SAVES shows
	int stringSize = 0;
	byte exit_while = 0;  // set to 1 to exit while loop
	unsigned long PS_start_time_stamp = millis();  // starting time of PLAY_SAVES_SHOW()



	FastLED.clear();
	SHOW_slow();

	if (G_exit_PLAY_SAVES_MODE == 0)  // only display below text if coming from GUI
	{
		G_special_char_select = 1;
		strcpy(scroll_text_array, "ENJOY YOUR SHOW");
		stringSize = strlen(scroll_text_array);
		SCROLL_TEXT(scroll_text_array, stringSize, 1, 2, -1, 0, 0, 2, 0);
	}

	LOAD_NEXT_SAVED_IMAGE(1);  // load first valid save image for next SHOW
	SHOW_slow();

	Serial.println("");
	Serial.println(F("PLAY_SAVES_SHOW  START"));
	Serial.println("");



	//while ((G_PLAY_SAVES_MODE_ON == 1) && (play_saves_count < duration) && (G_Hall_sync ==1) && (exit_while==0) && (digitalRead(HEAD_COM) == 0)) // I added G_Hall_sync==1 condition because PLAY_SAVES_SHOW gets stuck if spinning stops 
	//while ((G_PLAY_SAVES_MODE_ON == 1) && (play_saves_count < duration))
	while ((G_PLAY_SAVES_MODE_ON == 1) && (play_saves_count < duration) && (exit_while == 0))
	{
		++cycle;

		if ((millis() - PS_start_time_stamp) > MAXIMUM_TIME_IN_PSS)
		{
			exit_while = 1;
			break;
		}  // exit while loop loop if in PLAY SAVES too long...prevents potential lock up

		DC_CHECK_AND_DO();

		int dly = G_SPEED_slider * 100;
		//int dly = 4 * 100;

		///////////  *********************************  SHOW handler   *********************************** ////////////////////////
		if (show_num == 0)  // show_num=0 is a flag that says advance to next show_num
		{

			show_num = next_show_num;
			++next_show_num;
			cycle = 1;

			Serial.println("");
			Serial.print(F("PLAY_SAVES_SHOW  1: show_num="));
			Serial.println(show_num);
			Serial.print(F("play_saves_count="));
			Serial.println(play_saves_count);
			Serial.println("");


			// detect if the BASE is trying to communicate with the HEAD through the A2D port and if YES then execute COME_HITHER_SHOW() until another BASE signal is received
			//DETECT_BASE_COMMUNICATION_and_COME_HITHER();   // 12/25/23 commented out

			//if (1 == DETECT_BASE_COMMUNICATION2())   // 12/25/23   added
			//{

			//	G_Hall_sync = 0;  // only for COME_HITHER display

			//}
			//else
			//{
			//	G_Hall_sync = G_Hall_sync_original;  // return to original value
			//}

			DETECT_BASE_COMMUNICATION2();  // also changes G_Hall_sync if necessary


			Serial.println("");
			Serial.print(F("PLAY_SAVES_SHOW  1: G_Hall_sync="));
			Serial.println(G_Hall_sync);
			Serial.println("");


			if (G_force_sound_productions != -1)  // execute unless SOUND productions are not allowed
			{
				byte music_detect = MUSIC_DETECT(MUSIC_DETECTION_INTERVAL, MUSIC_DETECTION_COUNT);   // was 50

				if (music_detect > 0)
				{
					Serial.println("");
					Serial.println(F("PLAY_SAVES_SHOW: music_detect>0"));
					Serial.println("");

					exit_while = 1;   // set to 1 to exit while loop

					break;  // exit while loop
				}
			}


		}

		//Serial.println("");
		//Serial.println(F("PSS: test position 1"));

		if (next_show_num > number_of_shows + 1) // this executes at the end of the show
		{
			next_show_num = 1;  // restart the show
			show_num = 1;
			++play_saves_count;

			Serial.println("");
			Serial.print(F("PLAY_SAVES_SHOW  2: play_saves_count="));
			Serial.println(play_saves_count);
			Serial.print(F("G_exit_PLAY_SAVES_MODE="));
			Serial.println(G_exit_PLAY_SAVES_MODE);
			Serial.println("");

			if (G_exit_PLAY_SAVES_MODE == 1)  // set by DO_SHOW to force exit after the PLAY SAVES SHOW
			{
				//G_PLAY_SAVES_MODE_ON = 0;
				TURN_OFF_PLAY_SAVES_MODE();
				exit_while = 1;   // set to 1 to exit while loop
				break; // exit the while loop
			}

		}

		if (forced_show_number > 0)
		{
			show_num = forced_show_number;
			play_saves_count = 0;  // prevent exiting if play_saves_count>duration
		}

		//Serial.println("");
		//Serial.print(F("PSS: test position 2: show_num="));
		//Serial.println(show_num);
		//Serial.println("");

		//////////////////////////////////////////////
		//////////////  SHOW 1 new code //////////////////////
		if (show_num == 1)  // show all saved images in sequence
		{
			SHOW_slow();
			BT_DELAY(dly);

			int cycled_back = LOAD_NEXT_SAVED_IMAGE(0);

			if (cycled_back == 1)
			{
				show_num = 0; // advance to next show flag
			}

			//AUTO_DIM();

			int ringed_image = RETURN_NEXT_SAVED_IMAGE(0); // this finds a new saved image so the TEXT ring is different than the current G_active_PSS_image image

			// display ringed image of saved show
			//DC_OUT_array[0] = 11;
			//DC_OUT_array[1] = G_active_PSS_image; // display a RING from a different leds_saved image
			//DC_SEND();

			//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
			//  ------> The following code shows the saved image to be ringed displayed <----------
				// note: the saved image can also be displayed in DO_SHOW with G_show_num =254
					//int previous_special_char_select = G_special_char_select;
					//G_special_char_select = ringed_image + 1000;  //define image to be displayed	
					//strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");
					//int stringSize = strlen(scroll_text_array);
					//SCROLL_TEXT(scroll_text_array, stringSize, 1, 1, -1, 0, 1);
					//G_special_char_select = previous_special_char_select;

		   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
		   //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

			bt = RING_with_IMAGE(ringed_image, 0, 20, 1, 2, 0);

			if (bt == 1)  // handle BT interrupt
			{
				bt = 0;
				BLUE_TOOTH_COMMAND_HANDLER(1);

			}
		}

		// ^^^^^^ FOR TEST ONLY^^^^^^^^^^^^^^^^^^
		//show_num = 1;  // ^^^^^^ FOR TEST ONLY
		//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


		//////////////  SHOW 1  //////////////////////
		//if (show_num == 1)  // show all saved images in sequence
		//{
		//	if (image_num > maximum_number_of_SAVED_images)
		//	{
		//		image_num = 0;
		//		show_num = 0; // advance to next show flag
		//		LOAD_NEXT_SAVED_IMAGE(1);  // load first valid save image for next SHOW
		//	}

		//	++image_num;

		//	if (G_SAVED[image_num] == 1)
		//	{
		//		LOAD_SAVE(image_num);
		//		SHOW_slow();
		//		BT_DELAY(dly);
		//	}
		//}


		//////////////  SHOW 2  //////////////////////
		if (show_num == 2)  // vertical rolls
		{
			int number_of_cycles_for_this_show = 50; // sets how many times transformation will occur

			DIM_SLOW_LEDS(G_dim); // restore brightness

			/*Serial.println("");
			Serial.println(F("############ PLAY_SAVES_SHOw: show 2 start"));
			Serial.print(F("cycle="));
			Serial.println(cycle);
			Serial.print(F("G_active_PSS_image ="));
			Serial.println(G_active_PSS_image);
			Serial.println("");*/

			if ((G_PLAY_SAVES_MODE_ON == 1) && (G_EFFECT_slider != 1)) // this is needed as G_PLAY_SAVES_MODE_ON can be changed by BT_DELAY
			{
				G_EFFECT_slider = 1; //  set in MASTER with MODIFY_GUI2(5)
				//DC_OUT_array[0] = 7; // change EFFECT slider position
				//DC_OUT_array[1] = G_EFFECT_slider;
				//DC_SEND();

				/*Serial.println(F(" "));
				Serial.println(F("--------->  DCCH: command 7 "));
				Serial.print(F("G_EFFECT_slider= "));
				Serial.println(G_EFFECT_slider);
				Serial.println(F(" "));*/

				//G_EFFECT_slider = DC_IN_array[1];

				if (G_EFFECT_slider != G_EFFECT_slider_previous)
				{
					MODIFY_GUI2(5); // preset EFFECT slider
					G_EFFECT_slider_previous = G_EFFECT_slider;
				}

			}

			if (cycle < number_of_cycles_for_this_show)
			{
				ROLL_VERT(G_EFFECT_slider);
				SHOW_slow();
				//	BT_DELAY(dly);
			}
			else
			{
				cycle = 0;

				byte cycled_back = LOAD_NEXT_SAVED_IMAGE(0);
				SHOW_slow();

				/*Serial.println(F("PLAY_SAVES_SHOw: show 2, cycle=0"));
				Serial.print(F("cycled_back ="));
				Serial.println(cycled_back);
				Serial.println("");*/

				if (cycled_back == 1)  // time for next show
				{
					show_num = 0; // advance to next show flag
				}
			}

		}

		//////////////  SHOW 3  //////////////////////
		if (show_num == 3)  // horizontal roll
		{
			int number_of_cycles_for_this_show = 50; // sets how many times transformation will occur

			/*Serial.println("");
			Serial.println(F("############ PLAY_SAVES_SHOw: show 3 start"));
			Serial.print(F("cycle="));
			Serial.println(cycle);
			Serial.print(F("G_active_PSS_image ="));
			Serial.println(G_active_PSS_image);
			Serial.println("");*/

			if (cycle < number_of_cycles_for_this_show)
			{
				ROLL_HOZ(G_EFFECT_slider);
				SHOW_slow();
				//	BT_DELAY(dly);
			}
			else
			{
				cycle = 0;

				byte cycled_back = LOAD_NEXT_SAVED_IMAGE(0);
				SHOW_slow();

				/*Serial.println(F("PLAY_SAVES_SHOw: show 3, cycle=0"));
				Serial.print(F("cycled_back ="));
				Serial.println(cycled_back);
				Serial.println("");*/

				if (cycled_back == 1)  // time for next show
				{
					show_num = 0; // advance to next show flag
				}
			}

		}

		////////////////////SHOW 4 //////////////////////////////
		if (show_num == 4)  // HUE transformation 2
		{

			int number_of_cycles_for_this_show = 5; // sets how many times transformation will occur

			/*Serial.println("");
			Serial.println(F("############ PLAY_SAVES_SHOw: show 3 start"));
			Serial.print(F("cycle="));
			Serial.println(cycle);
			Serial.print(F("G_active_PSS_image ="));
			Serial.println(G_active_PSS_image);
			Serial.println("");*/

			if (G_EFFECT_slider != 10)
			{
				G_EFFECT_slider = 10; // also set in MASTER with MODIFY_GUI2(5)
				//DC_OUT_array[0] = 7; // change EFFECT slider position
				//DC_OUT_array[1] = G_EFFECT_slider;
				//DC_SEND();

				if (G_EFFECT_slider != G_EFFECT_slider_previous)
				{
					MODIFY_GUI2(5); // preset EFFECT slider
					G_EFFECT_slider_previous = G_EFFECT_slider;
				}
			}

			if (cycle < number_of_cycles_for_this_show)
			{


				DO_COLOR_TRANSFORMATION(2, G_EFFECT_slider);  // vertical HUE cycle
				SHOW_slow();
				BT_DELAY(dly);

				DO_COLOR_TRANSFORMATION(3, G_EFFECT_slider);  // horizontal HUE cycle
				SHOW_slow();
				BT_DELAY(dly);

			}
			else
			{
				cycle = 0;

				byte cycled_back = LOAD_NEXT_SAVED_IMAGE(0);
				SHOW_slow();

				/*Serial.println(F("PLAY_SAVES_SHOw: show 3, cycle=0"));
				Serial.print(F("cycled_back ="));
				Serial.println(cycled_back);
				Serial.println("");*/

				if (cycled_back == 1)  // time for next show
				{
					show_num = 0; // advance to next show flag
				}
			}

		}



		////////////////////SHOW 5 //////////////////////////////
		if (show_num == 5)  // random transformations
		{

			int number_of_cycles_for_this_show = 5; // sets how many times transformation will occur

			/*Serial.println("");
			Serial.println(F("############ PLAY_SAVES_SHOw: show 3 start"));
			Serial.print(F("cycle="));
			Serial.println(cycle);
			Serial.print(F("G_active_PSS_image ="));
			Serial.println(G_active_PSS_image);
			Serial.println("");*/

			if (cycle < number_of_cycles_for_this_show)
			{
				byte transform = random(G_number_of_transformations) + 1;

				DO_TRANSFORMATION(transform);
				SHOW_slow();
				BT_DELAY(dly);

			}
			else
			{
				cycle = 0;

				byte cycled_back = LOAD_NEXT_SAVED_IMAGE(0);
				SHOW_slow();

				/*Serial.println(F("PLAY_SAVES_SHOw: show 3, cycle=0"));
				Serial.print(F("cycled_back ="));
				Serial.println(cycled_back);
				Serial.println("");*/

				if (cycled_back == 1)  // time for next show
				{
					show_num = 0; // advance to next show flag
				}
			}

		}

		////////////////////SHOW 6 //////////////////////////////
		if (show_num == 6)  // color transformation 1
		{

			int number_of_cycles_for_this_show = 5; // sets how many times transformation will occur

			/*Serial.println("");
			Serial.println(F("############ PLAY_SAVES_SHOw: show 3 start"));
			Serial.print(F("cycle="));
			Serial.println(cycle);
			Serial.print(F("G_active_PSS_image ="));
			Serial.println(G_active_PSS_image);
			Serial.println("");*/

			if (cycle < number_of_cycles_for_this_show)
			{


				DO_COLOR_TRANSFORMATION(1, 1);
				SHOW_slow();
				BT_DELAY(dly);

			}
			else
			{
				cycle = 0;

				byte cycled_back = LOAD_NEXT_SAVED_IMAGE(0);
				SHOW_slow();

				/*Serial.println(F("PLAY_SAVES_SHOw: show 3, cycle=0"));
				Serial.print(F("cycled_back ="));
				Serial.println(cycled_back);
				Serial.println("");*/

				if (cycled_back == 1)  // time for next show
				{
					show_num = 0; // advance to next show flag
				}
			}

		}

		////////////////////SHOW 7 //////////////////////////////
		if (show_num == 7)  // STAR mode
		{
			Serial.println("");
			Serial.println("PSS: show 7: start");
			Serial.println("");

			int number_of_cycles_for_this_show = 2; // sets how many times transformation will occur

			/*Serial.println("");
			Serial.println(F("############ PLAY_SAVES_SHOw: show 3 start"));
			Serial.print(F("cycle="));
			Serial.println(cycle);
			Serial.print(F("G_active_PSS_image ="));
			Serial.println(G_active_PSS_image);
			Serial.println("");*/

			if (cycle < number_of_cycles_for_this_show)
			{



				//STAR(15, (2 * cycle) + 1);
				STAR(15, cycle + 1);
				SHOW_slow();
				BT_DELAY(dly);

			}
			else
			{
				cycle = 0;

				byte cycled_back = LOAD_NEXT_SAVED_IMAGE(0);
				SHOW_slow();

				/*Serial.println(F("PLAY_SAVES_SHOw: show 3, cycle=0"));
				Serial.print(F("cycled_back ="));
				Serial.println(cycled_back);
				Serial.println("");*/

				if (cycled_back == 1)  // time for next show
				{
					show_num = 0; // advance to next show flag
				}
			}

			Serial.println("");
			Serial.println("PSS: show 7:  end");
			Serial.println("");

		}

		////////////////////SHOW 8 //////////////////////////////
		if (show_num == 8)  // ringed transformations
		{


			int ringed_image2 = RETURN_NEXT_SAVED_IMAGE(0); // this finds a new saved image so the TEXT ring is different than the current G_active_PSS_image image

			//ringed_image2 = 0;  // for debug only

			CLEAR_ALL_LEDS();
			SHOW_slow();



			for (byte effect = 0; effect < 2; ++effect)
			{
				for (byte depth = 4; depth < 5; depth = depth + 4)
				{
					RING_with_IMAGE(G_active_PSS_image, ringed_image2, 15, 1, depth, effect);
					//RING_with_IMAGE(1, 2, 15, 1, depth, effect);
				}
			}


			int cycled_back = LOAD_NEXT_SAVED_IMAGE(0);  //get G_active_PSS_imag

			if (cycled_back == 1)
			{
				show_num = 0; // advance to next show flag
			}


		}

		////////////////////SHOW 9 //////////////////////////////
		if (show_num == 9)  // ROLL_X
		{

			Serial.println("");
			Serial.print(F("------->  PSS show 9: START"));
			Serial.println("");

			int cycled_back = 0;

			cycled_back = LOAD_NEXT_SAVED_IMAGE(1);

			//Serial.println("");
			//Serial.print(F("------->  PSS show 9:  G_active_PSS_image="));
			//Serial.println(G_active_PSS_image);
			//Serial.println("");

			//G_active_PSS_image

			SET_BOUNCE_ARRAY(1);

			if (cycled_back != 1)
			{
				for (int reps = 0; reps < 44; ++reps)
				{

					//BOUNCE_X(1, 5, 17);
					ROLL_X(1, 5, 17);
					SHOW_slow();
					delay(40);
				}

				cycled_back = LOAD_NEXT_SAVED_IMAGE(0);

				//Serial.println("");
				//Serial.print(F("------->  PSS show 9:  cycled_back ="));
				//Serial.println(cycled_back);
				//Serial.println("");

			}

			if (cycled_back == 1)// cycled_back=1
			{
				show_num = 0; // advance to next show flag

			}

			//Serial.print(F("------->LEAVING PSS show 9: show_num="));
			//Serial.println(show_num);
			//Serial.println("");

		}

		////////////////////SHOW 10 //////////////////////////////
		if (show_num == 10)  // BOUNCE_Y
		{


			int cycled_back = 0;

			cycled_back = LOAD_NEXT_SAVED_IMAGE(1);

			SET_BOUNCE_ARRAY(1);

			if (cycled_back != 1)
			{
				for (int reps = 0; reps < 44; ++reps)
				{
					BOUNCE_Y(1, 11, 0);

					SHOW_slow();
					delay(40);
				}

				cycled_back = LOAD_NEXT_SAVED_IMAGE(0);

				//Serial.println("");
				//Serial.print(F("------->  PSS show 10:  cycled_back ="));
				//Serial.println(cycled_back);
				//Serial.println("");



			}

			if (cycled_back == 1)// cycled_back=1// cycled_back=1
			{
				show_num = 0; // advance to next show flag
			}

			//Serial.print(F("------->LEAVING PSS show 10: show_num="));
			//Serial.println(show_num);
			//Serial.println("");

		}


		// ***  insert new PSS shows here  ***


	}  /////// END of PSS SHOWS /////////



	if (play_saves_count >= duration)  // return to DO_SHOW mode if PLAY_SAVES_MODE is selected for a long time (duration)
	{

		if (reset_when_done == 1)
		{
			Serial.println(F("PSS: END : before RESET"));
			Serial.println("");

			RESET(1);
		}
		else
		{
			Serial.println(F("PSS: END: no RESET "));
			Serial.println("");
		}
	}

}

//////////////////////////////////////////////////////////////////////////////////
void DO_COLOR_TRANSFORMATION(byte transform, byte effect_speed)
{
	G_number_of_color_transformations = 2;  // sets the number of possible color transformations

	switch (transform) {
	case 1:  //up
		ROTATE_COLORS(1);
		break;
	case 2:  //right
		//HUE_CYCLE_VERT(0, effect_speed, 0);  // change the colors each time 
		COLOR_STRIPES_VERT(4, 4);
		break;
	case 3:  // down
		//HUE_CYCLE_HOZ(0, effect_speed, 0);  // change the colors each time 
		COLOR_STRIPES_HOZ(4, 4);  // generate horizontal color stripes of random colors, only color LEDs already ON
		break;
	case 4:  // left
		ROTATE_COLORS(2);
		break;
	case 5:  //up right
		HUE_CYCLE_VERT(0, 6 * effect_speed, 2);  // change the colors each time 
		break;
	case 6:  // down right
		HUE_CYCLE_HOZ(0, 6 * effect_speed, 2);  // change the colors each time 
		break;
	case 7:  // down left
		HUE_CYCLE_HOZ(0, 3 * effect_speed, 2);  // change the colors each time 
		HUE_CYCLE_VERT(0, 3 * effect_speed, 2);  // change the colors each time 
		break;
	case 8:  // up left
		HUE_CYCLE_HOZ(0, 6 * effect_speed, 2);  // change the colors each time 
		HUE_CYCLE_VERT(0, 6 * effect_speed, 2);  // change the colors each time 
		break;


	default:
		// statements
		break;
	}
}

//************************************************************************************************************
void ROTATE_COLORS(int rot)
//  if rot=0: no rotation, rot=1: r->b, g->r, b->g  ,  rot=2: r->g, g->b , b->r
{
	byte r_temp1;
	byte g_temp1;
	byte b_temp1;

	byte r_temp2;
	byte g_temp2;
	byte b_temp2;

	byte r_temp3;
	byte g_temp3;
	byte b_temp3;

	byte r_temp4;
	byte g_temp4;
	byte b_temp4;

	int adr2;



	for (int n = 0; n < NUM_LEDS; ++n)
	{

		r_temp1 = leds1[n].r;
		g_temp1 = leds1[n].g;
		b_temp1 = leds1[n].b;


		r_temp3 = leds3[n].r;
		g_temp3 = leds3[n].g;
		b_temp3 = leds3[n].b;

		adr2 = modify_adr(0, 0, n);

		r_temp2 = leds2[adr2].r;
		g_temp2 = leds2[adr2].g;
		b_temp2 = leds2[adr2].b;

		r_temp4 = leds4[adr2].r;
		g_temp4 = leds4[adr2].g;
		b_temp4 = leds4[adr2].b;

		if (rot == 1)
		{
			if (G_panel1_on == 1)
			{
				leds1[n].r = b_temp1;
				leds1[n].g = r_temp1;
				leds1[n].b = g_temp1;
			}

			if (G_panel3_on == 1)
			{
				leds3[n].r = b_temp3;
				leds3[n].g = r_temp3;
				leds3[n].b = g_temp3;
			}


			if (G_panel2_on == 1)
			{
				leds2[adr2].r = b_temp2;
				leds2[adr2].g = r_temp2;
				leds2[adr2].b = g_temp2;
			}

			if (G_panel4_on == 1)
			{
				leds4[adr2].r = b_temp4;
				leds4[adr2].g = r_temp4;
				leds4[adr2].b = g_temp4;
			}

		}
		if (rot == 2)
		{
			if (G_panel1_on == 1)
			{
				leds1[n].r = g_temp1;
				leds1[n].g = b_temp1;
				leds1[n].b = r_temp1;
			}

			if (G_panel3_on == 1)
			{
				leds3[n].r = g_temp3;
				leds3[n].g = b_temp3;
				leds3[n].b = r_temp3;
			}

			if (G_panel2_on == 1)
			{
				leds2[adr2].r = g_temp2;
				leds2[adr2].g = b_temp2;
				leds2[adr2].b = r_temp2;
			}

			if (G_panel4_on == 1)
			{
				leds4[adr2].r = g_temp4;
				leds4[adr2].g = b_temp4;
				leds4[adr2].b = r_temp4;
			}
		}

		if (rot == 3)  // random hue select ... NOTE: each panel will have a different random hue
		{
			G_hue_select = random(0, MAX_HUES);   // each panel will show a different color

			//	leds[n].setHue = (hues[G_hue_select]);


			if ((leds1[n].g > 0) || (leds1[n].r > 0) || (leds1[n].b > 0))  // i.e. not a dark LED
			{
				if (G_panel1_on == 1)
				{
					leds1[n] = CHSV(hues[G_hue_select], 255, 255);
				}

			}

			if ((leds2[n].g > 0) || (leds2[n].r > 0) || (leds2[n].b > 0))  // i.e. not a dark LED
			{
				if (G_panel2_on == 1)
				{
					leds2[adr2] = CHSV(hues[G_hue_select], 255, 255);
				}
			}

			if ((leds3[n].g > 0) || (leds3[n].r > 0) || (leds3[n].b > 0))  // i.e. not a dark LED
			{
				if (G_panel3_on == 1)
				{
					leds3[n] = CHSV(hues[G_hue_select], 255, 255);
				}
			}

			if ((leds4[n].g > 0) || (leds4[n].r > 0) || (leds4[n].b > 0))  // i.e. not a dark LED
			{
				if (G_panel4_on == 1)
				{
					leds4[adr2] = CHSV(hues[G_hue_select], 255, 255);
				}
			}
		}
	}
}


///////////////////////////////////////////////////////////
void STAR(byte repeats, int darks)  // flash image on and off, 
{
	// repeats = number of revolutions to repeat this ... this is translated into time
	// darks = number blank image  SHOW_slow() times per repeat


	if (darks > 5) { darks = 5; }  // more than 4 results in only 1 image


	//Serial.println(F("STAR: START"));

#define ms_per_revolution 200  // assumimg 300 rpm

	int tadr = 0;
	CRGB leds1_temp[NUM_LEDS];  // create a holding array
	unsigned long duration = repeats * (ms_per_revolution);  // in ms
	unsigned long starting_time_stamp = millis();


	for (int n = 0; n < NUM_LEDS; ++n)  // copy led1 into temporary array
	{
		leds1_temp[n] = leds1[n];
	}

	FastLED.clear();  // clear interior image
	SHOW_slow();


	//for (byte n = 0; n < repeats; ++n)
	while ((millis() - starting_time_stamp) < duration)
	{

		FastLED.clear();  // clear interior image

		for (byte blanks = 0; blanks <= darks; ++blanks)
		{
			SHOW_slow();
		}

		// restore image
		for (int n = 0; n < NUM_LEDS; ++n)  // turn on LEDs
		{
			leds1[n] = leds1_temp[n];
			leds3[n] = leds1_temp[n];

			tadr = modify_adr(0, 0, n);

			leds2[tadr] = leds1_temp[n];
			leds4[tadr] = leds1_temp[n];
		}

		SHOW_slow();


	}

	//Serial.println(F("STAR: END"));

}

/////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////
//// STAR mode display in CREATE mode
//void STAR2(int float_time, int darks)
//
//// darks = how many blank frames
//
//// float_time= number of HALL counts to float image,  
////rep=how many times to repeat the same frame,
//// blanks = number of frames before all blanks are displayed : larger number will have more LEDs lit per revolution
//// note: rot=125 = 360 degrees at normal speed
//{
//
//	//darks = 5; // for testing only
//
//	Serial.println("");
//	Serial.println(F("STAR: start"));
//	Serial.print(F("STAR: G_Hall_sync="));
//	Serial.println(G_Hall_sync);
//	Serial.println("");
//
//	int tadr = 0;
//	unsigned long max_frames;
//
//	if ((G_Hall_sync == 1) && (digitalRead(HEAD_COM) == 0)) // only allow star float if HALL is active
//	{
//
//		if (G_cal_star_float >= 300)  // prevent blinking by limiting number of times CAL_SPIN2() is called  // prevent blinking by limiting number of times CAL_SPIN2() is called
//		{
//			Serial.println("");
//			Serial.println(F("STAR: before CAL_SPIN2"));
//			Serial.println("");
//
//			CAL_SPIN2(NUM_LEDS);  // find the maximum number of blanks for STAR FLOAT ... prevents flashing
//			G_cal_star_float = 0;
//
//			Serial.println("");
//			Serial.println(F("STAR: after CAL_SPIN2"));
//			Serial.println("");
//		}
//
//		max_frames = G_max_blanks - 3;
//
//		++G_cal_star_float;
//
//
//		CRGB leds1_temp[NUM_LEDS];  // create a holding array
//
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy led1 into temporary array
//		{
//			leds1_temp[n] = leds1[n];
//		}
//
//
//		unsigned long ft = READ_HALL_COUNTS() + float_time;
//
//		Serial.println("");
//		Serial.println(F("STAR: before while loop: ft="));
//		Serial.println(ft);
//		Serial.println("");
//
//		unsigned long begin_time_stamp = millis();
//		unsigned long max_time = begin_time_stamp + ((float_time + 15) / 4) * 1000;  // 4=revolutions per second at 240 rpm  
//		byte leave = 0;
//
//
//		//while (READ_HALL_COUNTS() < ft)
//		while ((READ_HALL_COUNTS() < ft) && (leave == 0))
//		{
//
//			if ((millis() - begin_time_stamp) > max_time)  // fail safe to prevent endless while...added 1/7/24
//			{
//				Serial.println(F("STAR: setting leave=1"));
//
//				leave = 1;
//				break;
//			}
//
//			for (int kk = 0; kk < max_frames; ++kk)   // this determines how many blanks between images
//			{
//
//
//				//SET2_BLACK_BRIGHT(1);  // turn on active LEDs
//
//				for (int n = 0; n < NUM_LEDS; ++n)  // turn on LEDs
//				{
//					leds1[n] = leds1_temp[n];
//					leds3[n] = leds1_temp[n];
//
//					tadr = modify_adr(0, 0, n);
//
//					leds2[tadr] = leds1_temp[n];
//					leds4[tadr] = leds1_temp[n];
//				}
//
//
//				//for (int g = 0; g < rep; ++g)
//				//{
//
//				if (READ_HALL_COUNTS() < ft)
//				{
//
//					SHOW_slow();
//					//Show_LEDs();
//					//	++kk;
//				}
//
//				//}
//
//
//			//SET2_BLACK_BRIGHT(0);  // turn off active LEDs
//
//				for (int n = 0; n < NUM_LEDS; ++n)  // turn off LEDs
//				{
//					leds1[n] = (0, 0, 0);
//					leds2[n] = (0, 0, 0);
//					leds3[n] = (0, 0, 0);
//					leds4[n] = (0, 0, 0);
//				}
//
//
//				for (int g = 0; g < darks; ++g)
//				{
//					if (READ_HALL_COUNTS() < ft)
//					{
//						SHOW_slow();
//						//Show_LEDs();
//						++kk;
//					}
//
//				}
//
//			}
//
//
//			//FastLED.clear();   // set to black all LEDs
//			//Show_LEDs();
//
//
//
//		}
//
//		//SET2_BLACK_BRIGHT(1);  // turn on active LEDs
//
//		for (int n = 0; n < NUM_LEDS; ++n)  // turn on LEDs
//		{
//			leds1[n] = leds1_temp[n];
//			leds3[n] = leds1_temp[n];
//
//			tadr = modify_adr(0, 0, n);
//
//			leds2[tadr] = leds1_temp[n];
//			leds4[tadr] = leds1_temp[n];
//
//		}
//		//Show_LEDs();
//		SHOW_slow();
//
//
//	}
//
//	Serial.println(F("STAR: END"));
//
//}

//////////////////////////////////////////////////////////////////////
void LOAD_SAVE(byte save)  // load all panels with the leds_save#[]
{


	for (int n = 0; n < NUM_LEDS; ++n)
	{

		leds1[n] = leds_saved[save][n];
		leds3[n] = leds_saved[save][n];

		int adr2 = modify_adr(0, 0, n);
		leds2[adr2] = leds_saved[save][n];
		leds4[adr2] = leds_saved[save][n];

	}



}


//////////////////////////////////////////////////////////////////////
void LOAD_BACKGROUND()  // load all panels with the leds_saved[0][n]=background
{


	for (int n = 0; n < NUM_LEDS; ++n)
	{
		leds1[n] = leds_saved[0][n];  // background
		leds3[n] = leds_saved[0][n];

		int adr2 = modify_adr(0, 0, n);
		leds2[adr2] = leds_saved[0][n];
		leds4[adr2] = leds_saved[0][n];

	}



}

//////////////////////////////////////////////////////////////////////////
void UNDO(byte NoChange)  // set to dark LEDs previously lit by a DRAW, CIRCLE or LINE or RECTANGLE command
// NoChange=1 to not change LEDs but properly clear the STACK
{

	byte command = 0;
	byte panel = 0;
	byte X = 0;
	byte Y = 0;
	byte panel1 = 0;
	byte panel2 = 0;
	byte panel3 = 0;
	byte panel4 = 0;
	int adr = 0;
	int tadr = 0;

	/*Serial.println(F(""));
	Serial.println(F("^^^^^^^^^^ UNDO start  ^^^^^^^^^^^^"));
	Serial.print(F("UNDO before POP: G_pointer="));
	Serial.println(G_pointer);
	Serial.println(F(""));

	Serial.println("");
	Serial.println("UNDO: STACK dump ++++++++++++");
	for (int n = G_pointer; n >= 0; --n)
	{
		Serial.print(F("SD: stack position="));
		Serial.print(n);
		Serial.print(F("  :  SD: stack value="));
		Serial.println(undo_stack[n]);
	}
	Serial.println("SD: END of STACK dump ++++++++++++");*/


	if (((G_pointer == 0) && (G_pointer_rollover_flag == 0)) || (G_CREATE_mode == 0)) { return; }  // exit function if trying to undo beyond 0

	POP();

	command = undo_stack[G_pointer];
	panel = undo_stack[G_pointer + 1];
	X = undo_stack[G_pointer + 2];
	Y = undo_stack[G_pointer + 3];

	/*Serial.print(F("UNDO: G_pointer="));
	Serial.println(G_pointer);
	Serial.print(F("UNDO: command="));
	Serial.println(command);
	Serial.print(F("UNDO: panel="));
	Serial.println(panel);
	Serial.print(F("UNDO: X="));
	Serial.println(X);
	Serial.print(F("UNDO: Y="));
	Serial.println(Y);
	Serial.println("");*/





	adr = XY_ADR(X, Y);
	tadr = modify_adr(0, 0, adr);


	// decode panels that will take part in the undo
	if (panel - 8 >= 0)
	{
		panel4 = 1;
		panel = panel - 8;
	}
	if (panel - 4 >= 0)
	{
		panel3 = 1;
		panel = panel - 4;
	}
	if (panel - 2 >= 0)
	{
		panel2 = 1;
		panel = panel - 2;
	}
	if (panel - 1 >= 0)
	{
		panel1 = 1;
		panel = panel - 1;
	}


	//////////////////////////////////
	if ((command == 0) && (NoChange == 0))  // draw mode undo
	{
		if (panel1 == 1)
		{
			leds1[adr].r = 0;
			leds1[adr].g = 0;
			leds1[adr].b = 0;
		}

		if (panel2 == 1)
		{
			leds2[tadr].r = 0;
			leds2[tadr].g = 0;
			leds2[tadr].b = 0;
		}

		if (panel3 == 1)
		{
			leds3[adr].r = 0;
			leds3[adr].g = 0;
			leds3[adr].b = 0;
		}

		if (panel4 == 1)
		{
			leds4[tadr].r = 0;
			leds4[tadr].g = 0;
			leds4[tadr].b = 0;
		}


	}

	/////////////////////////////
	if (command == 1)  // line mode undo
	{
		byte xs = X; // start of line
		byte ys = Y;

		POP(); // get end of line data

		command = undo_stack[G_pointer];
		panel = undo_stack[G_pointer + 1];
		X = undo_stack[G_pointer + 2];
		Y = undo_stack[G_pointer + 3];

		/*Serial.println(F("UNDO:------------> LINE command"));
		Serial.print(F("UNDO: G_pointer2="));
		Serial.println(G_pointer);
		Serial.print(F("UNDO: command2="));
		Serial.println(command);
		Serial.print(F("UNDO: panel="));
		Serial.println(panel);
		Serial.print(F("UNDO: X2="));
		Serial.println(X);
		Serial.print(F("UNDO: Y2="));
		Serial.println(Y);
		Serial.println("")*/;

		if ((command == 3) && (NoChange == 0))  // end of line ... it should be but just in case
		{
			LINE(xs, ys, X, Y, 999); // draw a dark line
		}

	}

	/////////////////////////////
	if (command == 2)  // circle mode undo
	{
		byte xs = X; // center of circle
		byte ys = Y;

		POP(); // get end of line data

		command = undo_stack[G_pointer];
		panel = undo_stack[G_pointer + 1];
		X = undo_stack[G_pointer + 2];
		Y = undo_stack[G_pointer + 3];

		// calculate radius
		int delta_X = (int)xs - (int)X;
		int delta_Y = (int)ys - (int)Y;

		int radius = sqrt((delta_X * delta_X) + (delta_Y * delta_Y));

		if ((command == 4) && (NoChange == 0))  // end of circle ... it should be but just in case
		{
			//SPHERE((byte)radius, xs, ys, 999);  // draw a dark circle
			CIRCLE((double)radius, xs, ys, 999);  // draw a dark circle
		}

	}

	/////////////////////////////
	if (command == 5)  // rectangle mode undo
	{
		byte xs = X; // start of rectangle
		byte ys = Y;

		POP(); // get end of diaganol coordinates

		command = undo_stack[G_pointer];
		panel = undo_stack[G_pointer + 1];
		X = undo_stack[G_pointer + 2];
		Y = undo_stack[G_pointer + 3];

		/*Serial.println(F("UNDO:------------> RECTANGLE command"));
		Serial.print(F("UNDO: G_pointer2="));
		Serial.println(G_pointer);
		Serial.print(F("UNDO: command2="));
		Serial.println(command);
		Serial.print(F("UNDO: panel="));
		Serial.println(panel);
		Serial.print(F("UNDO: X2="));
		Serial.println(X);
		Serial.print(F("UNDO: Y2="));
		Serial.println(Y);
		Serial.println("");*/

		if ((command == 6) && (NoChange == 0))  // end of diagnol... it should be but just in case
		{
			RECTANGLE(xs, ys, X, Y, 999); // draw a dark rectangle
		}

	}

	/////////////////////////////
	if (command == 7)  // triangle mode undo
	{
		byte xs = X; // start of triangle
		byte ys = Y;

		POP(); // get end of diaganol coordinates

		command = undo_stack[G_pointer];
		panel = undo_stack[G_pointer + 1];
		X = undo_stack[G_pointer + 2];
		Y = undo_stack[G_pointer + 3];

		/*Serial.println(F("UNDO:------------> RECTANGLE command"));
		Serial.print(F("UNDO: G_pointer2="));
		Serial.println(G_pointer);
		Serial.print(F("UNDO: command2="));
		Serial.println(command);
		Serial.print(F("UNDO: panel="));
		Serial.println(panel);
		Serial.print(F("UNDO: X2="));
		Serial.println(X);
		Serial.print(F("UNDO: Y2="));
		Serial.println(Y);
		Serial.println("");*/

		if ((command == 8) && (NoChange == 0))  // end of diagnol... it should be but just in case
		{
			TRIANGLE(xs, ys, X, Y, 999); // draw a dark triangle
		}

	}

	if (NoChange == 0)
	{
		SHOW_slow();
	}
}


//////////////////////////////////////////////////////////////////////////////////

// in CREATE mode draw on screen
void DRAW_in_CREATE()
{
	Serial.println(F("++++++ DRAW_in_CREATE +++++++"));
	Serial.print(F("G_geometery="));
	Serial.println(G_geometery);
	Serial.print(F("G_hue="));
	Serial.println(G_hue);
	Serial.print(F("G_RAND_HUE="));
	Serial.println(G_RAND_HUE);
	Serial.println(F(""));

	int hue = G_hue;

	G_UNDO_stored = 0;  // don't allow leds_buffer# images to be load during an UNDO

	if (G_RAND_HUE == 1)
	{
		hue = random(0, 213);
	}

	if (G_CREATE_mode == 1)
	{
		if (G_geometery == 1)  // dots mode
		{
			XY_HANDLE(G_X, G_Y);
			PUSH(0, G_X, G_Y);  // push undo data into the undo_stack,  0=draw mode

		}

		if (G_geometery == 0)   // line mode
		{
			if (G_end_flag == 1)
			{
				LINE(G_X_previous, G_Y_previous, G_X, G_Y, hue);

				Serial.println(F("DIC  LINE mode: before PUSH"));
				Serial.println(F(""));

				PUSH(3, G_X, G_Y); // end of line goes on the STACK first
				PUSH(1, G_X_previous, G_Y_previous); // start of line

				G_end_flag = 0;

				SHOW_slow();
				SHOW_slow(); // this 2nd SHOW_slow() should not be necessary but it is as otherwise sometime on one panel I see erroneous/random YELLOW LEDs light
			}
			else
			{
				G_end_flag = 1;  // wait for second XY pair to be received
			}
		}


		if (G_geometery == 2)   // SPHERE mode
		{
			if (G_end_flag == 1)
			{
				// calculate radius
				int delta_X = (int)G_X - (int)G_X_previous;
				int delta_Y = (int)G_Y - (int)G_Y_previous;

				int radius = sqrt((delta_X * delta_X) + (delta_Y * delta_Y));


				//SPHERE((byte)radius, G_X_previous, G_Y_previous, G_hue);
				CIRCLE((double)radius, G_X_previous, G_Y_previous, hue);

				PUSH(4, G_X, G_Y); // end of circle goes on the STACK first
				PUSH(2, G_X_previous, G_Y_previous); // start of circle

				G_end_flag = 0;

				SHOW_slow();
				SHOW_slow(); // this 2nd SHOW_slow() should not be necessary but it is as otherwise sometime on one panel I see erroneous/random YELLOW LEDs light
			}
			else
			{
				G_end_flag = 1;  // wait for second XY pair to be received
			}
		}

		if (G_geometery == 3)   // RECTANGLE mode
		{
			if (G_end_flag == 1)
			{

				RECTANGLE(G_X, G_Y, G_X_previous, G_Y_previous, hue);

				PUSH(6, G_X_previous, G_Y_previous); // diagonal
				PUSH(5, G_X, G_Y); // start of rectangle goes on the STACK first


				G_end_flag = 0;

				SHOW_slow();
				SHOW_slow();  // this 2nd SHOW_slow() should not be necessary but it is as otherwise sometime on one panel I see erroneous/random YELLOW LEDs light
			}
			else
			{
				G_end_flag = 1;  // wait for second XY pair to be received
			}
		}

		if (G_geometery == 4)   // TRIANGLE mode
		{
			if (G_end_flag == 1)
			{

				TRIANGLE(G_X, G_Y, G_X_previous, G_Y_previous, hue);

				PUSH(8, G_X_previous, G_Y_previous); // diagonal
				PUSH(7, G_X, G_Y); // start of triangle goes on the STACK first


				G_end_flag = 0;

				SHOW_slow();
				SHOW_slow(); // this 2nd SHOW_slow() should not be necessary but it is as otherwise sometime on one panel I see erroneous/random YELLOW LEDs light
			}
			else
			{
				G_end_flag = 1;  // wait for second XY pair to be received
			}
		}



	}

}


//////////////////////////////////////////////////////////////////
void ROLL_HOZ(byte num2roll) //old version,,,, roll outter column to inner column and inner column to outter column doing num2roll columns each time
{
	//num2roll sets how many columns are rolled 

	CRGB leds_temp[NUM_LEDS];
	int adr;
	int adr2;
	int newX = 0;


	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{

				newX = x + num2roll;

				if (newX >= NUM_COLUMNS)  // roll outter edge to inner
				{
					newX = newX - NUM_COLUMNS;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(newX, y);
				leds1[adr2] = leds_temp[adr];


			}
		}

	}

	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{

				newX = x + num2roll;

				if (newX >= NUM_COLUMNS)  // roll outter edge to inner
				{
					newX = newX - NUM_COLUMNS;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(newX, y);
				leds2[adr2] = leds_temp[adr];


			}
		}

	}


	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{

				newX = x + num2roll;

				if (newX >= NUM_COLUMNS)  // roll outter edge to inner
				{
					newX = newX - NUM_COLUMNS;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(newX, y);
				leds3[adr2] = leds_temp[adr];


			}
		}
	}


	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{

				newX = x + num2roll;

				if (newX >= NUM_COLUMNS)  // roll outter edge to inner
				{
					newX = newX - NUM_COLUMNS;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(newX, y);
				leds4[adr2] = leds_temp[adr];


			}
		}

	}
}

//////////////////////////////////////////////////////////////////
void ROLL_VERT(byte num2roll) // roll lower row to upper rows and top rows to lower rows doing num2roll rows each time
{
	//num2roll sets how many rows are rolled 

	CRGB leds_temp[NUM_LEDS];
	int adr;
	int adr2;
	int adr3;
	int newY = 0;


	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)
		{

			for (int y = 0; y < NUM_ROWS; ++y)
			{

				newY = y + num2roll;

				if (newY >= NUM_ROWS)  // roll outter edge to inner
				{
					newY = newY - NUM_ROWS;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, newY);
				leds1[adr2] = leds_temp[adr];


			}
		}

	}

	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)
		{

			for (int y = NUM_ROWS - 1; 0 <= y; --y)
			{

				newY = y - num2roll;

				if (newY < 0)  // roll outter edge to inner
				{
					newY = NUM_ROWS + newY;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, newY);
				leds2[adr2] = leds_temp[adr];


			}

		}

	}


	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)
		{

			for (int y = 0; y < NUM_ROWS; ++y)
			{

				newY = y + num2roll;

				if (newY >= NUM_ROWS)  // roll outter edge to inner
				{
					newY = newY - NUM_ROWS;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, newY);
				leds3[adr2] = leds_temp[adr];


			}
		}
	}


	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}



		for (int x = 0; x < NUM_COLUMNS; ++x)
		{

			for (int y = NUM_ROWS - 1; 0 <= y; --y)
			{

				newY = y - num2roll;

				if (newY < 0)  // roll outter edge to inner
				{
					newY = NUM_ROWS + newY;
				}

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, newY);
				leds4[adr2] = leds_temp[adr];


			}

		}


	}
}

/////////////////////////////////////////////////////////////////////
void PUSH(byte command, byte X, byte Y)  // push data onto the undo_stack in CREATE mode
{
	// G_pointer always points to the next available STACK position 

	//return;  // delete when this  is working

	int panels = 0;  // panels on

	if (G_pointer + 4 >= UNDO_STACK_SIZE)   // time to re-order stack to prevent over flow
	{
		G_pointer = 0;
		G_pointer_rollover_flag = 1; //// set to 1 if the undo stack rolls back to position 0
	}



	//byte undo_stack[UNDO_STACK_SIZE];
	//int G_pointer = 0;  // UNDO STACK pointer


	if (G_panel1_on == 1) { panels = 1; }
	if (G_panel2_on == 1) { panels = panels + 2; }
	if (G_panel3_on == 1) { panels = panels + 4; }
	if (G_panel4_on == 1) { panels = panels + 8; }



	undo_stack[G_pointer] = command;  // command

	++G_pointer;
	undo_stack[G_pointer] = panels;  // panels on


	++G_pointer;
	undo_stack[G_pointer] = X;

	++G_pointer;
	undo_stack[G_pointer] = Y;

	++G_pointer;




}

////////////////////////////////////////////////////////////////////////////
void POP()  // adjust G_pointer for removal of 4 bytes
{
	G_pointer = G_pointer - 4;

	if ((G_pointer < 0) && (G_pointer_rollover_flag == 1))  // roll the pointer to the bottom of the stack
	{
		G_pointer = UNDO_STACK_SIZE - 4;
		G_pointer_rollover_flag = 0;
	}

	if (G_pointer < 0)
	{
		G_pointer = 0;
	}

}

//******************************************************************************************
//void FLIP(int flip)  // flip the displays, flip=1 to flip, flip=0 to set back to normal 
//{
//	if (flip == 1)
//	{
//		if (G_flipped == 0)  // keep track if image is flipped or nor
//		{
//			G_flipped = 1;
//		}
//		else
//		{
//			G_flipped = 0;
//		}
//
//		if (G_upside_down == 1)
//		{
//			G_upside_down = 0;
//		}
//		else
//		{
//			G_upside_down = 1;
//		}
//
//	}
//	else   // flip=0
//	{
//		if (G_flipped == 1)  // if flipped return to normal
//		{
//			if (G_upside_down == 1)
//			{
//				G_upside_down = 0;
//			}
//			else
//			{
//				G_upside_down = 1;
//			}
//			G_flipped = 0;  // no longer flipped
//		}
//	}
//
//}



//////////////////////////////////////////////////////////////////////
void FLIP_DISPLAY()  // turn the display up side down 
{
	for (int n = 0; n < NUM_LEDS; ++n)
	{

		// note leds2 is upside down from leds1, leds4 is upside down from leds3
		// leds1 = leds3
		// leds2 = leds4

		leds1[n] = leds2[n];  
		leds2[n] = leds3[n];  // use led3 instead of leds1 which has been changed

		// at this point leds1 and leds2 are have been turned upside down
		
	}
	for (int n = 0; n < NUM_LEDS; ++n)
	{

		// note leds2 is upside down from leds1, leds4 is upside down from leds3
		leds3[n] = leds1[n];
		leds4[n] = leds2[n];


	}



}

//
//////////////////////////////////////////////////////////////////////
//void FLIP_DISPLAY_old()  // turn the display up side down 
//{
//	CRGB leds_temp[NUM_LEDS];
//	int adr;
//
//	if (G_panel1_on == 1)
//	{
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			leds_temp[n] = leds1[n];
//		}
//
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			adr = modify_adr(0, 0, n);
//			leds1[n] = leds_temp[adr];
//		}
//
//	}
//
//	if (G_panel2_on == 1)
//	{
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			leds_temp[n] = leds2[n];
//		}
//
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			adr = modify_adr(0, 0, n);
//			leds2[n] = leds_temp[adr];
//		}
//
//	}
//
//
//	if (G_panel3_on == 1)
//	{
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			leds_temp[n] = leds3[n];
//		}
//
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			adr = modify_adr(0, 0, n);
//			leds3[n] = leds_temp[adr];
//		}
//
//	}
//
//
//	if (G_panel4_on == 1)
//	{
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			leds_temp[n] = leds4[n];
//		}
//
//		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
//		{
//			adr = modify_adr(0, 0, n);
//			leds4[n] = leds_temp[adr];
//		}
//
//	}
//
//
//}


//////////////////////////////////////////////////////////////////////
void XY_SWAP()  // swap X and Y coordinates for all LEDs
{
	CRGB leds_temp[NUM_LEDS];
	int adr;
	int tadr;
	int adr_swapped;

	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}


		for (int x = 0; x < NUM_COLUMNS; ++x)  // copy existing mapping
		{
			for (int y = 0; y < NUM_ROWS; ++y)
			{
				adr = XY_ADR(x, y);
				adr_swapped = XY_ADR(y, x);
				leds1[adr] = leds_temp[adr_swapped];
			}

		}

	}

	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}


		for (int x = 0; x < NUM_COLUMNS; ++x)  // copy existing mapping
		{
			for (int y = 0; y < NUM_ROWS; ++y)
			{
				adr = XY_ADR(x, y);
				adr_swapped = XY_ADR(y, x);
				tadr = modify_adr(0, 0, adr_swapped);
				leds2[adr] = leds_temp[tadr];
			}

		}

		// now FLIP this panel
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			adr = modify_adr(0, 0, n);
			leds2[n] = leds_temp[adr];
		}

	}

	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}


		for (int x = 0; x < NUM_COLUMNS; ++x)  // copy existing mapping
		{
			for (int y = 0; y < NUM_ROWS; ++y)
			{
				adr = XY_ADR(x, y);
				adr_swapped = XY_ADR(y, x);
				leds3[adr] = leds_temp[adr_swapped];
			}

		}

	}

	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}


		for (int x = 0; x < NUM_COLUMNS; ++x)  // copy existing mapping
		{
			for (int y = 0; y < NUM_ROWS; ++y)
			{
				adr = XY_ADR(x, y);
				adr_swapped = XY_ADR(y, x);
				tadr = modify_adr(0, 0, adr_swapped);
				leds4[adr] = leds_temp[tadr];
			}

		}

		// now FLIP this panel
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}

		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			adr = modify_adr(0, 0, n);
			leds4[n] = leds_temp[adr];
		}

	}

}

//////////////////////////////////////////////////////////////////////
void SIDE_FLIP_DISPLAY()  // flip the columns 
{
	CRGB leds_temp[NUM_LEDS];
	int adr;
	int adr2;

	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)  // copy existing mapping
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(NUM_COLUMNS - x - 1, y);
				leds1[adr] = leds_temp[adr2];
			}
		}

	}

	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)  // copy existing mapping
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				//  adr = modify_adr(0, 0, adr);

				adr2 = GET_XY_ADR(NUM_COLUMNS - x - 1, y);
				//	adr2 = modify_adr(0, 0, adr2);

				leds2[adr] = leds_temp[adr2];
			}
		}

	}


	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)  // copy existing mapping
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(NUM_COLUMNS - x - 1, y);
				leds3[adr] = leds_temp[adr2];
			}
		}

	}


	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)  // copy existing mapping
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				//  adr = modify_adr(0, 0, adr);

				adr2 = GET_XY_ADR(NUM_COLUMNS - x - 1, y);
				//	adr2 = modify_adr(0, 0, adr2);

				leds4[adr] = leds_temp[adr2];
			}
		}

	}


}

//////////////////////////////////////////////////////////////////
void FLIP_MID_VERT() // flip the display around the middle of the display... vertically
{
	CRGB leds_temp[NUM_LEDS];
	int adr;
	int adr2;

	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}

		for (int y = 0; y < NUM_ROWS / 2; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y + (NUM_ROWS / 2));
				adr2 = GET_XY_ADR(x, y);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}
		}

	}

	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int y = 0; y < NUM_ROWS / 2; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y + (NUM_ROWS / 2));
				adr2 = GET_XY_ADR(x, y);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}
		}

	}


	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}

		for (int y = 0; y < NUM_ROWS / 2; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y + (NUM_ROWS / 2));
				adr2 = GET_XY_ADR(x, y);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}
		}

	}


	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}

		for (int y = 0; y < NUM_ROWS / 2; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y + (NUM_ROWS / 2));
				adr2 = GET_XY_ADR(x, y);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}
		}

	}

}

//////////////////////////////////////////////////////////////////
void FLIP_MID_HOZ() // flip the display around the middle of the display...horizontally
{
	CRGB leds_temp[NUM_LEDS];
	int adr;
	int adr2;

	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS / 2; ++x)
			{
				adr = GET_XY_ADR(x + (NUM_COLUMNS / 2), y);
				adr2 = GET_XY_ADR(x, y);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}
		}

	}

	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS / 2; ++x)
			{
				adr = GET_XY_ADR(x + (NUM_COLUMNS / 2), y);
				adr2 = GET_XY_ADR(x, y);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}
		}

	}


	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS / 2; ++x)
			{
				adr = GET_XY_ADR(x + (NUM_COLUMNS / 2), y);
				adr2 = GET_XY_ADR(x, y);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}
		}
	}


	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{

			for (int x = 0; x < NUM_COLUMNS / 2; ++x)
			{
				adr = GET_XY_ADR(x + (NUM_COLUMNS / 2), y);
				adr2 = GET_XY_ADR(x, y);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}
		}

	}

}

//////////////////////////////////////////////////////////////////
void FLIP_SQUARE_HOZ() // flip all quadrents of the display about the middle of quadrent ... horizontal flip
{
	CRGB leds_temp[NUM_LEDS];
	int adr;
	int adr2;

	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{
			// left side
			for (int x = 0; x < 5; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}

			for (int x = 6; x < 11; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}

			// right side
			for (int x = 11; x < 16; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}

			for (int x = 17; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}
		}


	}




	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{
			// left side
			for (int x = 0; x < 5; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}

			for (int x = 6; x < 11; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}

			// right side
			for (int x = 11; x < 16; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}

			for (int x = 17; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}
		}



	}




	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{
			// left side
			for (int x = 0; x < 5; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}

			for (int x = 6; x < 11; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}

			// right side
			for (int x = 11; x < 16; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}

			for (int x = 17; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}
		}

	}


	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}

		for (int y = 0; y < NUM_ROWS; ++y)
		{
			// left side
			for (int x = 0; x < 5; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}

			for (int x = 6; x < 11; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}

			// right side
			for (int x = 11; x < 16; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x + 6, y);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}

			for (int x = 17; x < NUM_COLUMNS; ++x)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x - 6, y);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}
		}
	}
}

//////////////////////////////////////////////////////////////////
void FLIP_SQUARE_VERT() // flip all quadrents of the display about the middle of quadrent ... vertical flip
{
	CRGB leds_temp[NUM_LEDS];
	int adr;
	int adr2;

	if (G_panel1_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds1[n];
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			// left side
			for (int y = 0; y < 5; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}

			for (int y = 6; y < 11; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}

			// right side
			for (int y = 11; y < 16; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}

			for (int y = 17; y < NUM_COLUMNS; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds1[adr2] = leds_temp[adr];
				leds1[adr] = leds_temp[adr2];

			}
		}


	}




	if (G_panel2_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds2[n];
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			// left side
			for (int y = 0; y < 5; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}

			for (int y = 6; y < 11; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}

			// right side
			for (int y = 11; y < 16; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}

			for (int y = 17; y < NUM_COLUMNS; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds2[adr2] = leds_temp[adr];
				leds2[adr] = leds_temp[adr2];

			}
		}



	}




	if (G_panel3_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds3[n];
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			// left side
			for (int y = 0; y < 5; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}

			for (int y = 6; y < 11; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}

			// right side
			for (int y = 11; y < 16; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}

			for (int y = 17; y < NUM_COLUMNS; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds3[adr2] = leds_temp[adr];
				leds3[adr] = leds_temp[adr2];

			}
		}

	}


	if (G_panel4_on == 1)
	{
		for (int n = 0; n < NUM_LEDS; ++n)  // copy existing mapping
		{
			leds_temp[n] = leds4[n];
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			// left side
			for (int y = 0; y < 5; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}

			for (int y = 6; y < 11; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}

			// right side
			for (int y = 11; y < 16; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y + 6);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}

			for (int y = 17; y < NUM_COLUMNS; ++y)
			{
				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x, y - 6);
				leds4[adr2] = leds_temp[adr];
				leds4[adr] = leds_temp[adr2];

			}
		}
	}
}

/////////////////////////////////////////////////////////////////////
void DO_TRANSFORMATION(byte transform)
{
	G_number_of_transformations = 7;  // sets the number of possible transformations

	switch (transform) {
	case 1:
		FLIP_DISPLAY();  // FLIP
		break;
	case 2:
		XY_SWAP();  // XY swap
		break;
	case 3:
		SIDE_FLIP_DISPLAY();  // side flip
		break;
	case 4:
		FLIP_MID_VERT(); // flip vertically around mid display
		break;
	case 5:
		FLIP_MID_HOZ();  // flip horizontally around mid display
		break;
	case 6:
		FLIP_SQUARE_HOZ();  // square flip horizontal
		break;
	case 7:
		FLIP_SQUARE_VERT();  // square flip vertical
		break;
	case 8:
		int rn;
		rn = random(1, 7);
		DO_TRANSFORMATION(rn);  // random transformation
		break;

	default:
		// statements
		break;
	}
}


//////////////////////////////////////////////////////////////////////////
byte LOAD_NEXT_SAVED_IMAGE(byte load_first_saved)
// load the next valid SAVED image 
// generate a new G_active_PSS_image
// return a 1 if cycling back to first valid image
// if load_first_saved=1 then first valid image is loaded starting with 1
// loaded image is stored in G_active_PSS_image 
// if there are no valid saved images then G_active_PSS_image = 0
{
	byte image_num = G_active_PSS_image;
	byte rv = 0;

	++image_num;

	if ((image_num > maximum_number_of_SAVED_images) || (load_first_saved == 1))
	{
		image_num = 1;
		rv = 1;  // indicate cycled_back

	}

	//Serial.print(F("------->  LOAD_NEXT_SAVED_IMAGE:  load_first_saved="));
	//Serial.println(load_first_saved);
	//Serial.print(F("G_active_PSS_image="));
	//Serial.println(G_active_PSS_image);
	//Serial.print(F("rv="));
	//Serial.println(rv);
	//Serial.println("");

	for (byte n = image_num; n <= maximum_number_of_SAVED_images; ++n)
	{

		//Serial.println(F("&&&&&&&&&&&& LOAD_NEXT_SAVED_IMAGE:  searching for valid image"));
		//Serial.print(F("n="));
		//Serial.println(n);
		//Serial.print(F("G_SAVED[n]="));
		//Serial.println(G_SAVED[n]);
		//Serial.print(F("image_num="));
		//Serial.println(image_num);
		//Serial.print(F("rv="));
		//Serial.println(rv);
		//Serial.println("");

		if (G_SAVED[n] > 0)  // a valid saved image
		{

			LOAD_SAVE(n);

			G_active_PSS_image = n;
			return rv;

		}
	}



	// at this point there is no valid image above current image_num
	// therefore search from the beginning 

	G_active_PSS_image = 0;  // this will stay equal to 0 if no saved images found

	for (byte k = 1; k < image_num; ++k)  // search for valid image less than present image number
	{
		Serial.println(F("&&&&&&&&&&&& LOAD_NEXT_SAVED_IMAGE:  position 5"));


		if (G_SAVED[k] > 0)  // a valid saved image
		{

			//Serial.println(F("&&&&&&&&&&&& LOAD_NEXT_SAVED_IMAGE:  position 6"));
			//Serial.print(F("k="));
			//Serial.println(k);
			//Serial.print(F("G_SAVED[k]="));
			//Serial.println(G_SAVED[k]);
			//Serial.println("");

			LOAD_SAVE(k);

			G_active_PSS_image = k;
			return 1;  // indicate cycled_back

		}

	}

	return 1;  // indicate cycled_back: note:  G_active_PSS_image = 0;  // this will 0 if no saved images found // added 1/6/24
}

//////////////////////////////////////////////////////////////////////////
byte RETURN_NEXT_SAVED_IMAGE(byte load_first_saved)
// returns the next valid SAVED image assuming the current active PSS image is stored in G_active_PSS_image
// if load_first_saved=1 then this function searches for the first valid saved image starting with 1
{
	byte image_num = G_active_PSS_image;
	byte rv = 0;

	++image_num;

	if ((image_num > maximum_number_of_SAVED_images) || (load_first_saved == 1))
	{
		image_num = 1;

	}

	Serial.print(F("------->  RETURN_NEXT_SAVED_IMAGE:  load_first_saved="));
	Serial.println(load_first_saved);
	Serial.println("");

	for (byte n = image_num; n <= maximum_number_of_SAVED_images; ++n)
	{

		Serial.println(F("&&&&&&&&&&&& RETURN_NEXT_SAVED_IMAGE:  searching for valid image"));
		Serial.print(F("n="));
		Serial.println(n);
		Serial.print(F("G_SAVED[n]="));
		Serial.println(G_SAVED[n]);
		Serial.println("");

		if (G_SAVED[n] > 0)  // a valid saved image
		{

			return n;

		}
	}

	// at this point there is no valid image above current image_num
	// therefore search from the beginning 
	for (byte k = 1; k < image_num; ++k)  // search for valid image less than present image number
	{
		if (G_SAVED[k] > 0)  // a valid saved image
		{

			return k;


		}

	}

	return 0;  //no image found:  added 1/6/24

}

//////////////////////////////////////////////////////////////////////
void RECTANGLE(int xs, int ys, int xe, int ye, int hue)  // generate a filled rectangle from given diagnol
{
	int xt;
	int yt;
	int adr;
	int adr2;

	byte S = 255;
	byte V = 255-G_dim;  //0524 was G_dim

	if (hue == 999) // set color to black
	{
		S = 0;
		V = 0;
		hue = 0;
	}

	if (hue == -1)  // white
	{
		S = 0;
		V = 255;
		hue = 0;
	}

	if (xs > xe) // swap xs and xe and ys and ye
	{
		xt = xs;
		xs = xe;
		xe = xt;

		yt = ys;
		ys = ye;
		ye = yt;
	}


	for (int x = xs; x <= xe; ++x)
	{
		if (ye > ys)
		{
			for (int y = ys; y <= ye; ++y)
			{
				if ((x == xs) || (x == xe) || (y == ys) || (y == ye))
				{
					adr = GET_XY_ADR(x, y);
					leds1[adr] = CHSV(hue, S, V);
					leds3[adr] = CHSV(hue, S, V);

					adr2 = modify_adr(0, 0, adr);
					leds2[adr2] = CHSV(hue, S, V);
					leds4[adr2] = CHSV(hue, S, V);
				}

			}

		}
		else
		{
			for (int y = ye; y <= ys; ++y)
			{
				if ((x == xs) || (x == xe) || (y == ys) || (y == ye))
				{
					adr = GET_XY_ADR(x, y);
					leds1[adr] = CHSV(hue, S, V);
					leds3[adr] = CHSV(hue, S, V);

					adr2 = modify_adr(0, 0, adr);
					leds2[adr2] = CHSV(hue, S, V);
					leds4[adr2] = CHSV(hue, S, V);
				}

			}
		}



	}

}

//////////////////////////////////////////////////
void XY_HANDLE(byte X, byte Y)  // do something with the CREATE mode X and Y data
{

	Serial.println("");
	Serial.println(F("++++++++++++++++++++++++++++++++++++++++++++++++++++++  XY_HANDLE:"));
	Serial.print(F("X="));
	Serial.println(X);
	Serial.print(F("Y="));
	Serial.println(Y);
	Serial.print(F("G_X="));
	Serial.println(G_X);
	Serial.print(F("G_Y="));
	Serial.println(G_Y);

	// clear previouse LED position
	CHSV hsv_dark(0, 0, 0);  // DARK pixel
	CRGB rgb;

	int adr = GET_XY_ADR(G_X, G_Y);  // this is the previous LED position
	int tadr = modify_adr(0, 0, adr);
	int hue = G_hue;

	hsv2rgb_rainbow(hsv_dark, rgb); // convert HSV to RGB

	//	Serial.println(F("++++++++++++++++++++  XY_HANDLE: position 2"));

		//if (G_keep_LED_flag == 0)  // set in DC_CHECK_AND_DO():  don't erase the pixel
		//{
	if (G_panel1_on == 1) { leds1[adr] = rgb; }
	if (G_panel2_on == 1) { leds2[tadr] = rgb; }
	if (G_panel3_on == 1) { leds3[adr] = rgb; }
	if (G_panel4_on == 1) { leds4[tadr] = rgb; }

	//}



	if (G_RAND_HUE == 1)
	{
		hue = random(0, 213);
	}

	// HSV (Rainbow) to RGB color conversion
	if (G_hue >= 0)
	{
		//		Serial.println(F("++++++++++++++++++++  XY_HANDLE: position 3"));
		CHSV hsv_color1(hue, 255, 255);
		hsv2rgb_rainbow(hsv_color1, rgb); // convert HSV to RGB
	}
	else
	{
		//		Serial.println(F("++++++++++++++++++++  XY_HANDLE: position 4"));

		CHSV hsv_color2(255, 255, 255); // white
		hsv2rgb_rainbow(hsv_color2, rgb); // convert HSV to RGB

		//Serial.print(F("white: rgb2.r="));
		//Serial.println(rgb.r);
		//Serial.print(F("white: rgb2.g="));
		//Serial.println(rgb.g);
		//Serial.print(F("white: rgb2.b="));
		//Serial.println(rgb.b);
		//Serial.print(F("white: hsv_color2.h="));
		//Serial.println(hsv_color2.h);
		//Serial.print(F("white: hsv_color2.s="));
		//Serial.println(hsv_color2.s);
		//Serial.print(F("white: hsv_color2.v="));
		//Serial.println(hsv_color2.v);
		//Serial.println("");

		rgb.r = 255;
		rgb.g = 255;
		rgb.b = 255;

	}

	adr = GET_XY_ADR(X, Y);
	tadr = modify_adr(0, 0, adr);


	if (G_panel1_on == 1) { leds1[adr] = rgb; }
	if (G_panel2_on == 1) { leds2[tadr] = rgb; }
	if (G_panel3_on == 1) { leds3[adr] = rgb; }
	if (G_panel4_on == 1) { leds4[tadr] = rgb; }

	//	Serial.println(F("++++++++++++++++++++  XY_HANDLE: position 5"));




	G_SKIP_BTCH = 1;  // this prevents a CRASH when in DOTs mode
	SHOW_slow();
	G_SKIP_BTCH = 0;  // restore operation of BTCH

	//	Serial.println(F("++++++++++++++++++++  XY_HANDLE: position 6"));


		//Serial.print(F("X="));
		//Serial.println(X);
		//Serial.print(F("Y="));
		//Serial.println(Y);
		//Serial.print(F("G_X="));
		//Serial.println(G_X);
		//Serial.print(F("G_Y="));
		//Serial.println(G_Y);
		//Serial.print(F("adr="));
		//Serial.println(adr);
		//Serial.print(F("G_hue="));
		//Serial.println(G_hue);
		//Serial.print(F("leds1[adr].r="));
		//Serial.println(leds1[adr].r);
		//Serial.print(F("leds1[adr].g="));
		//Serial.println(leds1[adr].g);
		//Serial.print(F("leds1[adr].b="));
		//Serial.println(leds1[adr].b);
		//Serial.println("");
		//Serial.print(F("rgb.r="));
		//Serial.println(rgb.r);
		//Serial.print(F("rgb.g="));
		//Serial.println(rgb.g);
		//Serial.print(F("rgb.b="));
		//Serial.println(rgb.b);

		//Serial.println("");

		//Serial.println(F("++++++++  leaving:    XY_HANDLE"));
		//Serial.println("");

		//LIGHT_LED(X, Y);
	G_X = X;
	G_Y = Y;



}


///////////////////////////////////////////////////
void DIM_SLOW_LEDS(byte dimming)
{
	// higher = more dimming
	//if (G_active == 1)  // if current set to FAST LEDs
	{
		SET_SLOW();
		//	G_active = 0;
	}

	//dimming = 255 - dimming;
	//FastLED.setBrightness(dimming);  // for this command higher values = higher brightness



	for (int n = 0; n < NUM_LEDS; ++n)  // first set to maximum G_brightness then dim
	{

		//FastLED.setBrightness(G_dim);

		leds1[n].maximizeBrightness();
		leds1[n].fadeLightBy(dimming); // Dim a color 

		leds2[n].maximizeBrightness();
		leds2[n].fadeLightBy(dimming); // Dim a color 

		leds3[n].maximizeBrightness();
		leds3[n].fadeLightBy(dimming); // Dim a color 

		leds4[n].maximizeBrightness();
		leds4[n].fadeLightBy(dimming); // Dim a color 
	}


}

///////////////////////////////////////////////////
void DIM_VAR_LEDS(byte dimming, int num)  // dim a variable number of LEDs
{
	// higher = more dimming



	for (int n = 0; n < num; ++n)  // first set to maximum G_brightness then dim
	{

		//FastLED.setBrightness(G_dim);

		leds1[n].maximizeBrightness();
		leds1[n].fadeLightBy(dimming); // Dim a color 

		leds2[n].maximizeBrightness();
		leds2[n].fadeLightBy(dimming); // Dim a color 

		leds3[n].maximizeBrightness();
		leds3[n].fadeLightBy(dimming); // Dim a color 

		leds4[n].maximizeBrightness();
		leds4[n].fadeLightBy(dimming); // Dim a color 
	}


}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
byte RING_with_IMAGE(int ringed_image1, int ringed_image2, byte ring_length, byte image_flag, byte depth, byte depth_effect)
{

	if ((G_Hall_sync == 0) || (digitalRead(HEAD_COM) == 1)) { return 0; }


	// return 1 if interrupted by BT command
	// ring the current display with the specified image number
	// if image_flag==0 then the image number refers to a FONT image 
	// if image_flag==1 then the image number refers to a saved image 
	// if image_flag==2 then the image number refers to a stored pre-made image
	// depth=how many layers to use in ring
	// depth_effects:  0=no effect, 1=inner columns shifted down by column number, 2=inner columns shifted up by column number, 3=alternate shift up and down

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
				//  ------> The following code shows the saved image to be ringed displayed <----------
					// note: the saved image can also be displayed in DO_SHOW with G_show_num =254

	// SIGNAL(42); // YELLOW signal

	delay(100); // this is needed for proper operation of 8way ring .... I don't know why...without this the 8way selection doesn't always work

	int previous_special_char_select = G_special_char_select;
	byte rv = 0;

	BMP_LOOKUP_ARRAY[0] = 0;
	BMP_LOOKUP_ARRAY[1] = 0;

	if (ring_length > 48) { ring_length = 48; }  // as a guard


	if (image_flag == 1)
	{
		G_special_char_select = ringed_image1 + 1000;  //define image to be displayed
		G_2nd_saved_image = ringed_image2 + 1000;
	}


	if (image_flag == 2)
	{
		G_special_char_select = 3000;  // flag that premade image to be displayed
		BMP_LOOKUP_ARRAY[0] = ringed_image1;
		BMP_LOOKUP_ARRAY[1] = ringed_image2;
	}


	//strcpy(scroll_text_array, "*%");
	//strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");  // 48 characters
	//strcpy(scroll_text_array, "#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^");  // 48 characters

	if (ringed_image2 > 0)
	{
		strcpy(scroll_text_array, "*%#^*%#^*%#^*%#^*%#^*%#^*%#^*%#^*%#^*%#^*%#^*%#^");  // 48 characters
		//	strcpy(scroll_text_array, "#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^#^");  // for debug only
	}

	if (ringed_image2 == 0)
	{
		strcpy(scroll_text_array, "*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%*%");  // 48 characters
	}
	//strcpy(scroll_text_array, "************************************************");


	//SCROLL_TEXT(scroll_text_array, ring_length, 1, 1, -1, 0, 1, depth, 0);
	rv = SCROLL_TEXT(scroll_text_array, ring_length, 1, 1, -1, 0, 1, depth, depth_effect);

	G_special_char_select = previous_special_char_select;

	G_2nd_saved_image = 0;  // prevents core crash in DISPLAY_TEXT_ARRAY after entire production completes and re-starts

	return rv;

	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
}


////////////////////////////////////////////////
int CALCULATED_MAX_FLASHES(int numleds)  // returns calculate G_max_flashes and G_max_bins based on number of LEDs
{
	int columns = numleds / 22;   // index

	//float scaler = float(G_startup_max_flashes) / float(stored_max_flashes[22]);
	float scaler = float(G_startup_max_flashes) / float(stored_max_flashes[2]);  // index of 2 is used as G_startup_max_flashes is measured with 2x22 number of LEDS

	G_max_flashes = int(scaler * float(stored_max_flashes[columns]));


	if (G_special_char_select < 1000)// note >1000 is for displaying leds_saved
	{
		G_max_bins = G_max_flashes / G_letter_width;  // keep track of maximum number of letter bins per 
	}
	else  // each leds_saved is 11 wide
	{
		G_max_bins = G_max_flashes / 11;  // keep track of maximum number of letter bins per 
	}

	if (G_max_bins % 2 != 0) //G_max_bins must be even or else panel 1,2 text do not align with panel 3,4 text....because panels 3,4 are offset by G_max_bins/2
	{
		++G_max_bins;
	}





	return G_max_flashes;
}

////////////////////////////////////////////////
int CALCULATED_MAX_BINS()  // returns calculate G_max_bins // added 070524
{

	if (G_special_char_select < 1000)// note >1000 is for displaying leds_saved
	{
		G_max_bins = G_max_flashes / G_letter_width;  // keep track of maximum number of letter bins per 
	}
	else  // each leds_saved is 11 wide
	{
		G_max_bins = G_max_flashes / 11;  // keep track of maximum number of letter bins per 
	}

	if (G_max_bins % 2 != 0) //G_max_bins must be even or else panel 1,2 text do not align with panel 3,4 text....because panels 3,4 are offset by G_max_bins/2
	{
		++G_max_bins;
	}


	return G_max_bins;
}

/////////////////////////////////////////////////////////
byte CALIBRATE_MAX_FLASHES(byte num2average)  // find max flashes by averaging and throwing out data that deviates far from norm
   //num2average = number of samples to take an average of
   // returns 1 if calibration fails because panels aren't rotating
{
	int sum = 0;
	//int num2average = 4;  // number of samples to take an average of
	int delta[4];
	int measurement[4];
	byte good_flag[4] = { 0,0,0,0 };
	int allowed_error = 4;
	byte count = 0;
	byte rv = 0; 

	for (int n = 0; n < num2average; ++n)  // make multiple measurments
	{
		rv = HALL_MEASURE2(2 * NUM_COLUMNS);  // find G_max_flashes for two columns
		measurement[n] = G_max_flashes;
		
		//SPACE
		//printD(" CALIBRATE_MAX_FLASHES: rv="), rv);
		//SPACE

		if (rv == 1) { return rv; }
	}

	for (int n = 0; n < num2average - 1; ++n)  // calculate delta between measurements
	{
		delta[n] = measurement[n] - measurement[n + 1];
	}

	for (int n = 0; n < num2average - 1; ++n)  // throw out bad data
	{
		if (abs(delta[n]) <= allowed_error)  // flag deltas with low error 
		{
			good_flag[n] = 1;
			good_flag[n + 1] = 1;
		}
	}

	for (int n = 0; n < num2average - 1; ++n)
	{
		if (good_flag[n] == 1)
		{
			sum = sum + measurement[n];
			++count;
		}
	}

	if (count > 0)  // don't devide by 0
	{
		G_startup_max_flashes = int(sum / count);  // take average
	}
	else
	{
		G_startup_max_flashes = G_max_flashes;
	}

	return 0;
}


///////////////////////////////////////////////////////////
//void CALIBRATE_MAX_FLASHES()  // find max flashes by averaging
//{
//	int sum = 0;
//	int num2average = 3;  // number of samples to take an average of
//
//	for (int n = 0; n < num2average; ++n)  // find average of G_startup_max_flashes
//	{
//		G_startup_max_flashes = HALL_MEASURE2(2 * NUM_COLUMNS);  // find G_max_flashes for two columns
//
//		sum = sum + (G_startup_max_flashes);
//	}
//
//	G_startup_max_flashes = int(sum / num2average);
//}


////////////////////////////////////////////////////////////////////////
//void VROLL_BEAT(int beat, int magnitude, int pitch)  // generate a verticle roll every beat
//{
//	// magnitude is between 0 and 255
//	
//	byte num2roll = byte(float(NUM_ROWS) * float(magnitude / 255));
//	
//	ROLL_VERT(num2roll);
//
//
//}



///////////////////////////////////////////////////////////////////////
void BOUNCE_X(int bounce_speed_multiplier, int wall_1, int wall_2)
// move all LEDs according to their bounce[] array value multiplied by the bounce_speed_multiplier.
// if a wall is hit then the bounce direction is reversed
// default walls exist at x=0 and x=NUM_COLUMNS -1 
{
	int adr = 0;
	int bounce_adr = 0;
	int new_x = 0;
	byte wall_flag = 0;
	int current_bounce = 0;
	int new_bounce = 0;
	int adr2 = 0;
	byte non_zero = 0;


	for (int n = 0; n < NUM_LEDS; ++n)
	{
		leds_saved[0][n] = 0; // clear array
	}

	for (int y = 0; y < NUM_ROWS; ++y)
	{
		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			adr = XY_ADR(x, y);
			current_bounce = bounce_speed_multiplier * bounce[adr];

			non_zero = 0;
			if (leds1[adr].r > 0) { non_zero = 1; }
			if (leds1[adr].g > 0) { non_zero = 1; }
			if (leds1[adr].b > 0) { non_zero = 1; }

			if ((current_bounce == 0) && (non_zero > 0)) // no bounce
			{
				leds_saved[0][adr] = leds1[adr];
			}

			/////////////////////////////
			if ((current_bounce > 0) && (non_zero > 0)) // positive bounce
			{
				new_x = x + current_bounce;

				new_bounce = bounce[adr];  // copy previous bounce into new location

				//Serial.println("");
				//Serial.println(F("START of DO_SHOW2"));

				if (new_x >= NUM_COLUMNS) // check for exceeding maximum x 
				{
					new_x = x - (new_x - NUM_COLUMNS);
					bounce_adr = XY_ADR(new_x, y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((x < wall_1) && (new_x >= wall_1) && (wall_1 > 0)) // wall_1 crossed
				{
					new_x = x - (new_x - wall_1);
					bounce_adr = XY_ADR(new_x, y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((x < wall_2) && (new_x >= wall_2) && (wall_2 > 0)) // wall_2 crossed
				{
					new_x = x - (new_x - wall_2);
					bounce_adr = XY_ADR(new_x, y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				bounce_adr = XY_ADR(new_x, y);
				bounce[bounce_adr] = new_bounce;  // copy previous bounce into new location


				leds_saved[0][bounce_adr] = leds1[adr];  // leds_saved = bounced temporary storage
			}

			///////////////////////////////
			if ((current_bounce < 0) && (non_zero > 0)) // negative bounce
			{
				new_x = x + current_bounce;

				new_bounce = bounce[adr];  // copy previous bounce into new location

				if (new_x < 0) // check for exceeding maximum x 
				{
					new_x = x - new_x;
					bounce_adr = XY_ADR(new_x, y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((x > wall_1) && (new_x <= wall_1) && (wall_1 > 0)) // wall_1 crossed
				{
					new_x = x + (wall_1 - new_x);
					bounce_adr = XY_ADR(new_x, y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((x > wall_2) && (new_x <= wall_2) && (wall_2 > 0)) // wall_2 crossed
				{
					new_x = x + (wall_2 - new_x);
					bounce_adr = XY_ADR(new_x, y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				bounce_adr = XY_ADR(new_x, y);
				bounce[bounce_adr] = new_bounce;  // copy previous bounce into new location


				leds_saved[0][bounce_adr] = leds1[adr];  // leds_saved = bounced temporary storage
			}

		}
	}

	for (int n = 0; n < NUM_LEDS; ++n)  // copy leds_saved to leds
	{

		leds1[n] = leds_saved[0][n];
		leds3[n] = leds_saved[0][n];

		adr2 = modify_adr(0, 0, n);

		leds2[adr2] = leds_saved[0][n];
		leds4[adr2] = leds_saved[0][n];


	}
}

///////////////////////////////////////////////////////////////////////
void BOUNCE_Y(int bounce_speed_multiplier, int wall_1, int wall_2)
// move all LEDs according to their bounce[] array value multiplied by the bounce_speed_multiplier.
// if a wall is hit then the bounce direction is reversed
// default walls exist at y=0 and y=NUM_ROWS -1 
{
	int adr = 0;
	int bounce_adr = 0;
	int new_y = 0;
	byte wall_flag = 0;
	int current_bounce = 0;
	int new_bounce = 0;
	int adr2 = 0;
	byte non_zero = 0;


	for (int n = 0; n < NUM_LEDS; ++n)
	{
		leds_saved[0][n] = 0; // clear array
	}

	for (int y = 0; y < NUM_ROWS; ++y)
	{
		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			adr = XY_ADR(x, y);
			current_bounce = bounce_speed_multiplier * bounce[adr];

			non_zero = 0;
			if (leds1[adr].r > 0) { non_zero = 1; }
			if (leds1[adr].g > 0) { non_zero = 1; }
			if (leds1[adr].b > 0) { non_zero = 1; }

			if ((current_bounce == 0) && (non_zero > 0)) // no bounce
			{
				leds_saved[0][adr] = leds1[adr];
			}

			/////////////////////////////
			if ((current_bounce > 0) && (non_zero > 0)) // positive bounce
			{
				new_y = y + current_bounce;

				new_bounce = bounce[adr];  // copy previous bounce into new location

				//Serial.println("");
				//Serial.println(F("START of DO_SHOW2"));

				if (new_y >= NUM_ROWS) // check for exceeding maximum x 
				{
					new_y = y - (new_y - NUM_ROWS);
					bounce_adr = XY_ADR(x, new_y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((y < wall_1) && (new_y >= wall_1) && (wall_1 > 0)) // wall_1 crossed
				{
					new_y = y - (new_y - wall_1);
					bounce_adr = XY_ADR(x, new_y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((y < wall_2) && (new_y >= wall_2) && (wall_2 > 0)) // wall_2 crossed
				{
					new_y = y - (new_y - wall_2);
					bounce_adr = XY_ADR(x, new_y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				bounce_adr = XY_ADR(x, new_y);
				bounce[bounce_adr] = new_bounce;  // copy previous bounce into new location


				leds_saved[0][bounce_adr] = leds1[adr];  // leds_saved = bounced temporary storage
			}

			///////////////////////////////
			if ((current_bounce < 0) && (non_zero > 0)) // negative bounce
			{
				new_y = y + current_bounce;

				new_bounce = bounce[adr];  // copy previous bounce into new location

				if (new_y < 0) // check for exceeding maximum x 
				{
					new_y = y - new_y;
					bounce_adr = XY_ADR(x, new_y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((y > wall_1) && (new_y <= wall_1) && (wall_1 > 0)) // wall_1 crossed
				{
					new_y = y + (wall_1 - new_y);
					bounce_adr = XY_ADR(x, new_y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((y > wall_2) && (new_y <= wall_2) && (wall_2 > 0)) // wall_2 crossed
				{
					new_y = y + (wall_2 - new_y);
					bounce_adr = XY_ADR(x, new_y);
					new_bounce = -1 * bounce[adr];  // reverse direction

				}

				bounce_adr = XY_ADR(x, new_y);
				bounce[bounce_adr] = new_bounce;  // copy previous bounce into new location


				leds_saved[0][bounce_adr] = leds1[adr];  // leds_saved = bounced temporary storage
			}

		}
	}

	for (int n = 0; n < NUM_LEDS; ++n)  // copy leds_saved to leds
	{

		leds1[n] = leds_saved[0][n];
		leds3[n] = leds_saved[0][n];

		adr2 = modify_adr(0, 0, n);

		leds2[adr2] = leds_saved[0][n];
		leds4[adr2] = leds_saved[0][n];


	}
}


/////////////////////////////////////////////////////////////////////
void SET_BOUNCE_ARRAY(int8_t magnitude)  // set the bounce array
{
	for (int n = 0; n < NUM_LEDS; ++n)
	{
		bounce[n] = magnitude;
	}
}


/////////////////////////////////////////////////////////////////////
void SET_BOUNCE_ARRAY_X(int xstart, int xend, int value)  // clear portions of the bounce array
// note xend must be > xstart
// value to set
{
	int bounce_adr = 0;

	for (int y = 0; y < NUM_ROWS; ++y)
	{
		for (int x = xstart; x <= xend; ++x)
		{
			bounce_adr = XY_ADR(x, y);

			bounce[bounce_adr] = value;
		}
	}
}

///////////////////////////////////////////////////////////////////////
void ROLL_X(int bounce_speed_multiplier, int wall_1, int wall_2)
// move all LEDs according to their bounce[] array value multiplied by the bounce_speed_multiplier.
// if a wall is hit then the LED rolls to the wall it was movinag away from and continues in the same direction
// default walls exist at x=0 and x=NUM_COLUMNS -1 
// NOTE: wall_2 must be greater (in X) than wall_1. ALSO if wall_2 exists then wall_1 must also.

{
	int adr = 0;
	int bounce_adr = 0;
	int new_x = 0;
	byte wall_flag = 0;
	int current_bounce = 0;
	int new_bounce = 0;
	int adr2 = 0;
	byte non_zero = 0;


	for (int n = 0; n < NUM_LEDS; ++n)
	{
		leds_saved[0][n] = 0; // clear array
	}

	for (int y = 0; y < NUM_ROWS; ++y)
	{
		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			adr = XY_ADR(x, y);
			current_bounce = bounce_speed_multiplier * bounce[adr];

			non_zero = 0;
			if (leds1[adr].r > 0) { non_zero = 1; }
			if (leds1[adr].g > 0) { non_zero = 1; }
			if (leds1[adr].b > 0) { non_zero = 1; }

			if ((current_bounce == 0) && (non_zero > 0)) // no bounce
			{
				leds_saved[0][adr] = leds1[adr];
			}

			/////////////////////////////
			if ((current_bounce > 0) && (non_zero > 0)) // positive bounce
			{
				new_x = x + current_bounce;

				//new_bounce = bounce[adr];  // copy previous bounce into new location

				//Serial.println("");
				//Serial.println(F("START of DO_SHOW2"));

				if (new_x >= NUM_COLUMNS - 1) // check for exceeding maximum x 
				{
					//new_x = x - (new_x - NUM_COLUMNS);

					if (wall_2 > 0)
					{
						new_x = wall_2 + 1;
					}
					else
						if (wall_1 > 0)
						{
							new_x = wall_1 + 1;
						}
						else
						{
							new_x = 0;
						}

					//bounce_adr = XY_ADR(new_x, y);
					//new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((x < wall_1) && (new_x >= wall_1) && (wall_1 > 0)) // wall_1 crossed
				{
					new_x = 0;
					//bounce_adr = XY_ADR(new_x, y);
					//new_bounce = -1 * bounce[adr];  // reverse direction

				}

				if ((x < wall_2) && (new_x >= wall_2) && (wall_2 > 0)) // wall_2 crossed
				{


					new_x = wall_1 + 1;
					//bounce_adr = XY_ADR(new_x, y);
					//new_bounce = -1 * bounce[adr];  // reverse direction

				}

				bounce_adr = XY_ADR(new_x, y);
				//bounce[bounce_adr] = new_bounce;  // copy previous bounce into new location


				leds_saved[0][bounce_adr] = leds1[adr];  // leds_saved = bounced temporary storage
			}

			///////////////////////////////
			if ((current_bounce < 0) && (non_zero > 0)) // negative bounce
			{

				new_x = x + current_bounce;

				//new_bounce = bounce[adr];  // copy previous bounce into new location

				if (new_x < 0) // check for exceeding maximum x 
				{
					if (wall_1 > 0)
					{
						new_x = wall_1 - 1;
						//bounce_adr = XY_ADR(new_x, y);
					//	new_bounce = -1 * bounce[adr];  // reverse direction
					}
					else
					{
						new_x = NUM_COLUMNS - 1;
					}

				}

				//Serial.println("");
				//Serial.print(F("ROLL_X   1:  x="));
				//Serial.println(x);
				//Serial.print(F("new_x="));
				//Serial.println(new_x);

				//Serial.println("");


				if ((x > wall_1) && (new_x <= wall_1) && (wall_1 > 0)) // wall_1 crossed
				{
					if (wall_2 > 0)
					{
						new_x = wall_2;
					}
					else
					{
						new_x = NUM_COLUMNS - 1;
					}


					//bounce_adr = XY_ADR(new_x, y);
					//new_bounce = -1 * bounce[adr];  // reverse direction

				}

				//Serial.println("");
				//Serial.print(F("ROLL_X   2: new_x="));
				//Serial.println(new_x);
				//Serial.println("");

				if ((x > wall_2) && (new_x <= wall_2) && (wall_2 > 0)) // wall_2 crossed
				{
					new_x = NUM_COLUMNS - 1;
					//bounce_adr = XY_ADR(new_x, y);
					//new_bounce = -1 * bounce[adr];  // reverse direction

				}

				bounce_adr = XY_ADR(new_x, y);
				//bounce[bounce_adr] = new_bounce;  // copy previous bounce into new location


				leds_saved[0][bounce_adr] = leds1[adr];  // leds_saved = bounced temporary storage
			}

		}
	}

	for (int n = 0; n < NUM_LEDS; ++n)  // copy leds_saved to leds
	{

		leds1[n] = leds_saved[0][n];
		leds3[n] = leds_saved[0][n];

		adr2 = modify_adr(0, 0, n);

		leds2[adr2] = leds_saved[0][n];
		leds4[adr2] = leds_saved[0][n];


	}
}


/////////////////////////////////////////////////////////////////////
void CREATE_RANDOM_IMAGES(int kind, int num_objects)
// create random image to be used TRANSLATE_X and TRANSLATE_Y
// kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle

{
	int max_radius = 7;  // sets maximum radius

	FastLED.clear();

	if (num_objects > MAX_NUMBER_IMAGES_to_TWEEN) { num_objects = MAX_NUMBER_IMAGES_to_TWEEN; }  // guard against array overflow

	for (int n = 0; n < num_objects; ++n)  // sets the number of things drawn
	{
		int hue = random(0, 213);

		//	HUE_IMAGE[n] = hue;

		G_X = random(0, NUM_COLUMNS - 1);
		G_Y = random(0, NUM_ROWS - 1);



		if (kind != 2)  // not a circle
		{
			G_X_previous = random(0, NUM_COLUMNS - 1);
			G_Y_previous = random(0, NUM_ROWS - 1);

			//// store randomly generated XY pairs for use with X_TRANSLATE and Y_TRANSLATE
			//XE[n] = G_X_previous;
			//XS[n] = G_X;
			//YE[n] = G_Y_previous;
			//YS[n] = G_Y;


		}
		else  // chose a maximum radius for a circle
		{
			int radius = random(max_radius);  // sets maximum radius
			int next_x = G_X + radius;

			if (next_x >= NUM_COLUMNS)
			{
				next_x = abs(G_X - radius);
			}
			G_X_previous = next_x;
			G_Y_previous = G_Y;

		}


		/////////
		if (kind == 1)  // line
		{
			//LINE(G_X_previous, G_Y_previous, G_X, G_Y, hue);
			LINE(G_X, G_Y, G_X_previous, G_Y_previous, hue);
		}

		///////

		if (kind == 2) // circle
		{



			// calculate radius
			int delta_X = (int)G_X - (int)G_X_previous;
			int delta_Y = (int)G_Y - (int)G_Y_previous;

			int radius = sqrt((delta_X * delta_X) + (delta_Y * delta_Y));

			CIRCLE((double)radius, G_X_previous, G_Y_previous, hue);

			// store randomly generated XY pairs for use with X_TRANSLATE and Y_TRANSLATE
			//XS[n] = G_X_previous;
			//YS[n] = G_Y_previous;
			//XE[n] = byte(abs(delta_X));
			//YE[n] = byte(abs(delta_Y));

		}

		///
		if (kind == 3)   // RECTANGLE mode
		{

			RECTANGLE(G_X, G_Y, G_X_previous, G_Y_previous, hue);

		}

		/////////////////
		if (kind == 4)   // TRIANGLE mode
		{

			TRIANGLE(G_X, G_Y, G_X_previous, G_Y_previous, hue);

		}

	}
}


////////////////////////////////////////////////////////////////////
//void AUTO_DIM()  // dim slow leds with G_AUTO_DIM_LEVEL
//{
//	if ((G_AUTO_DIM == 1) && (G_AUTO_DIM_LEVEL > G_dim)) // only dim SLOW leds more if auto dim level is more than G_dim
//	{
//		DIM_SLOW_LEDS(G_AUTO_DIM_LEVEL);  // dim SLOW leds
//		FastLED.show();
//	}
//}


///////////////////////////////////
void MODIFY_GUI4(byte element)  // force some GUI3 elements to be in the correct state
{
	if (G_GUI != 4) { return; }

	String BT_string2send = "";

	if (element == 1)  // set to ON position for the PRODUCTION switch
	{

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(7, 4)");
		SerialBT.println("add_switch(7,4,3,zV@,zW@,0,1)");


	}


	if (element == 2)  // set to OFF position for the PRODUCTION switch
	{

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(7, 4)");
		SerialBT.println("add_switch(7,4,3,zV@,zW@,0,0)");


	}


	if (element == 3)  // set to ON position for the SHOW lock switch
	{

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(13, 4)");
		SerialBT.println("add_switch(13,4,3,zX@,zY@,0,1)");

	}



	if (element == 4)  // set to OFF position for the SHOW lock switch
	{

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(13, 4)");
		SerialBT.println("add_switch(13,4,3,zX@,zY@,0,0)");


	}


	if (element == 6)  // turn ON BT active indicator
	{
		BT_string2send = "*HR0G0B255*";  // turn BT indicator BLUE
		SerialBT.print(BT_string2send);  // send to GUI
	}


	if (element == 7)  // turn OFF BT active indicator
	{
		BT_string2send = "*HR0G0B0*";  // turn BT indicator BLACK
		SerialBT.print(BT_string2send);  // send to GUI
	}



	if (element == 8)  // set to ON position for the MIC enable switch  8
	{

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(2, 4)");
		SerialBT.println("add_switch(2,4,3,zzm@,zzn@,0,1)");

		//G_MIC_ON_flag = 1;

	}


	if (element == 9)  // set to OFF position for the MIC enable switch  9
	{

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(2, 4)");
		SerialBT.println("add_switch(2,4,3,zzm@,zzn@,0,0)");

		//G_MIC_ON_flag = 0;


	}


	if (element == 10)  // set MIC gain slider
	{

		int gain = int(100 * G_MIC_gain);
		String gain_string = String(gain);

		SerialBT.print("*O");  // update GUI4 text for MIC gain
		SerialBT.print(gain);
		SerialBT.print("*");

		BT_string2send = "add_slider(18,6,1,0,100," + gain_string + ", zzq, @,1)";

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(18, 6)");
		SerialBT.print(BT_string2send);  // send to GUI


		//Serial.println("++++++++++++++++MIC SLIDER:"  + BT_string2send);
		//Serial.println("");

	}

	if (element == 11)  // turn ON MUSIC DETECT indicator
	{
		BT_string2send = "*PR255G255B0*";  // turn indicator YELLOW
		SerialBT.print(BT_string2send);  // send to GUI
	}


	if (element == 12)  // turn OFF MUSIC DETECT indicator
	{
		BT_string2send = "*PR0G0B0*";  // turn  indicator BLACK
		SerialBT.print(BT_string2send);  // send to GUI
	}

	if (element == 13)  // turn ON HEAD COM indicator
	{
		BT_string2send = "*QR0G255B255*";  // turn indicator CYAN
		SerialBT.print(BT_string2send);  // send to GUI
	}


	if (element == 14)  // turn OFF HEAD COM indicator
	{
		BT_string2send = "*QR0G0B0*";  // turn  indicator BLACK
		SerialBT.print(BT_string2send);  // send to GUI
	}


	if (element == 15)  // turn ON SOUND DETECT indicator
	{
		BT_string2send = "*RR0G255B255*";  // turn  indicator CYAN
		SerialBT.print(BT_string2send);  // send to GUI
	}


	if (element == 16)  // turn OFF SOUND DETECT indicator
	{
		BT_string2send = "*RR0G0B0*";  // turn  indicator CYAN
		SerialBT.print(BT_string2send);  // send to GUI
	}

	if (element == 17)
	{

		if (G_MUSIC_detected_flag == 0)  // MUSIC not detected
		{
			MODIFY_GUI4(12); // turn off MUSIC DETECT indicator

		}
		else  // MUSIC detected
		{
			MODIFY_GUI4(11); // turn on MUSIC DETECT indicator
		}



	}

	if (element == 18)  // update production number
	{
		SerialBT.print("*I");  // update production number
		SerialBT.print(G_production);
		SerialBT.print("*");
	}

	if (element == 19)  // update production number
	{
		SerialBT.print("*!");
		SerialBT.print(G_show_num);
		SerialBT.print("*");
	}

	if (element == 20)  // turn on MUSIC ONLY MODE switch
	{
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(18, 7)");
		SerialBT.println("add_switch(18,7,2,zzr@,zzs@,0,1)");
	}

	if (element == 21)  // turn off MUSIC ONLY MODE switch
	{
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(18, 7)");
		SerialBT.println("add_switch(18,7,2,zzr@,zzs@,0,0)");
	}



}

///////////////////////////////////
void MODIFY_GUI3(byte element)  // force some GUI3 elements to be in the correct state
{
	String BT_string2send = "";

	if (G_GUI != 3) { return; }

	if (element == 1)  // modify brightness slider control position
	{
		
		int slider_level = 0;

		// set BRIGHTNESS control
		if (G_dim > 126)
		{
			slider_level = 511 - (3 * (G_dim - 84));  //1 is min. value.   reverse of dimming equation found in BLUE_TOOTH_COMMAND_HANDLER
		    
			if (slider_level < 1) { slider_level = 1; }  // as a precaution if G_dim = 255; 1 is min. value.
		
		}
		else
		{
			slider_level = 510 - G_dim;  // 510 = max slider value
		}

		

		String brightness = String(slider_level);
		String output = String("add_slider(18,13,1,1,510," + brightness + ", q, @,1)");

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(18, 13)");
		SerialBT.println(output);
		SerialBT.println("*");

		//Serial.println(F(""));
		//Serial.print(F("MODIFY_GUI3(1): G_dim ="));
		//Serial.println(G_dim);
		//Serial.print(F("slider_level ="));
		//Serial.println(slider_level);
		//Serial.print(F("brightness ="));
		//Serial.println(brightness);
		//Serial.println(F(""));

		delay(100);         // added 6/16/24 to prevent erronious q command that changes G_dim
		FLUSH_BT_BUFFER();  // added 6/16/24 to prevent erronious q command that changes G_dim

	}

	//if (element == 2) // turn on CREATE mode switch
	//{
	//	// turn on CREATE mode switch
	//	SerialBT.println("*.kwl");
	//	//SerialBT.println("clear_location(21, 9)");
	//	SerialBT.println("clear_location(21, 10)");
	//	SerialBT.println("add_switch(21,10,1,K@,L@,0,1)");
	//	SerialBT.println("*");



	//}

	if (element == 3)
	{
		// turn off 'PLAY SAVES' switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(2, 9)");
		SerialBT.println("add_switch(2,9,1,zzN@,zzO@,0,0)");
		SerialBT.println("*");


	}

	if (element == 4)
	{
		//update geometery slider text
		String BT_string2send;

		switch (G_geometery)
		{
		case 0:
			BT_string2send = "*SLINE*";
			SerialBT.print(BT_string2send);  // send to GUI
			BT_string2send = "*E[ TOUCH 2 POINTS ]*";
			SerialBT.print(BT_string2send);  // send to GUI
			break;
		case 1:
			BT_string2send = "*SDOTS*";
			SerialBT.print(BT_string2send);  // send to GUI
			BT_string2send = "*E[ TOUCH 1 POINT & DRAG ]*";
			SerialBT.print(BT_string2send);  // send to GUI
			break;
		case 2:
			BT_string2send = "*SCIRCLES*";
			SerialBT.print(BT_string2send);  // send to GUI
			BT_string2send = "*E[ TOUCH 2 POINTS ]*";
			SerialBT.print(BT_string2send);  // send to GUI
			break;
		case 3:
			BT_string2send = "*SRECTANGLES*";
			SerialBT.print(BT_string2send);  // send to GUI
			BT_string2send = "*E[ TOUCH 2 POINTS ]*";
			SerialBT.print(BT_string2send);  // send to GUI
			break;
		case 4:
			BT_string2send = "*STRIANGLES*";
			SerialBT.print(BT_string2send);  // send to GUI
			BT_string2send = "*E[ TOUCH 2 POINTS ]*";
			SerialBT.print(BT_string2send);  // send to GUI
			break;
		default:
			// statements
			break;
		}
	}

	if (element == 5)
	{
		// turn off RANDOM HUE switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(15, 1)");
		SerialBT.println("add_switch(15,1,2,zR@,zS@,0,0)"); ////  off
		SerialBT.println("*");

		G_RAND_HUE = 0;

	}

	if (element == 6)  // turn ON BT active indicator
	{
		BT_string2send = "*HR0G255B0*";  // turn BT indicator GREEN
		SerialBT.print(BT_string2send);  // send to GUI
	}

	if (element == 7)  // turn OFF BT active indicator
	{
		BT_string2send = "*HR0G0B0*";  // turn BT indicator BLACK
		SerialBT.print(BT_string2send);  // send to GUI
	}

	//SerialBT.println("add_slider(0,9,3,0,4,1,g,@,1)");
	//String dimming = String(slider_level);
	//String output = String("add_slider(18,13,1,1,510," + dimming + ", q, @,1)");

	//SerialBT.println("*.kwl");
	//SerialBT.println("clear_location(18, 13)");
	//SerialBT.println(output);
	//SerialBT.println("*");

	if (element == 8)
	{
		//update geometery slider 

		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(0, 9)");
		String geometry = String(G_geometery);

		String output = String("add_slider(0,9,3,0,4," + geometry + ", g, @,1)");
		SerialBT.println(output);
		SerialBT.println("*");

	}

	if (element == 9)
	{
		// turn ON random HUE switch
		SerialBT.println("*.kwl");
		SerialBT.println("clear_location(15, 1)");
		SerialBT.println("add_switch(15,1,2,zR@,zS@,0,1)");
		SerialBT.println("*");


	}



	//delay(500);
	//FLUSH_BT_BUFFER();  // added 6/16/24 to prevent erronious q command that changes G_dim

}

///////////////////////////////////////////////////////
byte BT_DELAY_FILTER()  // filter out multiple fast BT transfers  // return 1 if BT was flushed
{

	unsigned long current_time = millis();
	unsigned long delta = current_time - G_system_time;
	unsigned long delay = 500;  //minimum acceptable time between BT commands,  was 500

	//Serial.println(F("++++  BT_DELAY_FILTER:  START"));

	//G_BT_previous_command

	//if ((G_BT_command == 'J')&&(G_geometery==1))  // send mouse pad ,  G_geometery=1=dots
	//if ((G_BT_command == 'J') || (G_BT_previous_command == 'J'))   // send mouse pad ,  G_geometery=1=dots
	//if (((G_BT_command == 'J') || (G_BT_previous_command == 'J')) && (G_geometery == 1))  // send mouse pad ,  G_geometery=1=dots
	
	if ((((G_BT_command == 'J') || (G_BT_previous_command == 'J')) && (G_geometery == 1)) || ((G_BT_command3 == 'Q') || (G_BT_previous_command3 == 'Q'))) // send mouse pad ,  G_geometery=1=dots
		//NOTE: J=mouse pad,  Q=8way CYCLE:  above exceptions made to BT filter to allow proper operation of mouse pad and 8way CYCLE
	{
		return 0;
	}

	//Serial.println(F("++++  BT_DELAY_FILTER:  position 2"));

	if ((G_BT_command == 'J') || (G_BT_previous_command == 'J'))
	{
		delay = 175;  // this delay is finely tuned and can not be less than 175 or else you risk a crash when dragging finger in all but DOTs mode
	}

	

	//int amount_of_BT = SerialBT.available();

	//Serial.print(F("++++  BT_DELAY_FILTER:  SerialBT.available()="));
	//Serial.println(amount_of_BT);

	// return 1 if BT was flushed
	if (SerialBT.available())
	{

		current_time = millis();
		delta = current_time - G_system_time;
		byte incomingByte;

		G_system_time = millis();  // added 4/16/22

		if (delta < delay)
		{
			//Serial.println(F("++++  BT_DELAY_FILTER:  before WHILE"));

			FLUSH_BT_BUFFER();

			//Serial.print(F("++++  BT_DELAY_FILTER: after WHILE:  SerialBT.available()="));
			//Serial.println(SerialBT.available());

			return 1;
		}
	}

	//Serial.println(F("++++  BT_DELAY_FILTER:  END"));

	return 0;
}

//////////////////////////////////////////////////////////////////////
int GET_RINGED_IMAGE()   // return the ringed image number
{
	byte preorder[maximum_number_of_SAVED_images] = { 0,0,0,0,0 };   // used to help order of display of G_SAVED[] images 
	byte order[maximum_number_of_SAVED_images] = { 0,0,0,0,0 };   // sets order of display of G_SAVED[] images 
	byte order_index = 0;

	/////////////// set the order array ////////
	for (byte n = 1; n < maximum_number_of_SAVED_images + 1; ++n)  // fill preorder array
	{
		if (G_SAVED[n] != 0)  // a valid image
		{
			preorder[order_index] = n;
			++order_index;

		}

	}

	byte n = 0;

	// the below fills the order array with saved images with some repeating if there are less then 5
	if (order_index > 0)
	{
		while (n < 5)
		{
			for (byte k = 0; k < order_index; ++k)
			{
				order[n] = preorder[k];  // note order array has repeats of preorder array
				++n;

				if (n >= 5)
				{
					break;  // exit for loop and also force exit of while loop
				}
			}
		}
	}


	//
	//Serial.println("");
	//Serial.println("");
	//Serial.println(F("+++++++GET_RINGED_IMAGE: 1 "));
	//for (byte n = 0; n < 5; ++n)
	//{
	//	Serial.print(F("order["));
	//	Serial.print(n);
	//	Serial.print(F("]="));
	//	Serial.println(order[n]);
	//}

	//Serial.println("");


	///////////////////////////////////////////



	G_special_saved_flag = 0;

	if (G_special_slider < 6)
	{
		switch (G_special_slider)
		{
		case 0:

			if (G_GUI != 3)
			{
				CONTINUOUS_SPECIAL_MODE_OFF();
			}
			else
			{
				G_special = '*';
			}
			break;
		case 1:
			G_special = '*';
			break;
		case 2:
			G_special = '%';
			break;
		case 3:
			G_special = '#';
			break;
		case 4:
			G_special = '^';
			break;
		case 5:
			G_special = '~';
			break;
		default:

			// if nothing else matches, do the default
			// default is optional
			G_special = '*';
			break;
		}
	}


	G_special_char_select = 1;



	if (G_special_slider > 5)  // select a G_SAVED image ... both halfs
	{

		order_index = G_special_slider - 6;  // ordered images are from 0 to 4 with G_special_slider from 6 to 10

		if (order[order_index] != 0)  // a valid image
		{
			G_special_char_select = 1000 + order[order_index];


			G_special_saved_flag = 1;  // use leds_saved '*' and '%'  both
		}



		//Serial.println("");
		//Serial.println(F("+++++++GET_RINGED_IMAGE: 2 "));
		//Serial.print(F("G_special_slider="));
		//Serial.println(G_special_slider);
		//Serial.print(F("G_special_char_select="));
		//Serial.println(G_special_char_select);
		//Serial.println("");
		//for (byte n = 0; n < 7; ++n)
		//{
		//	Serial.print(F("G_SAVED["));
		//	Serial.print(n);
		//	Serial.print(F("]="));
		//	Serial.println(G_SAVED[n]);
		//}
		//
		//Serial.println("");



		if (G_special_saved_flag == 0) // no saved images found so use a built in image
		{
			switch (G_special_slider - 5)
			{
			case 0:
				CONTINUOUS_SPECIAL_MODE_OFF();
				break;
			case 1:
				G_special = '*';
				break;
			case 2:
				G_special = '%';
				break;
			case 3:
				G_special = '#';
				break;
			case 4:
				G_special = '^';
				break;
			case 5:
				G_special = '~';
				break;
			default:

				// if nothing else matches, do the default
				// default is optional
				break;
			}
		}


	}

	return G_special_char_select;
}

////////////////////////////////////////////////////////////////////
void DISPLAY_RESET_IMAGE(byte img)  // show the RESET image
{
	int tadr = 0;

	SET_SLOW();

	if (img != 3)  // img 3 is a alignment image used in TEST mode
	{
		CLEAR_ALL_LEDS();
	}

	SHOW_slow();

	if (img == 1)  // image shown in SETUP
	{
		leds1[tadr].r = 255;  // 
		leds1[tadr].g = 0;
		leds1[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds2[tadr].r = 255;  // 
		leds2[tadr].g = 0;  // 
		leds2[tadr].b = 0;  // 

		tadr = 0;

		leds3[tadr].r = 255;  // 
		leds3[tadr].g = 0;
		leds3[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds4[tadr].r = 255;  // 
		leds4[tadr].g = 0;  // 
		leds4[tadr].b = 0;  // 

		tadr = 21;

		leds1[tadr].r = 255;  // 
		leds1[tadr].g = 255;
		leds1[tadr].b = 255;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds2[tadr].r = 255;  // 
		leds2[tadr].g = 255;  // 
		leds2[tadr].b = 255;  // 

		tadr = 21;

		leds3[tadr].r = 255;  // 
		leds3[tadr].g = 255;
		leds3[tadr].b = 255;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds4[tadr].r = 255;  // 
		leds4[tadr].g = 255;  // 
		leds4[tadr].b = 255;  // 
	}

	if (img == 2)  // image shown in RESET()
	{

		leds1[tadr].r = 0;  // 
		leds1[tadr].g = 0;
		leds1[tadr].b = 255;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds2[tadr].r = 0;  // 
		leds2[tadr].g = 0;  // 
		leds2[tadr].b = 255;  // 

		tadr = 0;

		leds3[tadr].r = 0;  // 
		leds3[tadr].g = 0;
		leds3[tadr].b = 255;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds4[tadr].r = 0;  // 
		leds4[tadr].g = 0;  // 
		leds4[tadr].b = 255;  // 

		tadr = 21;

		leds1[tadr].r = 0;  // 
		leds1[tadr].g = 255;
		leds1[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds2[tadr].r = 0;  // 
		leds2[tadr].g = 255;  // 
		leds2[tadr].b = 0;  // 

		tadr = 21;

		leds3[tadr].r = 0;  // 
		leds3[tadr].g = 255;
		leds3[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds4[tadr].r = 0;  // 
		leds4[tadr].g = 255;  // 
		leds4[tadr].b = 0;  // 


	}

	if (img == 3)   // test image to check panel alignment
	{
		leds1[tadr].r = 0;  // 
		leds1[tadr].g = 255;
		leds1[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds2[tadr].r = 0;  // 
		leds2[tadr].g = 255;  // 
		leds2[tadr].b = 0;  // 

		///////////////////////////
		tadr = 0;

		leds3[tadr].r = 255;  // 
		leds3[tadr].g = 0;
		leds3[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds4[tadr].r = 255;  // 
		leds4[tadr].g = 0;  // 
		leds4[tadr].b = 0;  // 

		///////////////////////////////

		tadr = 21;

		leds1[tadr].r = 0;  // 
		leds1[tadr].g = 255;
		leds1[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds2[tadr].r = 0;  // 
		leds2[tadr].g = 255;  // 
		leds2[tadr].b = 0;  // 

		//////////////////////////////////////

		tadr = 21;

		leds3[tadr].r = 255;  // 
		leds3[tadr].g = 0;
		leds3[tadr].b = 0;

		tadr = modify_adr(0, 0, tadr);   //make image right side up or upside down
		leds4[tadr].r = 255;  // 
		leds4[tadr].g = 0;  // 
		leds4[tadr].b = 0;  // 

		////// innner lights ///////////
		int adr = 483;
		int led_adr = 0;

		leds1[adr].r = 255;  // 
		leds1[adr].g = 0;
		leds1[adr].b = 0;

		leds3[adr].r = 0;  // 
		leds3[adr].g = 0;
		leds3[adr].b = 255;

		led_adr = modify_adr(0, 0, adr);   //make image right side up or upside down

		leds2[led_adr].r = 255;  // 
		leds2[led_adr].g = 0;  // 
		leds2[led_adr].b = 0;  //

		leds4[led_adr].r = 0;  // 
		leds4[led_adr].g = 0;  // 
		leds4[led_adr].b = 255;  //



	}

	//G_dim = DEFAULT_BRIGTHNESS;  // removed 5/14/24 as BEAT_SHOW unresponsive to DIMMING control
	SHOW_slow();
	delay(1000);
}







//////////////////////////////////////////////////////////////////////
void TRIANGLE(int xs, int ys, int xe, int ye, int hue)  // generate an triangle given the hypotinuse
{
	int xt;
	int yt;

	//if (xs > xe) // swap xs and xe and ys and ye
	//{
	//	xt = xs;
	//	xs = xe;
	//	xe = xt;

	//	yt = ys;
	//	ys = ye;
	//	ye = yt;
	//}

	if (xe > xs) // swap xs and xe and ys and ye
	{
		xt = xe;
		xe = xs;
		xs = xt;

		yt = ye;
		ye = ys;
		ys = yt;
	}

	//xs = 5;   //*********** FOR TEST ONLY  delete
	//ys = 11; //*********** FOR TEST ONLY  delete
	//xe = 5;  //*********** FOR TEST ONLY  delete
	//ye = 4;  //*********** FOR TEST ONLY  delete

	//Serial.println("");
	//Serial.println(F("+++++++++ TRIANGLE:"));
	//Serial.print(F("xs="));
	//Serial.println(xs);
	//Serial.print(F("ys="));
	//Serial.println(ys);
	//Serial.print(F("xe="));
	//Serial.println(xe);
	//Serial.print(F("ye="));
	//Serial.println(ye);
	//Serial.println("");

	LINE(xs, ys, xe, ye, hue);  //hypotonuse
	LINE(xs, ys, xe, ys, hue);  //horizontal 
	LINE(xe, ys, xe, ye, hue);   // verticle


}

//////////////////////////////////////////////////////////////////////
void HOZ_V(int xs, int ys, int xe, int ye, byte swap_SE_flag, int hue)  // generate a horizontal V given one leg....the other leg will be mirrored about the X axis at the vertex
{
	//if swap_SE_flag =1 the start and end are swapped

	int xt;
	int yt;

	//if (xs > xe) // swap xs and xe and ys and ye
	//{
	//	xt = xs;
	//	xs = xe;
	//	xe = xt;

	//	yt = ys;
	//	ys = ye;
	//	ye = yt;
	//}

	if (swap_SE_flag == 1)
	{
		//if (xe > xs) // swap xs and xe and ys and ye
		{
			xt = xe;
			xe = xs;
			xs = xt;

			yt = ye;
			ye = ys;
			ys = yt;
		}
	}

	//xs = 5;   //*********** FOR TEST ONLY  delete
	//ys = 11; //*********** FOR TEST ONLY  delete
	//xe = 5;  //*********** FOR TEST ONLY  delete
	//ye = 4;  //*********** FOR TEST ONLY  delete

	//Serial.println("");
	//Serial.println(F("+++++++++ HOZ_V:"));
	//Serial.print(F("xs="));
	//Serial.println(xs);
	//Serial.print(F("ys="));
	//Serial.println(ys);
	//Serial.print(F("xe="));
	//Serial.println(xe);
	//Serial.print(F("ye="));
	//Serial.println(ye);
	//Serial.println("");

	LINE(xs, ys, xe, ye, hue);  //first line

	int delta_y = abs(ye - ys);

	//Serial.print(F("delta_y="));
	//Serial.println(delta_y);

	if (ye > ys)  // mirror down
	{
		yt = ys - delta_y;
	}
	else // mirror up
	{
		yt = ys + delta_y;
	}

	if (yt < 0) { yt = 0; }
	if (yt >= NUM_ROWS) { yt = NUM_ROWS - 1; }

	ye = yt;

	//Serial.print(F("yt="));
	//Serial.println(yt);
	//Serial.println("---------");
	//
	LINE(xs, ys, xe, ye, hue);  //mirror



}

//////////////////////////////////////////////////////////////////////
void ZIG_ZAG(int xs, int ys, int xe, int ye, byte number_of_peaks, double amplitude, int hue)  // generate a zig zag given the axis, amplitude and segments
{
	// number_of_peaks = number of peaks positive and negative
	// amplitude = max distance (in LEDS) from the defined axis .. can be positive or negative
	// flip =0  or 1 to flip amplitude

	//Serial.println("");
	//Serial.print(F("ZIG_ZAG: xs= "));
	//Serial.println(xs);
	//Serial.print(F("ZIG_ZAG: ys= "));
	//Serial.println(ys);
	//Serial.print(F("ZIG_ZAG: xe= "));
	//Serial.println(xe);
	//Serial.print(F("ZIG_ZAG: ye= "));
	//Serial.println(ye);
	//Serial.print(F("ZIG_ZAG: number_of_peaks= "));
	//Serial.println(number_of_peaks);
	//Serial.print(F("ZIG_ZAG: amplitude= "));
	//Serial.println(amplitude);
	//Serial.print(F("ZIG_ZAG: hue= "));
	//Serial.println(hue);
	//Serial.println("");


#define MAX_NUMBER_PEAKS 8  // maximum number of peaks

	// find angle of rotation
	double xe_t = abs(xe - xs);  // move xs and ys to origin to set the point of rotation
	double ye_t = abs(ye - ys);
	double length = sqrt(((1 + xe_t) * (1 + xe_t)) + ((1 + ye_t) * (1 + ye_t)));

	if (xe_t == 0) { xe_t = .00001; }// prevent devide by 0

	double angle = atan(ye_t / xe_t);  // angle of translated axis


	/// find  coordinates of the peaks relative to the X,y axis (rotation and translation will occur later)
	double xpeaks[MAX_NUMBER_PEAKS];
	double ypeaks[MAX_NUMBER_PEAKS];
	double xpeaks_rotated[MAX_NUMBER_PEAKS];
	double ypeaks_rotated[MAX_NUMBER_PEAKS];
	double xpeaks_final[MAX_NUMBER_PEAKS];
	double ypeaks_final[MAX_NUMBER_PEAKS];

	// find the number of peaks
	//byte number_of_peaks;

	//if (int(segments) % 2 == 0)  // even
	//{
	//	number_of_peaks = byte(segments/2); 
	//}
	//else
	//{
	//	number_of_peaks = byte((segments+1) / 2);
	//}

	//Serial.println("");
	//Serial.print(F("---> number_of_peaks= "));
	//Serial.println(number_of_peaks);
	//Serial.print(F("amplitude= "));
	//Serial.println(amplitude);
	//Serial.print(F("length= "));
	//Serial.println(length);

	//Serial.print(F("xe_t= "));
	//Serial.println(xe_t);
	//Serial.print(F("ye_t= "));
	//Serial.println(ye_t);

	//Serial.print(F("angle= "));
	//Serial.println(angle);
	//Serial.println("");

	byte peak_index = 0;

	// using a line that is horizontal of length= length, construct the peak locations...at the end this line will be rotated
	//for (byte n = 0; n < segments; ++n)
	for (byte n = 1; n <= number_of_peaks; ++n)
	{
		//if (n % 2 != 0)  // odd....peaks only occur on odd segments

		xpeaks[peak_index] = ((n) * (length / number_of_peaks));

		//if (xpeaks[peak_index] >= NUM_COLUMNS) { xpeaks[peak_index] = NUM_COLUMNS -1; }

		if (peak_index % 2 == 0)  // even
		{
			ypeaks[peak_index] = amplitude;
		}
		else
		{

			ypeaks[peak_index] = 0;
		}

		//Serial.print(F("xpeaks["));
		//Serial.print(peak_index);
		//Serial.print(F("]= "));
		//Serial.println(xpeaks[peak_index]);
		//Serial.print(F("ypeaks["));
		//Serial.print(peak_index);
		//Serial.print(F("]= "));
		//Serial.println(ypeaks[peak_index]);
		//Serial.println("");

		++peak_index;




	}



	// now rotate the peaks by angle
	for (byte n = 0; n < number_of_peaks; ++n)
	{
		xpeaks_rotated[n] = (xpeaks[n] * cos(angle)) - (ypeaks[n] * sin(angle));
		ypeaks_rotated[n] = (ypeaks[n] * cos(angle)) + (xpeaks[n] * sin(angle));


		//Serial.print(F("angle= "));
		//Serial.println(180*angle/3.14159);  // convert to degrees
		//Serial.print(F("xpeaks_rotated["));
		//Serial.print(n);
		//Serial.print(F("]= "));
		//Serial.println(xpeaks_rotated[n]);
		//Serial.print(F("ypeaks_rotated["));
		//Serial.print(n);
		//Serial.print(F("]= "));
		//Serial.println(ypeaks_rotated[n]);
		//Serial.println("");

	}

	// now translate back 
	for (byte n = 0; n < number_of_peaks; ++n)
	{
		xpeaks_final[n] = xpeaks_rotated[n] + xs;
		ypeaks_final[n] = ypeaks_rotated[n] + ys;

		if (xpeaks_final[n] < 0) { xpeaks_final[n] = 0; }
		if (xpeaks_final[n] >= NUM_COLUMNS) { xpeaks_final[n] = NUM_COLUMNS - 1; }
		if (ypeaks_final[n] < 0) { ypeaks_final[n] = 0; }
		if (ypeaks_final[n] >= NUM_ROWS) { ypeaks_final[n] = NUM_ROWS - 1; }



	}


	// now connect the points with lines
	LINE(xs, ys, xpeaks_final[0], ypeaks_final[0], hue);  //first line

	for (byte n = 0; n < number_of_peaks; ++n)
	{
		if (n + 1 < number_of_peaks)
		{
			LINE(xpeaks_final[n], ypeaks_final[n], xpeaks_final[n + 1], ypeaks_final[n + 1], hue);

			//Serial.print(F("xpeaks_final["));
			//Serial.print(n);
			//Serial.print(F("]= "));
			//Serial.println(xpeaks_final[n]);
			//Serial.print(F("ypeaks_final["));
			//Serial.print(n);
			//Serial.print(F("]= "));
			//Serial.println(ypeaks_final[n]);

			//Serial.print(F("xpeaks_final["));
			//Serial.print(n+1);
			//Serial.print(F("]= "));
			//Serial.println(xpeaks_final[n+1]);
			//Serial.print(F("ypeaks_final["));
			//Serial.print(n + 1);
			//Serial.print(F("]= "));
			//Serial.println(ypeaks_final[n + 1]);
			//Serial.println("");


		}
	}

}

//////////////////////////////////////////////////////////////////////
void SPIKES(int xs, int ys, int xe, int ye, byte number_of_spikes, double amplitude, byte mode, int hue_axis, int hue_spikes)  // generate a line with spikes at regular intervals
{
	// number_of_spikes = number of peaks positive and negative
	// amplitude = max distance (in LEDS) from the defined axis .. can be positive or negative
	// mode = 1 for axis and spikes, 0=spikes only

	//Serial.println("");
	//Serial.print(F("SPIKES: xs= "));
	//Serial.println(xs);
	//Serial.print(F("SPIKES: ys= "));
	//Serial.println(ys);
	//Serial.print(F("SPIKES: xe= "));
	//Serial.println(xe);
	//Serial.print(F("SPIKES: ye= "));
	//Serial.println(ye);
	//Serial.print(F("SPIKES: number_of_spikes= "));
	//Serial.println(number_of_spikes);
	//Serial.print(F("SPIKES: amplitude= "));
	//Serial.println(amplitude);
	//Serial.print(F("SPIKES: hue_axis= "));
	//Serial.println(hue_axis);
	//Serial.print(F("SPIKES: hue_spikes= "));
	//Serial.println(hue_spikes);
	//Serial.println("");

#define MAX_NUMBER_SPIKES 8  // maximum number of peaks


	if (xs > xe) // reverse pair to get spikes to align correctly
	{
		int xst = xs;  // temporary
		int yst = ys; // temporary

		xs = xe;
		ys = ye;

		xe = xst;
		ye = yst;

	}


	// find angle of rotation
	// note: do not take absolute value as angle turns out wrong for negative slope
	double xe_t = (xe - xs);  // move xs and ys to origin to set the point of rotation
	double ye_t = (ye - ys);

	double length = sqrt(((1 + xe_t) * (1 + xe_t)) + ((1 + ye_t) * (1 + ye_t)));

	if (xe_t == 0) { xe_t = .00001; }// prevent devide by 0

	double angle = atan(ye_t / xe_t);  // angle of translated axis


	/// find  coordinates of the peaks relative to the x,y axis (rotation and translation will occur later)
	double xpeaks[MAX_NUMBER_SPIKES];
	double ypeaks[MAX_NUMBER_SPIKES];
	double xorigins[MAX_NUMBER_SPIKES]; // all spikes have a base on the main axis 
	double yorigins[MAX_NUMBER_SPIKES]; // all spikes have a base on the main axis 

	double xpeaks_rotated[MAX_NUMBER_SPIKES];
	double ypeaks_rotated[MAX_NUMBER_SPIKES];
	double xorigins_rotated[MAX_NUMBER_SPIKES]; // all spikes have a base on the main axis 
	double yorigins_rotated[MAX_NUMBER_SPIKES]; // all spikes have a base on the main axis 


	double xpeaks_final[MAX_NUMBER_SPIKES];
	double ypeaks_final[MAX_NUMBER_SPIKES];
	double xorigins_final[MAX_NUMBER_SPIKES]; // all spikes have a base on the main axis 
	double yorigins_final[MAX_NUMBER_SPIKES]; // all spikes have a base on the main axis 

	//Serial.println(F("++++++SPIKES : position 1"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);

	// find the number of peaks
	//byte number_of_peaks;

	//if (int(segments) % 2 == 0)  // even
	//{
	//	number_of_peaks = byte(segments/2); 
	//}
	//else
	//{
	//	number_of_peaks = byte((segments+1) / 2);
	//}

	//Serial.println(F("---  SPIKES  --- "));
	//Serial.print(F("---> number_of_peaks= "));
	//Serial.println(number_of_spikes);
	//Serial.print(F("amplitude= "));
	//Serial.println(amplitude);
	//Serial.print(F("length= "));
	//Serial.println(length);

	//Serial.print(F("xe_t= "));
	//Serial.println(xe_t);
	//Serial.print(F("ye_t= "));
	//Serial.println(ye_t);

	//Serial.print(F("angle= "));
	//Serial.println(180 * angle / 3.14159);  // convert to degrees);
	//Serial.println("");

	byte peak_index = 0;

	// using a line that is horizontal of length= length, construct the spike locations...in the end this line will be rotated
	for (byte n = 1; n <= number_of_spikes; ++n)
	{
		//if (n % 2 != 0)  // odd....peaks only occur on odd segments

		xpeaks[peak_index] = ((n) * (length / number_of_spikes));

		xorigins[peak_index] = xpeaks[peak_index];
		yorigins[peak_index] = 0;

		if (peak_index % 2 == 0)  // even
		{
			ypeaks[peak_index] = amplitude;

		}
		else
		{

			ypeaks[peak_index] = -1 * amplitude;
		}

		//Serial.print(F("xpeaks["));
		//Serial.print(peak_index);
		//Serial.print(F("]= "));
		//Serial.println(xpeaks[peak_index]);
		//Serial.print(F("ypeaks["));
		//Serial.print(peak_index);
		//Serial.print(F("]= "));
		//Serial.println(ypeaks[peak_index]);
		//Serial.println("");

		++peak_index;




	}


	//Serial.println(F("++++++SPIKES : position 2"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);


	// now rotate the peaks by angle
	for (byte n = 0; n < number_of_spikes; ++n)
	{




		xpeaks_rotated[n] = (xpeaks[n] * cos(angle)) - (ypeaks[n] * sin(angle));
		ypeaks_rotated[n] = (ypeaks[n] * cos(angle)) + (xpeaks[n] * sin(angle));

		xorigins_rotated[n] = (xorigins[n] * cos(angle)) - (yorigins[n] * sin(angle));
		yorigins_rotated[n] = (yorigins[n] * cos(angle)) + (xorigins[n] * sin(angle));




		//xpeaks_rotated[n] = (xpeaks[n] * cos(angle)) - (ypeaks[n] * sin(angle));
		//ypeaks_rotated[n] = (ypeaks[n] * cos(angle)) + (xpeaks[n] * sin(angle));

		//xorigins_rotated[n] = (xorigins[n] * cos(angle)) - (yorigins[n] * sin(angle));
		//yorigins_rotated[n] = (yorigins[n] * cos(angle)) + (xorigins[n] * sin(angle));


		//Serial.print(F("angle= "));
		//Serial.println(180*angle/3.14159);  // convert to degrees
		//Serial.print(F("xpeaks_rotated["));
		//Serial.print(n);
		//Serial.print(F("]= "));
		//Serial.println(xpeaks_rotated[n]);
		//Serial.print(F("ypeaks_rotated["));
		//Serial.print(n);
		//Serial.print(F("]= "));
		//Serial.println(ypeaks_rotated[n]);
		//Serial.println("");

	}

	//Serial.println(F("++++++SPIKES : position 3"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);

	// now translate back 
	for (byte n = 0; n < number_of_spikes; ++n)
	{


		//xpeaks_final[number_of_spikes -n -1] = xpeaks_rotated[n] + xs;
		//ypeaks_final[number_of_spikes - n - 1] = ypeaks_rotated[n] + ys;

		//xorigins_final[number_of_spikes - n - 1] = xorigins_rotated[n] + xs;
		//yorigins_final[number_of_spikes - n - 1] = yorigins_rotated[n] + ys;

		xpeaks_final[n] = xpeaks_rotated[n] + xs;
		ypeaks_final[n] = ypeaks_rotated[n] + ys;

		xorigins_final[n] = xorigins_rotated[n] + xs;
		yorigins_final[n] = yorigins_rotated[n] + ys;

		if (xpeaks_final[n] < 0) { xpeaks_final[n] = 0; }
		if (xpeaks_final[n] >= NUM_COLUMNS) { xpeaks_final[n] = NUM_COLUMNS - 1; }

		if (xorigins_final[n] < 0) { xorigins_final[n] = 0; }
		if (xorigins_final[n] >= NUM_COLUMNS) { xorigins_final[n] = NUM_COLUMNS - 1; }

		if (ypeaks_final[n] < 0) { ypeaks_final[n] = 0; }
		if (ypeaks_final[n] >= NUM_ROWS) { ypeaks_final[n] = NUM_ROWS - 1; }

		if (yorigins_final[n] < 0) { yorigins_final[n] = 0; }
		if (yorigins_final[n] >= NUM_ROWS) { yorigins_final[n] = NUM_ROWS - 1; }



	}

	//Serial.print(F(""));
	//Serial.println(F("++++++---->>>>>>>>>>>>> SPIKES : position 4"));
	////Serial.print(F("G_sampling_period_us= "));
	////Serial.println(G_sampling_period_us);
	//Serial.print(F("xs= "));
	//Serial.println(xs);
	//Serial.print(F("ys= "));
	//Serial.println(ys);
	//Serial.print(F("xe= "));
	//Serial.println(xe);
	//Serial.print(F("ye= "));
	//Serial.println(ye);
	//Serial.print(F("hue_axis= "));
	//Serial.println(hue_axis);
	//Serial.print(F("hue_spikes= "));
	//Serial.println(hue_spikes);
	//Serial.print(F("mode= "));
	//Serial.println(mode);
	//Serial.print(F(""));

	if (mode == 1) // spikes and axis are drawn
	{
		// now connect the points with lines
		LINE(xs, ys, xe, ye, hue_axis);  //axis line
	}

	//Serial.println(F("++++++SPIKES : position 5"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);

	for (byte n = 0; n < number_of_spikes; ++n)  // draw spikes
	{
		//if (n + 1 < number_of_spikes)
		{

			LINE(xorigins_final[n], yorigins_final[n], xpeaks_final[n], ypeaks_final[n], hue_spikes);   // draw spike

			//Serial.print(F("xpeaks_final["));
			//Serial.print(n);
			//Serial.print(F("]= "));
			//Serial.println(xpeaks_final[n]);
			//Serial.print(F("ypeaks_final["));
			//Serial.print(n);
			//Serial.print(F("]= "));
			//Serial.println(ypeaks_final[n]);

			//Serial.print(F("xpeaks_final["));
			//Serial.print(n+1);
			//Serial.print(F("]= "));
			//Serial.println(xpeaks_final[n+1]);
			//Serial.print(F("ypeaks_final["));
			//Serial.print(n + 1);
			//Serial.print(F("]= "));
			//Serial.println(ypeaks_final[n + 1]);
			//Serial.println("");


		}
	}


	//Serial.println(F("++++++SPIKES : END"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);


}


/////////////////////////////////////////////////////////////////////
byte GENERATE_IMAGE_IF_NONE(byte kind)  // generate a random image if there isn't any displayed
// kind=1 for line, kind=2 for circle, kind=3 for rectangle, kind=4 for triangle
// return a 1 if an image is generated
{
	//Serial.println("");
	//Serial.println(F("+++++++++ GENERATE_IMAGE_IF_NONE"));

	int image_exists = 0;  // set to 1 if an image exists

	for (int n = 0; n < NUM_LEDS; ++n)
	{
		if ((leds1[n].r != 0) || (leds1[n].g != 0) || (leds1[n].b != 0))
		{
			image_exists = 1;
			return 0;
		}

	}


	if (image_exists == 0)  // no image found
	{
		//Serial.println(F("no image"));

		CREATE_RANDOM_IMAGES(kind, 6);
		// create random images to be used by DO_SHOW
		// kind=1 for LINE, 2=circle, 3=rectangle, 4= triangle

		SHOW_slow();
		return 1;
	}

	//Serial.println("");
}

///////////////////////////////////////////////////////////////////////
void SAVE_DISPLAY_to_BUFFER()  // save the present contents of leds1 to specified buffer
{
	// image is always saved to leds_buffer# pointed to by the last element in the UNDO_stored_array

	byte buffer;  // holds which leds_buffer# to store image display to
	byte temp;

	++G_UNDO_stored;  // 0= no images stored in leds_buffer1 or leds_buffer2, 1= undo image stored in leds_buffer1, 2= undo image stored in leds_buffer2

	if (G_UNDO_stored == 1)
	{
		UNDO_stored_array[1] = 1; // point to leds_buffer1 
		buffer = 1; // save image in leds_buffer1
	}

	if (G_UNDO_stored == 2)
	{
		UNDO_stored_array[1] = 2; // point to leds_buffer2
		UNDO_stored_array[0] = 1; // point to leds_buffer1

		buffer = 2; // save image in leds_buffer2
	}

	if (G_UNDO_stored > maximum_number_of_stored_buffer_images)
	{
		G_UNDO_stored = maximum_number_of_stored_buffer_images;

		// swap pointers as buffer pointed to in position 0 is to be re-used
		temp = UNDO_stored_array[0];
		UNDO_stored_array[0] = UNDO_stored_array[1];
		UNDO_stored_array[1] = temp;
		buffer = temp; // save image to buffer pointed to by temp

	}


	// store the present display to the buffer
	for (int n = 0; n < NUM_LEDS; ++n)
	{
		if (buffer == 1)
		{
			leds_buffer1[n] = leds1[n];
		}
		if (buffer == 2)
		{
			leds_buffer2[n] = leds1[n];
		}
	}


}

///////////////////////////////////////////////////////////////////////
byte LOAD_DISPLAY_from_BUFFER()  // load panel with leds_buffer specified in the last positionof the UNDO_stored_array
// return 1 if image was loaded otherwise return 0
{

	int adr;
	byte buffer;

	G_BT_cmd_previous = 0; // allow for another SAVE_DISPLAY_to_BUFFER to occur

	buffer = UNDO_stored_array[1]; // load image in leds_buffer#

	if (G_UNDO_stored == 1)
	{
		UNDO_stored_array[1] = 0; // after an UNDO no image is pointed to
	}


	if (G_UNDO_stored == 2)
	{
		UNDO_stored_array[1] = UNDO_stored_array[0]; // point to leds_buffer1 
		UNDO_stored_array[0] = 0;
	}

	--G_UNDO_stored;

	if (G_UNDO_stored < 0)  // no images stored in buffer
	{
		G_UNDO_stored = 0;
		return 0;
	}


	for (int n = 0; n < NUM_LEDS; ++n)
	{
		adr = modify_adr(0, 0, n); // make image upside down

		if (buffer == 1)
		{
			leds1[n] = leds_buffer1[n];
			leds3[n] = leds_buffer1[n];

			leds2[adr] = leds_buffer1[n];
			leds4[adr] = leds_buffer1[n];

		}
		if (buffer == 2)
		{
			leds1[n] = leds_buffer2[n];
			leds3[n] = leds_buffer2[n];

			leds2[adr] = leds_buffer2[n];
			leds4[adr] = leds_buffer2[n];

		}
	}

	SHOW_slow();

	return 1;


}


///////////////////////////////////////////////////////////////////////
void COLOR_STRIPES_VERT(byte width, byte seperation)  // generate vertical color stripes of random colors, only color LEDs already ON
// num_stripes=number of stripes (starting near spin axis), width = number of leds wide for 1st color  , seperation=witdth number of LEDS to change to a 2nd color
{
	byte width_counter = 0;
	byte seperation_counter = 0;
	int color1 = 0;
	int color2 = 0;
	int rn;
	int hue;
	int adr;
	int adr2;

	rn = random(0, MAX_HUES - 1);  // select stripe colors
	color1 = hues[rn];

	rn = random(0, MAX_HUES - 1);
	color2 = hues[rn];


	for (int x = 0; x < NUM_COLUMNS; ++x)
	{
		++width_counter;
		if (width_counter <= width)
		{
			hue = color1;

		}

		if (width_counter > width)
		{
			++seperation_counter;
			hue = color2;

		}

		if (seperation_counter >= seperation)
		{
			width_counter = 0;
			seperation_counter = 0;
		}

		for (int y = 0; y < NUM_ROWS; ++y)  // colorize columns
		{
			adr = GET_XY_ADR(x, y);
			adr2 = modify_adr(0, 0, adr);

			if (leds1[adr])   // check if LED is lit
			{
				leds1[adr] = CHSV(hue, 255, 255);
				leds2[adr2] = CHSV(hue, 255, 255);
				leds3[adr] = CHSV(hue, 255, 255);
				leds4[adr2] = CHSV(hue, 255, 255);
			}

		}


	}


}


///////////////////////////////////////////////////////////////////////
void COLOR_STRIPES_HOZ(byte width, byte seperation)  // generate horizontal color stripes of random colors, only color LEDs already ON
// num_stripes=number of stripes (starting near spin axis), width = number of leds wide for 1st color  , seperation=witdth number of LEDS to change to a 2nd color
{
	byte width_counter = 0;
	byte seperation_counter = 0;
	int color1 = 0;
	int color2 = 0;
	int rn;
	int hue;
	int adr;
	int adr2;

	rn = random(0, MAX_HUES - 1);  // select stripe colors
	color1 = hues[rn];

	rn = random(0, MAX_HUES - 1);
	color2 = hues[rn];


	for (int y = 0; y < NUM_ROWS; ++y)
	{
		++width_counter;
		if (width_counter <= width)
		{
			hue = color1;

		}

		if (width_counter > width)
		{
			++seperation_counter;
			hue = color2;

		}

		if (seperation_counter >= seperation)
		{
			width_counter = 0;
			seperation_counter = 0;
		}

		for (int x = 0; x < NUM_COLUMNS; ++x)  // colorize rows
		{
			adr = GET_XY_ADR(x, y);
			adr2 = modify_adr(0, 0, adr);

			if (leds1[adr])   // check if LED is lit
			{
				leds1[adr] = CHSV(hue, 255, 255);
				leds2[adr2] = CHSV(hue, 255, 255);
				leds3[adr] = CHSV(hue, 255, 255);
				leds4[adr2] = CHSV(hue, 255, 255);
			}

		}


	}


}

//////////////////////////////////////////////////////////
void MINI_SHOW_1(int repeats)  // V lines moving up and down
{
	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

	SAVE_BACKGROUND();

	int prev_y = 0; // keep track of previous value of y
	byte hue1;
	byte hue2;


	for (int n = 0; n < repeats; ++n)
	{
		//HUE_CYCLE_VERT(0, 2, 0);  // change the colors each time 

		hue1 = random(0, 255);
		hue2 = random(0, 255);

		for (int y = 0; y < NUM_ROWS; ++y)
		{
			LOAD_BACKGROUND();

			//	LINE(0, prev_y, NUM_COLUMNS -1, NUM_ROWS -1 , 999); // clear the previous line
			LINE(0, y, NUM_COLUMNS - 1, NUM_ROWS - 1, hue1);  // bottom up start, anchored end

			//	LINE(0, (NUM_ROWS - 1 - prev_y), (NUM_COLUMNS - 1), 0, 999);  // top down start // clear the previous line
			LINE(0, (NUM_ROWS - 1 - y), (NUM_COLUMNS - 1), 0, hue2);  // top down start, anchored end



			prev_y = y;


			SHOW_slow();

		}

	}

	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER

}


/////////////////////////////////////////////////////////////
void MINI_SHOW_2(int repeats)  // proceedural V up and V down with sphere
{

	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

	int x_target = (NUM_COLUMNS - 1);
	int y_target = NUM_ROWS / 2;
	int hue = 0;
	int hue_increment = 15;

	SAVE_BACKGROUND();

	//CLEAR_ALL_LEDS();



	for (int n = 0; n < repeats; ++n)  // number of times show repeats
	{
		for (int y = 0; y < NUM_ROWS; ++y)
		{
			LOAD_BACKGROUND();

			LINE(0, y, x_target, y_target, 1);  // red line
			LINE(0, NUM_ROWS - y - 1, x_target, y_target, 171);  // blue line


			hue = hue + hue_increment;

			if (hue > 255)
			{
				hue = 0;
			}

			if ((y > 0) && (y < NUM_ROWS / 2))
			{
				SPHERE(y, 0, y_target, hue);  // hue sphere
			}

			if (y > NUM_ROWS / 2)
			{
				SPHERE(NUM_ROWS - y, 0, y_target, hue);  // yellow sphere
			}


			SHOW_slow();
			delay(50);

			//	LINE(0, y, x_target, y_target, 999);  // erase red line
			//	LINE(0, NUM_ROWS - y - 1, x_target, y_target, 999);  // erase blue line

			if ((y > 0) && (y < NUM_ROWS / 2))
			{
				SPHERE(y, 0, y_target, 999);  // erase hue sphere
			}
			if (y > NUM_ROWS / 2)
			{
				SPHERE(NUM_ROWS - y, 0, y_target, 999);  // erase yellow sphere
			}
		}
	}

	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER
}

/////////////////////////////////////////////////////////
void MINI_SHOW_3(int repeats)  //up and down white lights
{

	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

	int x;
	int adr;
	int adr2;
	int y2;

	int x3;
	int hu;
	int rn;
	int x4;

	SAVE_BACKGROUND();


	for (int n = 0; n < repeats; ++n)
	{


		x = 0;
		y2 = 0;
		x4 = x;


		for (int y = NUM_ROWS - 1; y >= 0; --y)
		{
			LOAD_BACKGROUND();

			rn = random(MAX_HUES - 1);
			hu = hues[rn];

			if (0 == x % 2) // even ... skip every other x
			{

				x3 = NUM_COLUMNS - 1 - x4;

				x4 = x4 + 2; // every other column
			}

			if (x3 < 0)
			{
				x4 = 0;
			}

			for (int yy = 0; yy < NUM_ROWS; ++yy)  // vertical colored line
			{


				adr = GET_XY_ADR(x3, yy);
				adr2 = modify_adr(0, 0, adr);



				leds1[adr] = CHSV(hu, 255, 255);
				leds3[adr] = CHSV(hu, 255, 255);
				leds2[adr2] = CHSV(hu, 255, 255);
				leds4[adr2] = CHSV(hu, 255, 255);

			}

			// top down
			adr = GET_XY_ADR(x, y);
			//leds1[adr] = (255, 255, 255);  // white
			leds1[adr].r = 255;
			leds1[adr].g = 255;
			leds1[adr].b = 255;

			leds3[adr].r = 255;
			leds3[adr].g = 255;
			leds3[adr].b = 255;



			adr2 = modify_adr(0, 0, adr);


			leds2[adr2].r = 255;
			leds2[adr2].g = 255;
			leds2[adr2].b = 255;

			leds4[adr2].r = 255;
			leds4[adr2].g = 255;
			leds4[adr2].b = 255;



			// bottom up
			adr = GET_XY_ADR(x, y2);
			leds1[adr].r = 255;
			leds1[adr].g = 255;
			leds1[adr].b = 255;

			leds3[adr].r = 255;
			leds3[adr].g = 255;
			leds3[adr].b = 255;

			adr2 = modify_adr(0, 0, adr);


			leds2[adr2].r = 255;
			leds2[adr2].g = 255;
			leds2[adr2].b = 255;

			leds4[adr2].r = 255;
			leds4[adr2].g = 255;
			leds4[adr2].b = 255;


			SHOW_slow();

			++x;
			++y2;

		}
	}

	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER

}

/////////////////////////////////////////////////////////
void MINI_SHOW_4(int repeats)  //vertical waves of color  
{

	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

	byte abort = 0;  // set to 1 if aborting this mini show

	SAVE_BACKGROUND();

	for (int k = 0; k < repeats; ++k)
	{
		LOAD_BACKGROUND();

		abort = COLOR_STRIPE_ROLL_HOZ(6, 2, 2, 1);  // roll color stripes of given width through image from inner to outter,

		if (abort == 1) // allow for quick abort if BT received
		{
			LOAD_BACKGROUND();
			return;
		}

		abort = COLOR_STRIPE_ROLL_VERT(6, 2, 2, 1); // roll color stripes of given width through image from bottom to top

		if (abort == 1) // allow for quick abort if BT received
		{
			LOAD_BACKGROUND();
			return;
		}

		abort = COLOR_STRIPE_ROLL_VERT(11, 2, 2, 2); // roll color stripes of given width through image from bottom to top

		if (abort == 1)// allow for quick abort if BT received
		{
			LOAD_BACKGROUND();
			return;
		}

		abort = COLOR_STRIPE_ROLL_HOZ(11, 2, 2, 2);  // roll color stripes of given width through image from inner to outter,

		if (abort == 1) // allow for quick abort if BT received
		{
			LOAD_BACKGROUND();
			return;
		}

		abort = COLOR_STRIPE_ROLL_VERT(11, 2, 2, 1); // roll color stripes of given width through image from bottom to top

		if (abort == 1) // allow for quick abort if BT received
		{
			LOAD_BACKGROUND();
			return;
		}

		abort = COLOR_STRIPE_ROLL_VERT(6, 2, 2, 2); // roll color stripes of given width through image from bottom to top

		if (abort == 1)// allow for quick abort if BT received
		{
			LOAD_BACKGROUND();
			return;
		}

		abort = COLOR_STRIPE_ROLL_HOZ(6, 2, 2, 2);  // roll color stripes of given width through image from inner to outter,

		if (abort == 1) // allow for quick abort if BT received
		{
			LOAD_BACKGROUND();
			return;
		}

	}

	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER


}

/////////////////////////////////////////////////////////
void MINI_SHOW_5(int repeats)  //FATTEN  
{

	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

	int short_delay = 10;

	SAVE_BACKGROUND();

	for (int k = 0; k < repeats; ++k)
	{
		LOAD_BACKGROUND();


		for (int n = 0; n < 20; ++n)
		{


			FATTEN_VERT(1, 0);  //FATTEN pixels by adding new pixels to dir=top down (1) or dir =bottom up (2)  , keep=1 to keep parent pixels
			FATTEN_HOZ(1, 0);  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels

			SHOW_slow();
			delay(short_delay);
		}

		LOAD_BACKGROUND();


		for (int n = 0; n < 4; ++n)
		{


			FATTEN_VERT(1, 1);  //FATTEN pixels by adding new pixels to dir=top down (1) or dir =bottom up (2)  , keep=1 to keep parent pixels
			FATTEN_HOZ(1, 1);  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels

			SHOW_slow();
			delay(short_delay);
		}


		//BT_DELAY(50);

		LOAD_BACKGROUND();

		for (int n = 0; n < 20; ++n)
		{
			FATTEN_HOZ(2, 0);  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels

			FATTEN_VERT(2, 0);  //FATTEN pixels by adding new pixels to dir=top down (1) or dir =bottom up (2)  , keep=1 to keep parent pixels

			SHOW_slow();
			delay(short_delay);
		}

		for (int n = 0; n < 4; ++n)
		{
			FATTEN_HOZ(2, 1);  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels

			FATTEN_VERT(2, 1);  //FATTEN pixels by adding new pixels to dir=top down (1) or dir =bottom up (2)  , keep=1 to keep parent pixels

			SHOW_slow();
			delay(short_delay);
		}
	}

	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER

}

/////////////////////////////////////////////////////////
void MINI_SHOW_6(int repeats)  //flipping 
{

	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

	SAVE_BACKGROUND();

	for (int n = 0; n < repeats; ++n)
	{

		LOAD_BACKGROUND();

		FLIP_DISPLAY();
		SHOW_slow();
		delay(10);

		FLIP_MID_HOZ();
		SHOW_slow();
		delay(10);

	}


	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER
}

/////////////////////////////////////////////////////////
void MINI_SHOW_7(int repeats)  //rolling
{

	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

	SAVE_BACKGROUND();

	for (int n = 0; n < repeats; ++n)
	{
		ROLL_HOZ(2);
		SHOW_slow();
		delay(10);

		ROLL_VERT(2);
		SHOW_slow();
		delay(10);


	}
	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER

}

/////////////////////////////////////////////////////////
void MINI_SHOW_8(int repeats)  //FATTEN  
{
	G_SKIP_BTCH = 1;  // skip BLUE_TOOTH_COMMAND_HANDLER

#define thickness 5  // how many pixels involved in fatten

	SAVE_BACKGROUND();

	for (int n = 0; n < repeats; ++n)
	{
		LOAD_BACKGROUND();

		for (int k = 0; k < thickness; ++k)
		{

			FATTEN_VERT(1, 1);  //FATTEN pixels by adding new pixels to dir=top down (1) or dir =bottom up (2)  , keep=1 to keep parent pixels
			SHOW_slow();
			delay(10);
		}

		for (int k = 0; k < thickness; ++k)
		{

			FATTEN_HOZ(1, 1);  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels
			SHOW_slow();
			delay(10);
		}


	}
	LOAD_BACKGROUND();
	SHOW_slow();

	G_SKIP_BTCH = 0;  // enable BLUE_TOOTH_COMMAND_HANDLER

}

/////////////////////////////////////////////////////////
void FATTEN_HOZ(int dir, int keep)  //FATTEN pixels by adding new pixels to dir=left (1) or dir =right (2)  , keep=1 to keep parent pixels
{



	int adr;
	int adr_fat;
	int adr2;
	int adr2_fat;


	for (int y = 0; y < NUM_ROWS; ++y)
	{
		if (dir == 1)  // add pixels to the left
		{

			for (int x = 1; x < NUM_COLUMNS; ++x)  // fatten to the left
			{
				adr = GET_XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);

				adr_fat = GET_XY_ADR(x - 1, y);
				if (x == 1) { adr_fat = adr; }  // prevent pile up on column 0

				adr2_fat = modify_adr(0, 0, adr_fat);

				if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))  // pixel is lit
				{
					leds1[adr_fat].r = leds1[adr].r;
					leds1[adr_fat].g = leds1[adr].g;
					leds1[adr_fat].b = leds1[adr].b;

					leds3[adr_fat].r = leds3[adr].r;
					leds3[adr_fat].g = leds3[adr].g;
					leds3[adr_fat].b = leds3[adr].b;

					leds2[adr2_fat].r = leds2[adr2].r;
					leds2[adr2_fat].g = leds2[adr2].g;
					leds2[adr2_fat].b = leds2[adr2].b;

					leds4[adr2_fat].r = leds4[adr2].r;
					leds4[adr2_fat].g = leds4[adr2].g;
					leds4[adr2_fat].b = leds4[adr2].b;


					if (keep == 0)  // turn off parent pixels
					{
						leds1[adr].r = 0;
						leds1[adr].g = 0;
						leds1[adr].b = 0;

						leds3[adr].r = 0;
						leds3[adr].g = 0;
						leds3[adr].b = 0;

						leds2[adr2].r = 0;
						leds2[adr2].g = 0;
						leds2[adr2].b = 0;

						leds4[adr2].r = 0;
						leds4[adr2].g = 0;
						leds4[adr2].b = 0;

					}
				}


			}

		}

		if (dir == 2)  // add pixels to the right
		{

			for (int x = NUM_COLUMNS - 2; x >= 0; --x)  // fatten to the right
			{
				adr = GET_XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);

				adr_fat = GET_XY_ADR(x + 1, y);
				if (x + 1 == NUM_COLUMNS - 1) { adr_fat = adr; }  // prevent pile up at outter column

				adr2_fat = modify_adr(0, 0, adr_fat);



				if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))  // pixel is lit
				{
					leds1[adr_fat].r = leds1[adr].r;
					leds1[adr_fat].g = leds1[adr].g;
					leds1[adr_fat].b = leds1[adr].b;

					leds3[adr_fat].r = leds3[adr].r;
					leds3[adr_fat].g = leds3[adr].g;
					leds3[adr_fat].b = leds3[adr].b;

					leds2[adr2_fat].r = leds2[adr2].r;
					leds2[adr2_fat].g = leds2[adr2].g;
					leds2[adr2_fat].b = leds2[adr2].b;

					leds4[adr2_fat].r = leds4[adr2].r;
					leds4[adr2_fat].g = leds4[adr2].g;
					leds4[adr2_fat].b = leds4[adr2].b;


					if (keep == 0)  // turn off parent pixels
					{
						leds1[adr].r = 0;
						leds1[adr].g = 0;
						leds1[adr].b = 0;

						leds3[adr].r = 0;
						leds3[adr].g = 0;
						leds3[adr].b = 0;

						leds2[adr2].r = 0;
						leds2[adr2].g = 0;
						leds2[adr2].b = 0;

						leds4[adr2].r = 0;
						leds4[adr2].g = 0;
						leds4[adr2].b = 0;

					}
				}


			}

		}

	}



}

/////////////////////////////////////////////////////////
void FATTEN_VERT(int dir, int keep)  //FATTEN pixels by adding new pixels to dir=top down (1) or dir =bottom up (2)  , keep=1 to keep parent pixels
{

	int adr;
	int adr_fat;
	int adr2;
	int adr2_fat;


	for (int x = 0; x < NUM_COLUMNS; ++x)
	{
		if (dir == 1)  // add pixels to the bottom
		{

			for (int y = 1; y < NUM_ROWS; ++y)  // fatten going down
			{
				adr = GET_XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);

				adr_fat = GET_XY_ADR(x, y - 1);
				if (y == 1) { adr_fat = adr; }  // prevent pile up on column 0

				adr2_fat = modify_adr(0, 0, adr_fat);

				if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))  // pixel is lit
				{
					leds1[adr_fat].r = leds1[adr].r;
					leds1[adr_fat].g = leds1[adr].g;
					leds1[adr_fat].b = leds1[adr].b;

					leds3[adr_fat].r = leds3[adr].r;
					leds3[adr_fat].g = leds3[adr].g;
					leds3[adr_fat].b = leds3[adr].b;

					leds2[adr2_fat].r = leds2[adr2].r;
					leds2[adr2_fat].g = leds2[adr2].g;
					leds2[adr2_fat].b = leds2[adr2].b;

					leds4[adr2_fat].r = leds4[adr2].r;
					leds4[adr2_fat].g = leds4[adr2].g;
					leds4[adr2_fat].b = leds4[adr2].b;


					if (keep == 0)  // turn off parent pixels
					{
						leds1[adr].r = 0;
						leds1[adr].g = 0;
						leds1[adr].b = 0;

						leds3[adr].r = 0;
						leds3[adr].g = 0;
						leds3[adr].b = 0;

						leds2[adr2].r = 0;
						leds2[adr2].g = 0;
						leds2[adr2].b = 0;

						leds4[adr2].r = 0;
						leds4[adr2].g = 0;
						leds4[adr2].b = 0;

					}
				}


			}

		}

		if (dir == 2)  // add pixels to the top
		{

			for (int y = NUM_ROWS - 2; y >= 0; --y)  // fatten going up
			{
				adr = GET_XY_ADR(x, y);
				adr2 = modify_adr(0, 0, adr);

				adr_fat = GET_XY_ADR(x, y + 1);
				if (y + 1 == NUM_ROWS - 1) { adr_fat = adr; }  // prevent pile up at outter column

				adr2_fat = modify_adr(0, 0, adr_fat);



				if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))  // pixel is lit
				{
					leds1[adr_fat].r = leds1[adr].r;
					leds1[adr_fat].g = leds1[adr].g;
					leds1[adr_fat].b = leds1[adr].b;

					leds3[adr_fat].r = leds3[adr].r;
					leds3[adr_fat].g = leds3[adr].g;
					leds3[adr_fat].b = leds3[adr].b;

					leds2[adr2_fat].r = leds2[adr2].r;
					leds2[adr2_fat].g = leds2[adr2].g;
					leds2[adr2_fat].b = leds2[adr2].b;

					leds4[adr2_fat].r = leds4[adr2].r;
					leds4[adr2_fat].g = leds4[adr2].g;
					leds4[adr2_fat].b = leds4[adr2].b;


					if (keep == 0)  // turn off parent pixels
					{
						leds1[adr].r = 0;
						leds1[adr].g = 0;
						leds1[adr].b = 0;

						leds3[adr].r = 0;
						leds3[adr].g = 0;
						leds3[adr].b = 0;

						leds2[adr2].r = 0;
						leds2[adr2].g = 0;
						leds2[adr2].b = 0;

						leds4[adr2].r = 0;
						leds4[adr2].g = 0;
						leds4[adr2].b = 0;

					}
				}


			}

		}

	}

}

//////////////////////////////////////////////////////////
void SAVE_BACKGROUND()  // save the current image to leds_saved position 0
{
	for (int n = 0; n < NUM_LEDS; ++n)  // save LEDs
	{
		//	leds_background[n] = leds1[n];
		leds_saved[0][n] = leds1[n];  // background
	}
}


//////////////////////////////////////////////////////////////////
void MIRROR_MID_HOZ(byte direction) // mirror the display around the middle of the display...horizontally
// direction = 1 if mirror from closeset to spin axis to outer LEDs, direction =2 if mirror from outer LEDS to closest to spin axis
{

	int adr;
	int adr2;
	int adr_mod;
	int adr2_mod;


	for (int y = 0; y < NUM_ROWS; ++y)
	{

		for (int x = 0; x < NUM_COLUMNS / 2; ++x)
		{
			adr2 = GET_XY_ADR((NUM_COLUMNS - 1 - x), y);
			adr = GET_XY_ADR(x, y);

			if (direction == 1)
			{
				leds1[adr2] = leds1[adr];
				leds3[adr2] = leds3[adr];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr2_mod] = leds2[adr_mod];
				leds4[adr2_mod] = leds4[adr_mod];

			}

			if (direction == 2)
			{
				leds1[adr] = leds1[adr2];
				leds3[adr] = leds3[adr2];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr_mod] = leds2[adr2_mod];
				leds4[adr_mod] = leds4[adr2_mod];

			}

		}
	}

}

//////////////////////////////////////////////////////////////////
void MIRROR_MID_VERT(byte direction) // mirror the display around the middle of the display...vertically
// direction = 1 if mirror from bottom to top LEDs, direction =2 if mirror from top to bottom LEDs
{

	int adr;
	int adr2;
	int adr_mod;
	int adr2_mod;


	for (int x = 0; x < NUM_COLUMNS; ++x)
	{

		for (int y = 0; y < NUM_ROWS / 2; ++y)
		{
			adr2 = GET_XY_ADR(x, (NUM_ROWS - 1 - y));
			adr = GET_XY_ADR(x, y);

			if (direction == 1)
			{
				leds1[adr2] = leds1[adr];
				leds3[adr2] = leds3[adr];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr2_mod] = leds2[adr_mod];
				leds4[adr2_mod] = leds4[adr_mod];

			}

			if (direction == 2)
			{
				leds1[adr] = leds1[adr2];
				leds3[adr] = leds3[adr2];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr_mod] = leds2[adr2_mod];
				leds4[adr_mod] = leds4[adr2_mod];

			}

		}
	}




}


//////////////////////////////////////////////////////////////////
void MIRROR_MID_DIAG(byte direction) // mirror the display around a diagnal of the display...vertically
// direction = 1 right diag: bottom to top; 
// direction = 2 right diag : top to bottom;
// direction = 3 left diag: bottom to top; 
// direction = 4 left diag : top to bottom;
{
	int y_line;
	int y2;
	int x2;


	int adr;
	int adr2;
	int adr_mod;
	int adr2_mod;


	if (direction == 1)  // bottom to top
	{
		///////  y=x  //////////////////
		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			y_line = x;

			for (int y = 0; y < y_line; ++y)
			{
				x2 = y;
				y2 = x;

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x2, y2);

				leds1[adr2] = leds1[adr];
				leds3[adr2] = leds3[adr];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr2_mod] = leds2[adr_mod];
				leds4[adr2_mod] = leds4[adr_mod];


			}
		}

	}


	if (direction == 2)  // top to bottom
	{
		///////  y=x  //////////////////
		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			y_line = x;

			for (int y = 0; y < y_line; ++y)
			{
				x2 = y;
				y2 = x;

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x2, y2);

				leds1[adr] = leds1[adr2];
				leds3[adr] = leds3[adr2];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr_mod] = leds2[adr2_mod];
				leds4[adr_mod] = leds4[adr2_mod];


			}
		}

	}

	if (direction == 3)  // left to right
	{
		///////  y=21-x  //////////////////
		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			y_line = NUM_COLUMNS - 1 - x;

			for (int y = 0; y < y_line; ++y)
			{
				x2 = NUM_ROWS - 1 - y;
				y2 = NUM_COLUMNS - 1 - x;

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x2, y2);

				leds1[adr2] = leds1[adr];
				leds3[adr2] = leds3[adr];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr2_mod] = leds2[adr_mod];
				leds4[adr2_mod] = leds4[adr_mod];


			}
		}

	}

	if (direction == 4)  // right to left
	{
		///////  y=21-x  //////////////////
		for (int x = 0; x < NUM_COLUMNS; ++x)
		{
			y_line = NUM_COLUMNS - 1 - x;

			for (int y = 0; y < y_line; ++y)
			{
				x2 = NUM_ROWS - 1 - y;
				y2 = NUM_COLUMNS - 1 - x;

				adr = GET_XY_ADR(x, y);
				adr2 = GET_XY_ADR(x2, y2);

				leds1[adr] = leds1[adr2];
				leds3[adr] = leds3[adr2];

				adr_mod = modify_adr(0, 0, adr);
				adr2_mod = modify_adr(0, 0, adr2);

				leds2[adr_mod] = leds2[adr2_mod];
				leds4[adr_mod] = leds4[adr2_mod];


			}
		}

	}





}

///////////////////////////////////////////////////////////////////
byte COLOR_STRIPE_ROLL_VERT(byte width_of_color_band, byte repeats, int display_time, byte direction)  // roll color stripes of given width through image from bottom to top, direction=1 for bottom up , =2 for top down
// return 1 if interrupted by a BT command
{

	// SAVE_BACKGROUND();

	int band_count = 0;
	int hue = 0;
	//int hue_previous = 0;
	int rn = 0;
	int band_color_map[NUM_ROWS];  // keep track of what hue was used for a wave
	byte bt_received = 0;



	int adr;
	int adr2;
	byte y = 0;


	for (int n = 0; n < repeats; ++n)
	{


		// initialize band_color_map
		for (int n = 0; n < NUM_ROWS; ++n)
		{
			band_color_map[n] = -1;  // negative number means leave color alone
		}


		rn = random(0, MAX_HUES - 1);
		hue = hues[rn];  // differnt colors to chose from in HSV color space: RED,YELLOW,GREEN,AQUA,BLUE,PURPLE
		band_color_map[0] = hue;
		//	hue_previous = hue; 

		for (int row = 0; row < NUM_ROWS; ++row)
		{
			y = -1;

			for (int k = 0; k < NUM_ROWS; ++k)
			{

				if (direction == 1)
				{
					++y;
				}

				if (direction == 2)
				{
					y = NUM_ROWS - 1 - k;
				}


				for (int x = 0; x < NUM_COLUMNS; ++x)
				{

					adr = GET_XY_ADR(x, y);
					adr2 = modify_adr(0, 0, adr);

					if ((leds1[adr].r != 0) || (leds1[adr].g != 0) || (leds1[adr].b != 0))  // pixel is lit
					{

						if (band_color_map[k] > 0)
							//	if (band_color_map[y] > 0)
						{

							hue = band_color_map[k];

							//	if (hue == hue_previous)  // detect when a blank line is needed
							{
								leds1[adr] = CHSV(hue, 255, 255);
								leds3[adr] = CHSV(hue, 255, 255);

								leds2[adr2] = CHSV(hue, 255, 255);
								leds4[adr2] = CHSV(hue, 255, 255);
							}
							//else
							//{
							//	
							//	leds1[adr] = CRGB(1,0, 0);  // dark region
							//	leds3[adr] = CRGB(1, 0, 0);

							//	leds2[adr2] = CRGB(1, 0, 0);
							//	leds4[adr2] = CRGB(1, 0, 0);
							//}
						}


					}

				}
				//hue_previous = hue;

			}



			for (int n = NUM_ROWS - 1; 0 < n; --n) // shift band_color_map array
			{
				band_color_map[n] = band_color_map[n - 1];
			}

			++band_count;



			if (band_count >= width_of_color_band)  // pick a new color
			{
				band_count = 0;

				rn = random(0, MAX_HUES - 1);
				hue = hues[rn];
				band_color_map[0] = hue;

			}



			SHOW_slow();
			bt_received = BT_DELAY(display_time);
			if (bt_received == 1) { return 1; }
		}


	}

	return 0;

}

///////////////////////////////////////////////////////////////////
byte COLOR_STRIPE_ROLL_HOZ(byte width_of_color_band, byte repeats, int display_time, byte direction)  // roll color stripes of given width through image from inner to outter, 
// direction=1 for inner to outter , =2 for outter to inner
// return 1 if interrupted by a BT command
{

	// SAVE_BACKGROUND();

	int band_count = 0;
	int hue = 0;
	//int hue_previous = 0;
	int rn = 0;
	int band_color_map[NUM_ROWS];  // keep track of what hue was used for a wave
	byte bt_received = 0;



	int adr;
	int adr2;
	byte x = 0;


	for (int n = 0; n < repeats; ++n)
	{


		// initialize band_color_map
		for (int n = 0; n < NUM_ROWS; ++n)
		{
			band_color_map[n] = -1;  // negative number means leave color alone
		}


		rn = random(0, MAX_HUES - 1);
		hue = hues[rn];  // differnt colors to chose from in HSV color space: RED,YELLOW,GREEN,AQUA,BLUE,PURPLE
		band_color_map[0] = hue;
		//	hue_previous = hue; 

		for (int column = 0; column < NUM_COLUMNS; ++column)
		{
			x = -1;

			for (int k = 0; k < NUM_COLUMNS; ++k)
			{

				if (direction == 1)
				{
					++x;
				}

				if (direction == 2)
				{
					x = NUM_COLUMNS - 1 - k;
				}


				for (int y = 0; y < NUM_ROWS; ++y)
				{

					adr = GET_XY_ADR(x, y);
					adr2 = modify_adr(0, 0, adr);

					if ((leds1[adr].r != 0) || (leds1[adr].g != 0) || (leds1[adr].b != 0))  // pixel is lit
					{

						if (band_color_map[k] > 0)
							//	if (band_color_map[y] > 0)
						{

							hue = band_color_map[k];

							//	if (hue == hue_previous)  // detect when a blank line is needed
							{
								leds1[adr] = CHSV(hue, 255, 255);
								leds3[adr] = CHSV(hue, 255, 255);

								leds2[adr2] = CHSV(hue, 255, 255);
								leds4[adr2] = CHSV(hue, 255, 255);
							}
							//else
							//{
							//	
							//	leds1[adr] = CRGB(1,0, 0);  // dark region
							//	leds3[adr] = CRGB(1, 0, 0);

							//	leds2[adr2] = CRGB(1, 0, 0);
							//	leds4[adr2] = CRGB(1, 0, 0);
							//}
						}


					}

				}
				//hue_previous = hue;

			}



			for (int n = NUM_ROWS - 1; 0 < n; --n) // shift band_color_map array
			{
				band_color_map[n] = band_color_map[n - 1];
			}

			++band_count;



			if (band_count >= width_of_color_band)  // pick a new color
			{
				band_count = 0;

				rn = random(0, MAX_HUES - 1);
				hue = hues[rn];
				band_color_map[0] = hue;

			}



			SHOW_slow();
			bt_received = BT_DELAY(display_time);
			if (bt_received == 1) { return 1; }
		}


	}

	return 0;

}

////////////////////
void SIGNAL(int hue, int height)  // generate a signal on the display
{
	//////////////////////////


	 // return ;  //******   comment this out to make SIGNAL in-active

	/////////////////////////

	int x = 11;
	int y = 11;
	int adr = 0;
	int adr2 = 0;

	for (int n = 0; n < height; ++n)
	{

		adr = GET_XY_ADR(x, y + n);
		adr2 = modify_adr(0, 0, adr);

		leds1[adr] = CHSV(hue, 255, 255);
		leds3[adr] = CHSV(hue, 255, 255);

		leds2[adr2] = CHSV(hue, 255, 255);
		leds4[adr2] = CHSV(hue, 255, 255);

	}

	SHOW_slow();
	delay(800);

	for (int n = 0; n < height; ++n)
	{
		adr = GET_XY_ADR(x, y + n);
		adr2 = modify_adr(0, 0, adr);

		leds1[adr] = CRGB(0, 0, 0);
		leds3[adr] = CRGB(0, 0, 0);

		leds2[adr2] = CRGB(0, 0, 0);
		leds4[adr2] = CRGB(0, 0, 0);
	}

	SHOW_slow();
	delay(300);



}




///////////////////////////////////////////////////////////////////////
void CART2CYLIN(double x, double y, double z)     // calculate G_radius, G_angle, G_z  given (x,y,x)  :  G_angle in degrees (0 to 360)
{
	double rads = 0;

	G_radius = sqrt((x * x) + (y * y));
	G_z = z;
	rads = atan2(x, y);

	G_angle = rads * (180 / PI);  // convert to degrees 

	if (G_angle < 0) { G_angle = G_angle + 360; }  // eliminate negative angles

	G_flash_angle = int(G_max_flashes * G_angle / 360);

	//Serial.println(F("-->CART2CYLIN"));
	//Serial.print(F("x= "));
	//Serial.print(x);
	//Serial.print(F("  y= "));
	//Serial.print(y);
	//Serial.print(F("  z= "));
	//Serial.println(z);
	//Serial.print(F("G_radius= "));
	//Serial.println(G_radius);
	//Serial.print(F("G_angle= "));
	//Serial.println(G_angle);
	//Serial.print(F("G_z= "));
	//Serial.println(G_z);
	//Serial.print(F("G_startup_max_flashes= "));
	//Serial.println(G_startup_max_flashes);
	//Serial.print(F("G_flash_angle= "));
	//Serial.println(G_flash_angle);
	//Serial.println("");

}

//////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// FLASH draw a line between given paired verticies at a given rotation angle
// paired verticies are specified as adjacent entries in the verticies[] array
void FLASH_DRAW_LINE(byte v1, byte v2)  // v1 and v2 are indexs for verts[] array which contains shape verticies.  A line is drawn from v1 to v2
// note: it is assummed that this function is called immediately after a HALL_SYNC2(); 
{
	byte active_columns = 6;  // number of active columns
	int num_leds = active_columns * 22; // number of active LEDs
	byte delta_flash_angle = 0;  // cyln coordinate angle difference betweent verts[v1] and verts[v2]
	byte flash_angle1 = 0;
	byte flash_angle2 = 0;
	double dx = 0;
	double dy = 0;
	double dz = 0;
	double L = verts[v2].x - verts[v1].x;
	double M = verts[v2].y - verts[v1].y;
	double N = verts[v2].z - verts[v1].z;
	byte blank = 2;  // number of flashes to decrease G_max_flashes by to prevent roll around
	double x = verts[v1].x;
	double y = verts[v1].y;
	double z = verts[v1].z;

	int angle1;  // for testing
	int angle2;  // for testing
	byte radius;

	int adr = 0;
	int adr_mod = 0;

	//verts[0] = { 21,21,21 };  // top right 
	//verts[1] = { 21,-21,21 }; // top left

	CART2CYLIN(verts[v1].x, verts[v1].y, verts[v1].z);
	flash_angle1 = G_flash_angle;
	angle1 = G_angle;

	CART2CYLIN(verts[v2].x, verts[v2].y, verts[v2].z);
	flash_angle2 = G_flash_angle;
	angle2 = G_angle;

	delta_flash_angle = abs(flash_angle2 - flash_angle1); // in degrees

	if (delta_flash_angle == 0) { delta_flash_angle = 1; }  // prevent devide by 0

	dx = L / delta_flash_angle;  // find x increment
	dy = M / delta_flash_angle;  // find y increment
	dz = N / delta_flash_angle;  // find z increment

	Serial.println(F("-->FLASH_DRAW_LINE"));
	Serial.print(F("dx= "));
	Serial.print(dx);
	Serial.print(F("  dy= "));
	Serial.print(dy);
	Serial.print(F("  dz= "));
	Serial.println(dz);
	Serial.print(F("delta_flash_angle= "));
	Serial.println(delta_flash_angle);
	Serial.print(F("flash_angle1= "));
	Serial.println(flash_angle1);
	Serial.print(F("flash_angle2="));
	Serial.println(flash_angle2);
	Serial.print(F("angle1="));
	Serial.println(angle1);
	Serial.print(F("angle2="));
	Serial.println(angle2);
	Serial.println("");


	for (byte n = 0; n < G_max_flashes - blank; ++n)  // display loop
	{
		if ((n >= flash_angle1) && (n <= flash_angle2))  // only draw between angles between the verticies
		{

			CART2CYLIN(x, y, z);  // finds G_radius and G_z

			radius = byte((.7071 * (G_radius))) + 1;  // normalize so maximum radius = 21

			if (radius < (22 - active_columns)) { radius = (22 - active_columns); }  // make sure something is lit 


			adr = GET_XY_ADR(radius, G_z);
			adr_mod = modify_adr(0, 0, adr);

			leds1[adr] = CRGB(255, 255, 255);
			//		leds3[adr] = CRGB(255, 255, 255);
			leds2[adr_mod] = CRGB(255, 255, 255);
			//		leds4[adr_mod] = CRGB(255, 255, 255);

			SHOW_var(num_leds);
			FastLED.clear();

			Serial.println(F("-->** FLASH_DRAW_LINE: 2"));
			Serial.print(F("x= "));
			Serial.print(x);
			Serial.print(F("  y= "));
			Serial.print(y);
			Serial.print(F("  z= "));
			Serial.println(z);
			Serial.print(F("  G_radius= "));
			Serial.println(G_radius);
			Serial.print(F("  radius= "));
			Serial.println(radius);
			Serial.print(F("  G_angle= "));
			Serial.println(G_angle);
			Serial.println("");





			x = x + dx;
			y = y + dy;
			z = z + dz;


		}
		else
		{
			SHOW_var(num_leds);
		}

	}


}




////////////////////////////////////////////////////////////////////
// FLASH draw a line from v1 to v2....the flash angle is specified as flash =  0 to G_max_flashes range
void FLASH_DRAW_CYLIN_CORDINATES(byte v1, byte v2, byte flash, int hue, byte depth)  // v1 and v2 are indexes for cyclindracal cylin[#] = cylindrical coordinates
// note: it is assummed that this function is called after a HALL_SYNC2();
// note: it is assummed that SET_VAR(number of active leds) has been previously called ... which sets G_active
// flash = flash angle being processed
// depth = number of LEDs lit starting with outter LEDs first

{

	if ((G_Hall_sync != 1) || (digitalRead(HEAD_COM) == 1)) { return; }  // prevents devide by 0 crash

	//Serial.print(F("FLASH_DRAW_CYLIN_CORDINATES: v1= "));
	//Serial.println(v1);
	//Serial.println("");


	byte force_blue_red = 0;  // set to 1 to show panels 1,2 in RED and panels 3,4 in BLUE...  set to 2 to disable panels 3 and 4.... set to 3 to disable panels 1 and 2

	//if ((v1 == 1) && (v2 == 2))  // TEST ONLY
	//{
	//	Serial.println(F("******************************************** START "));  
	//	Serial.println("");
	//}

	byte S = 255;
	byte V = 255;

	if (hue == -1)  // white
	{
		S = 0;
		V = 255;
		hue = 0;
	}




	//byte blanks = 5; // blanks = how many flashs less than G_max_flashes to draw ... need to prevent roll over...was 4
	//if (flash > (G_max_flashes - blanks))  // this is needed to prevent flash2 draws which will be incorrect
	//{
	//	FastLED.clear();
	//	return;
	//}


	cylindrical t_cylin[2];  // temporary coordinates needed to re-order cylin(v1) and cylin(v2) so z of v1 is less than z of v2

	//// swap based on z such that t_cylin[0].z < t_cylin[1].z
	//if (cylin[v1].z > cylin[v2].z)
	//{
	//	t_cylin[0] = cylin[v2];
	//	t_cylin[1] = cylin[v1];
	//}
	//else
	//{
	//	t_cylin[1] = cylin[v2];
	//	t_cylin[0] = cylin[v1];
	//}

	// swap based on angle such that t_cylin[0].angle < t_cylin[1].angle
	if (cylin[v1].angle > cylin[v2].angle)
	{
		t_cylin[0].angle = cylin[v2].angle;
		t_cylin[0].radius = cylin[v2].radius;
		t_cylin[0].z = cylin[v2].z;

		t_cylin[1].angle = cylin[v1].angle;
		t_cylin[1].radius = cylin[v1].radius;
		t_cylin[1].z = cylin[v1].z;

		//t_cylin[0] = cylin[v2];
		//t_cylin[1] = cylin[v1];
	}
	else
	{
		t_cylin[0].angle = cylin[v1].angle;
		t_cylin[0].radius = cylin[v1].radius;
		t_cylin[0].z = cylin[v1].z;

		t_cylin[1].angle = cylin[v2].angle;
		t_cylin[1].radius = cylin[v2].radius;
		t_cylin[1].z = cylin[v2].z;


		//t_cylin[1] = cylin[v2];
		//t_cylin[0] = cylin[v1];
	}





	//Serial.println(F("-->FLASH_DRAW_CYLIN_CORDINATES:  1"));

	//////////////////
	float z_span = (t_cylin[1].z - t_cylin[0].z);  // delta z
	float z_direction = 1;  // equals 1 if changes from low ROW to high ROW, equals -1 if high ROW to low ROW, =0 if no z change

	if (z_span < 0)
	{
		z_direction = -1;
	}

	if (z_span == 0)
	{
		z_direction = 0;
	}

	z_span = abs(z_span);

	//////////////////

	float radius_span = t_cylin[1].radius - t_cylin[0].radius;
	float radius_direction = 1; // equals 1 if radius changes from smaller to larger, equals -1 if change if larger to smaller

	if (radius_span < 0)
	{
		radius_direction = -1;
	}

	radius_span = abs(radius_span);


	////////////
	if (t_cylin[0].angle >= 360)  // keep in range
	{
		t_cylin[0].angle = t_cylin[0].angle - 360;
	}


	if (t_cylin[1].angle >= 360)  // keep in range
	{
		t_cylin[1].angle = t_cylin[1].angle - 360;
	}

	// Adjust angle so it is centered in quantization of flashes for more reliable flashing of panels 3,4
	int quantized_angle_increment = 360 / G_max_flashes;
	int increments = t_cylin[0].angle / quantized_angle_increment;

	t_cylin[0].angle = quantized_angle_increment * (increments + .5);  // angle is now centered in middle of flash

	increments = t_cylin[1].angle / quantized_angle_increment;
	t_cylin[1].angle = quantized_angle_increment * (increments + .5);  // angle is now centered in middle of flash





	byte flash_start = byte(G_max_flashes * t_cylin[0].angle / 360);  // for panels 1 and 2
	byte flash_end = byte(G_max_flashes * t_cylin[1].angle / 360);  // for panels 1 and 2
	float num_flashes = 1 + flash_end - flash_start;
	float flash_pointer = 0;

	if ((flash >= flash_start) && (flash <= flash_end))  // find where "flash" is relative to flash_start and flash_end, 1=flash at flash_start
	{
		flash_pointer = (flash - flash_start) + 1;
	}


	byte radius = t_cylin[0].radius;


	float z = t_cylin[0].z;

	//byte radius2 = t_cylin[0].radius;  
	byte radius2 = t_cylin[1].radius;

	float z2 = t_cylin[0].z;

	///////////////// guards  //////////////////
	if (cylin[v1].radius < G_first_active_column)  // guard...G_first_active_column is calculated in SET_VAR()
	{
		cylin[v1].radius = G_first_active_column;
	}

	if (cylin[v1].radius >= NUM_COLUMNS) { cylin[v1].radius = NUM_COLUMNS - 1; }

	if (cylin[v2].radius < G_first_active_column)  // guard...G_first_active_column is calculated in SET_VAR()
	{
		cylin[v2].radius = G_first_active_column;
	}

	if (cylin[v2].radius >= NUM_COLUMNS) { cylin[v2].radius = NUM_COLUMNS - 1; }

	/////////////////////////////////////////////

	int adr;
	int adr_mod;

	//float radius_span = abs(cylin[v2].radius - cylin[v1].radius); // delta radius

	float dr = radius_span / num_flashes;  // change in radius per flash
	float dz = z_span / num_flashes;
	byte columns = G_active / NUM_ROWS;  // calculate number of active columns

	int z_current = int(z);

	byte skip = 0;

	byte adjust = 0;  // a hack to fix fill
	byte dr_flag = 0;  // 0 if dr is based on radius_span, 1 if dr is based on z_span, 2 if based radius alone within a small number of flashes

	byte start_radius = t_cylin[0].radius;
	byte stop_radius = t_cylin[1].radius;



	//int z2_next = int(z2);
	//int zint = int(z);
	//int zint2 = int(z2);




	///////////////
	int flash2;  // flash for panels 3,4

	if (flash < G_max_flashes / 2)  // calculate offset between panels 1,2 and 3,4 
	{
		flash2 = (flash + G_max_flashes / 2);

	}

	if (flash >= G_max_flashes / 2)
	{
		flash2 = (flash - G_max_flashes / 2);

	}



	//Serial.print(F("$$$$$$$$$$$$$$$$$-->FLASH_FLASH_DRAW_CYLIN_CORDINATES: flash="));
	//Serial.println(flash);
	//Serial.print(F("G_max_flashes= "));
	//Serial.println(G_max_flashes);
	//Serial.print(F("G_max_flashes/2= "));
	//Serial.println(G_max_flashes / 2);
	//Serial.print(F("flash2= "));
	//Serial.println(flash2);
	//Serial.print(F("flash_start= "));
	//Serial.println(flash_start);
	//Serial.print(F("flash_end= "));
	//Serial.println(flash_end);
	//Serial.println("");


	if (depth > columns) { depth = columns; }

	//Serial.println(F("-->FLASH_FLASH_DRAW_CYLIN_CORDINATES:  0"));
	//Serial.print(F("columns= "));
	//Serial.println(columns);
	//Serial.print(F("G_active= "));
	//Serial.println(G_active);
	//Serial.print(F("dr= "));
	//Serial.print(dr);
	//Serial.print(F("  dz= "));
	//Serial.println(dz);
	//Serial.print(F("flash_start= "));
	//Serial.println(flash_start);
	//Serial.print(F("flash_end= "));
	//Serial.println(flash_end);
	//Serial.print(F("flash= "));
	//Serial.println(flash);
	//Serial.print(F("radius_span="));
	//Serial.println(radius_span);
	//Serial.print(F("z_span="));
	//Serial.println(z_span);
	//Serial.print(F("num_flashes="));
	//Serial.println(num_flashes);
	//Serial.print(F("G_max_flashes="));
	//Serial.println(G_max_flashes);
	//Serial.println("");


	//Serial.print(F("start2_angle fraction= "));
	//Serial.println(start2_angle);
	//Serial.print(F("end2_angle fraction= "));
	//Serial.println(end2_angle);
	//Serial.print(F("flash2_start= "));
	//Serial.println(flash2_start);
	//Serial.print(F("flash2_end= "));
	//Serial.println(flash2_end);
	//Serial.println("");


	/*
	z_next is to fill in between z jumps
	For short angle spans and large z changes between end points...the delta z for each flash is large.
	Thus I need to fill in the z's between the flashes


	*/

	// below is necessary to fix improper z fill for some lines
	if (((cylin[v1].angle < cylin[v2].angle) && (cylin[v1].z <= cylin[v2].z)) || ((cylin[v1].angle > cylin[v2].angle) && (cylin[v1].z >= cylin[v2].z)))
	{
		adjust = 1;
	}

	//adjust = 1; // testing only

	//Serial.println(F("-->FLASH_DRAW_CYLIN_CORDINATES:  1"));
	//Serial.print(F("radius_span="));
	//Serial.println(radius_span);
	//Serial.print(F("z_span="));
	//Serial.println(z_span);
	//Serial.print(F("num_flashes="));
	//Serial.println(num_flashes);
	//Serial.print(F("adjust="));
	//Serial.println(adjust);

	//Serial.print(F("(cylin[v1].angle="));
	//Serial.println(cylin[v1].angle);
	//Serial.print(F("(cylin[v2].angle="));
	//Serial.println(cylin[v2].angle);
	//Serial.print(F("(cylin[v1].z="));
	//Serial.println(cylin[v1].z);
	//Serial.print(F("(cylin[v2].z="));
	//Serial.println(cylin[v2].z);
	//Serial.println("");



	//determine if dr will be based on flash or dz or along radius
	if ((z_span < radius_span) && (radius_span <= num_flashes)) // handles horizontal lines
	{
		dr_flag = 0;  // dr based on flashes
	}


	if ((z_span >= num_flashes) || (z_span > radius_span))
		//	if ((z_span >= num_flashes))
	{
		dr_flag = 1;  // dr based on z_span 
	}

	//if ((z_span < radius_span) && (radius_span > num_flashes))
	//{
	//	dr_flag = 2;  // dr based on radius alone 
	//}

	if ((z_span < num_flashes) && (radius_span > 0) && (z_span <= radius_span))  // handle case where line goes straight from outside radius to inside radius
		//if ((z_span < num_flashes) && (radius_span > 0))  // handle case where line goes straight from outside radius to inside radius
	{
		dr_flag = 2;  // dr based on radius alone , columns will be decremented to fill line
	}


	//dr_flag = 2;  // test only

///////////////////
	//determine if dr will be based on flash or dz
	//if ((z_span > num_flashes))
	//{
	//	dr_flag = 1;  // dr based on z_span 
	//}

	//Serial.print(F("--------->FLASH_DRAW_CYLIN_CORDINATES:2:  flash="));
	//Serial.println(flash);
	//Serial.print(F("dr_flag="));
	//Serial.println(dr_flag);
	//Serial.print(F("flash_start="));
	//Serial.println(flash_start);
	//Serial.print(F("flash_end="));
	//Serial.println(flash_end);
	//Serial.println("");

		////////// do panels 1 and 2 /////////////////////////////////
	if ((flash >= flash_start) && (flash <= flash_end) && (force_blue_red != 3))  // only draw between the verticies
	{
		//		Serial.println(F("-->FLASH_DRAW_CYLIN_CORDINATES:  3"));


		if (force_blue_red == 1) { hue = 0; }  //RED for testing



		//flash_psdo = flash; 

		float z2 = z + z_direction * (flash + 1 - flash_start) * dz;  //  target z for sucessive flashs

		z = z + z_direction * (flash - flash_start) * dz;  // value for z based on flash


		//Serial.println(F("2:  -->FLASH_FLASH_DRAW_CYLIN_CORDINATES"));
		//Serial.print(F("z = "));
		//Serial.println(z);

		int z_current = int(z);


		// find radius
		if (dr_flag == 0)  // dr based on flash
		{
			radius = radius + (flash - flash_start) * dr * radius_direction;
		}

		//Serial.println(F("-->FLASH_DRAW_CYLIN_CORDINATES   4"));
		//Serial.print(F("z2= "));
		//Serial.println(z2);
		//Serial.print(F("z_current= "));
		//Serial.println(z_current);
		//Serial.print(F("adjust= "));
		//Serial.println(adjust);
		//Serial.print(F("radius= "));
		//Serial.println(radius);
		//Serial.print(F("G_first_active_column= "));
		//Serial.println(G_first_active_column);
		//Serial.println("");


		//Serial.print(F("dz= "));
		//Serial.println(dz);
		//Serial.print(F("flash= "));
		//Serial.println(flash);
		//Serial.print(F("flash_start= "));
		//Serial.println(flash_start);
		//Serial.println("");

		if (dr_flag == 2) // radius goes in towards the middle, the code below determines the angle at which it goes in
		{

			depth = byte(radius_span / num_flashes);

			if (start_radius >= stop_radius)
			{
				if (flash_pointer > 1)
				{
					//radius = stop_radius + flash_pointer*depth;  // this will angle in the opposite direction of the above.....DON'T DELETE this commented out line
					radius = start_radius - 1 - (flash_pointer - 1) * depth;  // this will angle in the opposite direction of the above commented out line
				}
				else
				{
					radius = start_radius - 1;
				}
			}
			else
			{
				radius = start_radius + flash_pointer * depth;
			}
		}


		//Serial.print(F("flash_start= "));
		//Serial.println(flash_start);
		//Serial.print(F("flash_end= "));
		//Serial.println(flash_end);
		//Serial.print(F("dr_flag= "));
		//Serial.println(dr_flag);
		//Serial.print(F("radius= "));
		//Serial.println(radius);
		//Serial.print(F("depth= "));
		//Serial.println(depth);
		//Serial.print(F("radius_span= "));
		//Serial.println(radius_span);
		//Serial.print(F("num_flashes= "));
		//Serial.println(num_flashes);
		//Serial.print(F("start_radius= "));
		//Serial.println(start_radius);
		//Serial.print(F("stop_radius= "));
		//Serial.println(stop_radius);
		//Serial.print(F("flash_pointer= "));
		//Serial.println(flash_pointer);
		//Serial.println("");



		if (int(z2) > z_current - adjust)  // without "adjust" : yellow bad (TEST 44) , purple good (without adjust: if >= then yellow good, purple bad ..."adjust" fixes this) 
		{
			skip = 1;

			//Serial.println(F("before 1st while "));
			//Serial.print(F("z2= "));
			//Serial.println(z2);
			//Serial.print(F("z_current= "));
			//Serial.println(z_current);
			//Serial.println("");

			while (z_current <= int(z2))  // z2 is the next z value based on the next flash, z_current=the current z value based on the current flash
			{

				if (dr_flag == 1)  // radius increment depends on z
				{
					dr = abs(z_current - t_cylin[0].z) / z_span;

					radius = start_radius + int(dr * radius_span * radius_direction);

				}

				//byte depth_original = depth;

				//if (dr_flag == 2)
				//{
				//	depth = radius_span;

				//	if (start_radius >= stop_radius)
				//	{
				//		radius = start_radius;
				//	}
				//	else
				//	{
				//		radius = stop_radius;
				//	}
				//}

				//Serial.print(F("1: dr_flag= "));
				//Serial.println(dr_flag);
				////Serial.print(F("radius_span= "));
				////Serial.println(radius_span);
				//Serial.print(F("radius= "));
				//Serial.println(radius);
				//Serial.println("");


				for (int col = radius; col > radius - depth; --col)
				{

					if (col < G_first_active_column) { break; }  // prevent trying to change non-active LEDs


					adr = GET_XY_ADR(int(col), z_current);
					adr_mod = modify_adr(0, 0, adr);

					leds1[adr] = CHSV(hue, S, V);

					leds2[adr_mod] = CHSV(hue, S, V);

					//Serial.print(F("1: col= "));
					//Serial.println(col);
					//Serial.print(F("z_current= "));
					//Serial.println(z_current);
					//Serial.println("");



				}

				//z_next = z_next + z_direction;  // z_direction must = 1
				z_current = z_current + 1;

				if (z_direction == 0)
				{
					break;
				}

				if (z_current > NUM_ROWS)
				{

					break;
				}

				if (z_current < 0)
				{

					break;
				}


			}
		}



		if ((int(z2) <= z_current) && (skip == 0))
		{
			//Serial.println(F("before 2nd while "));
			//Serial.println("");

			while (z_current >= int(z2))
			{

				if (dr_flag == 1)  // radius increment depends on z
				{
					dr = abs(z_current - t_cylin[0].z) / z_span;

					radius = start_radius + int(dr * radius_span * radius_direction);

				}

				//if (dr_flag == 2)
				//{
				//	depth = radius_span;
				//	if (start_radius >= stop_radius)
				//	{
				//		radius = start_radius;
				//	}
				//	else
				//	{
				//		radius = stop_radius;
				//	}
				//}

				//Serial.print(F("2: dr_flag= "));
				//Serial.println(dr_flag);
				//Serial.print(F("radius_span= "));
				//Serial.println(radius_span);
				//Serial.print(F("radius= "));
				//Serial.println(radius);
				//Serial.println("");


				//for (byte col = radius; col >= NUM_COLUMNS - depth; --col)
				for (int col = radius; col > radius - depth; --col)
				{
					//if (radius - depth < G_first_active_column) { break; }  // prevent trying to change non-active LEDs
					if (col < G_first_active_column) { break; }  // prevent trying to change non-active LEDs

					adr = GET_XY_ADR(int(col), z_current);
					adr_mod = modify_adr(0, 0, adr);

					leds1[adr] = CHSV(hue, S, V);

					leds2[adr_mod] = CHSV(hue, S, V);

					//Serial.print(F("2: col= "));
					//Serial.println(col);
					//Serial.print(F("z_current= "));
					//Serial.println(z_current);
					//Serial.println("");

				}

				//z_next = z_next + z_direction;
				z_current = z_current - 1;

				if (z_direction == 0)
				{
					break;
				}

				if (z_current > NUM_ROWS)
				{

					break;
				}

				if (z_current < 0)
				{

					break;
				}


			}
		}
	}

	skip = 0;

	//Serial.print(F("------------>  5:  flash2="));
	//Serial.println(flash2);
	//Serial.print(F("flash_start="));
	//Serial.println(flash_start);
	//Serial.print(F("flash_end="));
	//Serial.println(flash_end);


	//Serial.print(F("dr_flag="));
	//Serial.println(dr_flag);
	////Serial.print(F("adjust="));
	////Serial.println(adjust);	
	//Serial.println("");

	//////////  now do panels 3 and 4  ////////////////
	if ((flash2 >= flash_start) && (flash2 <= flash_end) && (force_blue_red != 2))  // only draw between the verticies
	{
		//Serial.println(F("DOING PANELS 3 & 4"));
		//Serial.println(F(""));
		
		z = t_cylin[0].z;

		if (force_blue_red == 1) { hue = 171; }  //BLUE for testing

		if (dr_flag == 0)  // dr based on flash not z
		{
			radius2 = radius2 + (flash2 - flash_start) * dr * radius_direction;
		}

		z2 = z + z_direction * (flash2 + 1 - flash_start) * dz;  //z 2
		z = z + z_direction * (flash2 - flash_start) * dz;  //z 1
		int z_current = int(z);

		//Serial.println(F("-->  6"));
		//Serial.print(F("z2="));
		//Serial.println(z2);
		//Serial.print(F("z_current="));
		//Serial.println(z_current);
		//Serial.print(F("adjust="));
		//Serial.println(adjust);
		//Serial.println("");

		if (dr_flag == 2)
		{
			//depth = radius_span;

			//depth = byte(radius_span * (flash_pointer / num_flashes));

			depth = byte(radius_span / num_flashes);

			if (start_radius >= stop_radius)
			{


				//radius = stop_radius + flash_pointer*depth;
				if (flash_pointer > 1)
				{
					//radius = 1 + start_radius - flash_pointer * depth;  // this will angle in the opposite direction of the above
					radius2 = start_radius - 1 - (flash_pointer - 1) * depth;  // this will angle in the opposite direction of the above
				}
				else
				{
					radius2 = start_radius - 1;
				}

			}
			else
			{
				//radius = stop_radius;


				radius2 = start_radius + flash_pointer * depth;

			}


		}


		if (int(z2) > z_current - adjust)
		{

			skip = 1;  // skip the 2nd while loop

			//Serial.println(F("**98: before while"));
			//Serial.print(F("adjust="));
			//Serial.println(adjust);
			//Serial.print(F("z_direction="));
			//Serial.println(z_direction);
			//Serial.print(F("dr_flag="));
			//Serial.println(dr_flag);
			//Serial.print(F("dz="));
			//Serial.println(dz);
			//Serial.println("");

			while (z_current <= int(z2))   ///////  1st while
			{


				//Serial.println(F("**99***"));
				//Serial.print(F("z_current = "));
				//Serial.println(z_current);
				//Serial.print(F("z2 = "));
				//Serial.println(int(z2));
				//Serial.print(F("flash = "));
				//Serial.println(int(flash));
				//Serial.print(F("flash2 = "));
				//Serial.println(int(flash2));
				//Serial.println("");

					// find radius
				if (dr_flag == 1)  // radius increment depends on z
				{
					dr = abs(z_current - t_cylin[0].z) / z_span;

					radius2 = start_radius + int(dr * radius_span * radius_direction);

				}

				//if (dr_flag == 2)
				//{
				//	depth = radius_span;
				//	if (start_radius >= stop_radius)
				//	{
				//		radius2 = start_radius;
				//	}
				//	else
				//	{
				//		radius2 = stop_radius;
				//	}
				//}


				for (int col = radius2; col > radius2 - depth; --col)
				{
					//if (radius2 - depth < G_first_active_column) { break; }  // prevent trying to change non-active LEDs
					if (col < G_first_active_column) { break; }  // prevent trying to change non-active LEDs

					//adr = GET_XY_ADR(int(col), int(z));
					adr = GET_XY_ADR(int(col), z_current);
					adr_mod = modify_adr(0, 0, adr);

					leds3[adr] = CHSV(hue, S, V);

					leds4[adr_mod] = CHSV(hue, S, V);

					//Serial.print(F("z_current = "));
					//Serial.println(z_current);
					//Serial.print(F("adr = "));
					//Serial.println(int(adr));
					//Serial.println("");

				}

				z_current = z_current + z_direction;

				if (z_direction == 0)
				{
					break;
				}

				if (z_current > NUM_ROWS)
				{
					//	Serial.println(F("break 1 "));
					//	Serial.println("");
					break;
				}

				if (z_current < 0)
				{
					//	Serial.println(F("break 2 "));
					//	Serial.println("");
					break;
				}


			}
		}

		////////////////////

		if ((int(z2) <= int(z)) && (skip == 0))
		{
			while (z_current >= int(z2))   ///////  2nd while
			{
				//Serial.println(F("**100***"));
				//Serial.print(F("z_current = "));
				//Serial.println(z_current);
				//Serial.print(F("z2 = "));
				//Serial.println(int(z2));
				//Serial.print(F("dr_flag = "));
				//Serial.println(dr_flag);
				//Serial.print(F("z_direction = "));
				//Serial.println(z_direction);
				//Serial.print(F("flash = "));
				//Serial.println(int(flash));
				//Serial.print(F("flash2 = "));
				//Serial.println(int(flash2));
				//Serial.println("");


						// find radius
				if (dr_flag == 1)  // radius increment depends on z
				{
					dr = abs(z_current - t_cylin[0].z) / z_span;

					radius2 = start_radius + int(dr * radius_span * radius_direction);

				}

				//if (dr_flag == 2)
				//{
				//	depth = radius_span;
				//	if (start_radius >= stop_radius)
				//	{
				//		radius2 = start_radius;
				//	}
				//	else
				//	{
				//		radius2 = stop_radius;
				//	}
				//}

				for (int col = radius2; col > radius2 - depth; --col)
				{

					//if (radius2 - depth < G_first_active_column) { break; }  // prevent trying to change non-active LEDs
					if (col < G_first_active_column) { break; }  // prevent trying to change non-active LEDs

					adr = GET_XY_ADR(int(col), z_current);
					adr_mod = modify_adr(0, 0, adr);

					leds3[adr] = CHSV(hue, S, V);

					leds4[adr_mod] = CHSV(hue, S, V);

					//Serial.print(F("z_next = "));
					//Serial.println(z_next);
					//Serial.print(F("adr = "));
					//Serial.println(int(adr));
					//Serial.println("");

				}

				z_current = z_current + z_direction;

				if (z_direction == 0)
				{
					break;
				}

				if (z_current > NUM_ROWS)
				{
					//	Serial.println(F("break 1 "));
					//	Serial.println("");
					break;
				}

				if (z_current < 0)
				{
					//	Serial.println(F("break 2 "));
					//	Serial.println("");
					break;
				}


			}
		}

	}



}

/////////////////////////////////////////////////////////////
//void ADJUST_G_max_flashes(float time_per_show_flash, float time_per_flash) // modify G_max_flashes based on difference between the two input parameters
//{
//	Serial.println(F("------> ADJUST_G_max_flashes "));
//	Serial.print(F("before: G_max_flashes= "));
//	Serial.println(G_max_flashes);
//
//	float max_flashes= G_max_flashes;
//	
//
//	max_flashes = max_flashes * (time_per_flash / time_per_show_flash);
//
//	G_max_flashes = int(max_flashes);
//
//	Serial.print(F("after: G_max_flashes= "));
//	Serial.println(G_max_flashes);
//	Serial.println("");
//
//	if (G_max_flashes % 2 != 0)  // make divisible by 2
//	{
//		--G_max_flashes;
//
//	}
//
//
//}



/////////////////////////////////////////////////////
//int GUARD(int rad, byte active_columns)  // insure radius is in range
//{
//	if (rad >= NUM_COLUMNS) { rad = NUM_COLUMNS - 1; }
//	if (rad < NUM_COLUMNS - active_columns) { rad = NUM_COLUMNS - active_columns; }
//
//	return rad;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////// FOR FFT   /////////////////////////////////////////////////////////////////////////////////////////////////////////////

byte min(byte v1, byte v2)  // return the minimum of either v1 or v2
{
	if (v1 > v2) { return v2; }
}


// FFT PATTERNS BELOW
void rainbowBars(int band, int barHeight) {
	int xStart = BAR_WIDTH * band;
	for (int x = xStart; x < xStart + BAR_WIDTH; x++) {
		for (int y = 0; y < barHeight; y++) {
			leds1[XY(x, y)] = CHSV((x / BAR_WIDTH) * (255 / NUM_BANDS), 255, 255);

			leds3[XY(x, y)] = leds1[XY(x, y)];
			int adr2 = modify_adr(0, 0, XY(x, y));   //make image right side up or upside down
			leds2[adr2] = leds1[XY(x, y)];
			leds4[adr2] = leds1[XY(x, y)];
		}
	}

	//FLIP_DISPLAY(); // make HIGH notes on the TOP
}

void purpleBars(int band, int barHeight) {
	int xStart = BAR_WIDTH * band;
	for (int x = xStart; x < xStart + BAR_WIDTH; x++) {
		for (int y = 0; y < barHeight; y++) {
			leds1[XY(x, y)] = ColorFromPalette(purplePal, y * (255 / barHeight));

			leds3[XY(x, y)] = leds1[XY(x, y)];
			int adr2 = modify_adr(0, 0, XY(x, y));   //make image right side up or upside down
			leds2[adr2] = leds1[XY(x, y)];
			leds4[adr2] = leds1[XY(x, y)];
		}
	}

	//FLIP_DISPLAY(); // make HIGH notes on the TOP
}

void changingBars(int band, int barHeight) {
	int xStart = BAR_WIDTH * band;
	for (int x = xStart; x < xStart + BAR_WIDTH; x++) {
		for (int y = 0; y < barHeight; y++) {
			leds1[XY(x, y)] = CHSV(y * (255 / kMatrixHeight) + colorTimer, 255, 255);

			leds3[XY(x, y)] = leds1[XY(x, y)];
			int adr2 = modify_adr(0, 0, XY(x, y));   //make image right side up or upside down
			leds2[adr2] = leds1[XY(x, y)];
			leds4[adr2] = leds1[XY(x, y)];
		}
	}

	//FLIP_DISPLAY(); // make HIGH notes on the TOP
}

void whitePeak(int band) {
	int xStart = BAR_WIDTH * band;
	int peakHeight = peak[band];
	for (int x = xStart; x < xStart + BAR_WIDTH; x++) {
		int y = peakHeight;
		leds1[XY(x, y)] = CRGB::White;

		leds3[XY(x, y)] = leds1[XY(x, y)];
		int adr2 = modify_adr(0, 0, XY(x, y));   //make image right side up or upside down
		leds2[adr2] = leds1[XY(x, y)];
		leds4[adr2] = leds1[XY(x, y)];
	}

	//FLIP_DISPLAY(); // make HIGH notes on the TOP
}

void rainbowPeak(int band) {
	int xStart = BAR_WIDTH * band;
	int peakHeight = peak[band];
	for (int x = xStart; x < xStart + BAR_WIDTH; x++) {
		//leds[XY(x,peakHeight)] = CHSV(peakHeight * (255 / kMatrixHeight), 255, 255);
		
		leds1[XY(x, peakHeight)] = ColorFromPalette(outrunPal, peakHeight * (255 / kMatrixHeight));
		int y = peakHeight;

		leds3[XY(x, y)] = leds1[XY(x, y)];
		int adr2 = modify_adr(0, 0, XY(x, y));   //make image right side up or upside down
		leds2[adr2] = leds1[XY(x, y)];
		leds4[adr2] = leds1[XY(x, y)];
	}

	//FLIP_DISPLAY(); // make HIGH notes on the TOP
}


//void rainbowPeak_fill(int band) {   // adds line from axis to peak
//	int xStart = BAR_WIDTH * band;
//	int peakHeight = peak[band];
//	for (int x = xStart; x < xStart + BAR_WIDTH; x++) {
//		//leds[XY(x,peakHeight)] = CHSV(peakHeight * (255 / kMatrixHeight), 255, 255);
//
//		leds1[XY(x, peakHeight)] = CHSV(peakHeight * (255 / kMatrixHeight), 255, 255);
//		
//		//leds1[XY(x, peakHeight)] = ColorFromPalette(outrunPal, peakHeight * (255 / kMatrixHeight));
//		int y = peakHeight;
//
//		leds3[XY(x, y)] = leds1[XY(x, y)];
//		int adr2 = modify_adr(0, 0, XY(x, y));   //make image right side up or upside down
//		leds2[adr2] = leds1[XY(x, y)];
//		leds4[adr2] = leds1[XY(x, y)];
//	}
//}


///////////////////////////
byte DYNAMIC_LINES(int band, int barHeight)  /// FFT lines extending radially from center 
{
	if (barHeight < 3) { return 0; }

	//Serial.print(F("barHeight="));
	//Serial.println(barHeight);
	//Serial.print(F("band="));
	//Serial.println(band);
	//Serial.println("");

	static byte index_hue = 0;

	++index_hue;

	if (index_hue > MAX_HUES) { index_hue = 0; }

	LINE(0, 11, barHeight, band, hues[index_hue]);        // end point x = amplitude, end point y = frequency/band
	LINE(0, 11, band, barHeight, hues[index_hue]);        // end point x = frequency/band, end point y = amplitude

	SHOW_slow();
	LINE(0, 11, barHeight, band, 999);
	LINE(0, 11, band, barHeight, 999);

	byte BT_interrupt = SHOW_slow();

	return BT_interrupt;


}




/////////////////////////////////////////////////
void BAND(byte numBands)  // devide into COMB_bandValues for FFT
// note: width of each vReal[] bin = sample rate/number of samples
{
#define FIRST_ACTIVE_BAND 3  // bands below this are ignored	, was 2

	for (byte r = 0; r < NUM_COLUMNS;++r)  // initialze array to 0
	{
		COMB_bandValues[r] = 0;
		bandValues[r] = 0;   // added 6/1/23
	}

	// Analyse FFT results
	for (int i = FIRST_ACTIVE_BAND; i < (SAMPLES / 2); i++) {       // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.

		//if (vReal[i] > NOISE) {                    // A
		//	//22 bands, 12kHz top band
		//	if (i <= 2)           bandValues[0] += (int)vReal[i];
		//	if (i > 2 && i <= 3) bandValues[1] += (int)vReal[i];
		//	if (i > 3 && i <= 4) bandValues[2] += (int)vReal[i];
		//	if (i > 4 && i <= 5) bandValues[3] += (int)vReal[i];
		//	if (i > 5 && i <= 6) bandValues[4] += (int)vReal[i];
		//	if (i > 6 && i <= 8) bandValues[5] += (int)vReal[i];
		//	if (i > 8 && i <= 10) bandValues[6] += (int)vReal[i];
		//	if (i > 10 && i <= 12) bandValues[7] += (int)vReal[i];
		//	if (i > 12 && i <= 16) bandValues[8] += (int)vReal[i];
		//	if (i > 16 && i <= 20) bandValues[9] += (int)vReal[i];
		//	if (i > 20 && i <= 25) bandValues[10] += (int)vReal[i];
		//	if (i > 25 && i <= 32) bandValues[11] += (int)vReal[i];
		//	if (i > 32 && i <= 41) bandValues[12] += (int)vReal[i];
		//	if (i > 41 && i <= 52) bandValues[13] += (int)vReal[i];
		//	if (i > 52 && i <= 66) bandValues[14] += (int)vReal[i];

		//	if (i > 66 && i <= 83) bandValues[15] += (int)vReal[i];
		//	if (i > 83 && i <= 106) bandValues[16] += (int)vReal[i];
		//	if (i > 106 && i <= 134) bandValues[17] += (int)vReal[i];
		//	if (i > 134 && i <= 170) bandValues[18] += (int)vReal[i];
		//	if (i > 170 && i <= 216) bandValues[19] += (int)vReal[i];
		//	if (i > 216 && i <= 275) bandValues[20] += (int)vReal[i];
		//	if (i > 275) bandValues[21] += (int)vReal[i];
		//}


		///// Don modified
		if (vReal[i] > NOISE) {                    // A
			//22 bands, 12kHz top band
			if (i <= 2)           bandValues[0] += (int)vReal[i];
			if (i > 2 && i <= 10) bandValues[1] += (int)vReal[i];
			if (i > 10 && i <= 15) bandValues[2] += (int)vReal[i];
			if (i > 15 && i <= 20) bandValues[3] += (int)vReal[i];
			if (i > 20 && i <= 25) bandValues[4] += (int)vReal[i];
			if (i > 25 && i <= 30) bandValues[5] += (int)vReal[i];
			if (i > 30 && i <= 35) bandValues[6] += (int)vReal[i];
			if (i > 35 && i <= 45) bandValues[7] += (int)vReal[i];
			if (i > 45 && i <= 55) bandValues[8] += (int)vReal[i];
			if (i > 55 && i <= 65) bandValues[9] += (int)vReal[i];
			if (i > 65 && i <= 75) bandValues[10] += (int)vReal[i];
			if (i > 75 && i <= 80) bandValues[11] += (int)vReal[i];
			if (i > 80 && i <= 95) bandValues[12] += (int)vReal[i];
			if (i > 95 && i <= 110) bandValues[13] += (int)vReal[i];
			if (i > 110 && i <= 130) bandValues[14] += (int)vReal[i];

			if (i > 130 && i <= 160) bandValues[15] += (int)vReal[i];
			if (i > 160 && i <= 190) bandValues[16] += (int)vReal[i];
			if (i > 190 && i <= 220) bandValues[17] += (int)vReal[i];
			if (i > 220 && i <= 290) bandValues[18] += (int)vReal[i];
			if (i > 290 && i <= 360) bandValues[19] += (int)vReal[i];
			if (i > 360 && i <= 400) bandValues[20] += (int)vReal[i];
			if (i > 400) bandValues[21] += (int)vReal[i];
		}

	}

	int number_bands2combine = NUM_COLUMNS / numBands;
	byte index = 0;
	int count = 0;

	//Serial.println(F("------- BAND -------"));
	//Serial.print(F("number_bands2combine ="));
	//Serial.println(number_bands2combine);
	//Serial.println("");

	// combine bandValues into a smaller number of bands stored in COMB_bandValues
	for (byte k = 0; k < NUM_COLUMNS; ++k)   // note: 22=number of bands above
	{

		if (count >= number_bands2combine)
		{
			++index;

			count = 0;
		}

		++count;

		COMB_bandValues[index] += bandValues[k];

		//Serial.print(F("k="));
		//Serial.println(k);
		//Serial.print(F("index="));
		//Serial.println(index);
		//Serial.print(F("count="));
		//Serial.println(count);
		//Serial.println("");

	}

	//for (byte n = 0; n < NUM_COLUMNS; ++n)
	//{
	//	Serial.println("");
	//	Serial.print(F("COMB_bandValues[ "));
	//	Serial.print(n);
	//	Serial.print(F("]= "));
	//	Serial.println(COMB_bandValues[n]);
	//}

	//Serial.println("");



	if (SOUND_DETECT(SOUND_DETECT_THRESHOLD, 1) == 1)
	{
		++G_sound_detected_flag;
	}


}

//////  for FFT  ///////////////////////////////////

void FFT_COMPUTE()  // sample analog input and compute FFT
{
	// this function takes 123ms to complete

	//Serial.println(F("** FFT_COMPUTE: position 0 **"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);

	//NOTE: I added the line below as somehow G_sampling_period_us was being changed...I have no idea how!!!!!
//	G_sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQ));  // for FFT , 25us/sample --> 25.6ms/1024 samples

	// NOTE: bin width resolution = 40KHz sample rate/1024 samples = 39Hz per bin
	// for FFT, 25us/sample --> 25.6ms/1024 samples

	// Reset bandValues[]
	//for (int i = 0; i < NUM_BANDS; i++) {
	//	bandValues[i] = 0;
	//}

	int audio_pin_A2D_value;


	// Sample the audio pin...takes 10ms total for 1024 samples
	for (int i = 0; i < SAMPLES; i++) {

		audio_pin_A2D_value = analogRead(AUDIO_IN_PIN);

		newTime = micros();
		vReal[i] = G_MIC_gain * audio_pin_A2D_value; // A conversion takes about 9.7uS on an ESP32
		vImag[i] = 0;

		//Serial.println(F("** FFT_COMPUTE: position 1a **"));
		//Serial.print(F("newTime + G_sampling_period_us ="));
		//Serial.println(newTime + G_sampling_period_us );
		//Serial.print(F("newTime ="));
		//Serial.println(newTime );
		//Serial.print(F("G_sampling_period_us ="));
		//Serial.println(G_sampling_period_us);
		//Serial.println(F(""));

		while (micros() < (newTime + G_sampling_period_us))
		{ /* chill */
			//Serial.println(F("** FFT_COMPUTE: position 1b **"));
			//Serial.print(F("micros() ="));
			//Serial.println(micros());
		}


	}

	//	Serial.println(F("** FFT_COMPUTE: position 2 **"));

		// NOTE: bin width resolution = 40KHz sample rate/1024 samples = 39Hz per bin

		// Compute FFT
		//FFT.DCRemoval();
	FFT.dcRemoval();

	//	Serial.println(F("** FFT_COMPUTE: position 3 **"));

		//FFT.Windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);
	FFT.windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);


	//FFT.Compute(FFT_FORWARD);
	FFT.compute(FFT_FORWARD);

	//	Serial.println(F("** FFT_COMPUTE: position 4 **"));

		//FFT.ComplexToMagnitude();
	FFT.complexToMagnitude();

	//Serial.println(F("** FFT_COMPUTE: END **"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);


	//Serial.println(F(""));
	//for (int i = 2; i < (SAMPLES / 2); i++) // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.
	//{       

	//	Serial.print(F("vReal["));
	//	Serial.print(i);
	//	Serial.print(F("]= "));
	//	Serial.println((int)vReal[i]);

	//}


}

void FFT2_COMPUTE()  // sample analog input and compute FFT
{
	// NOTE: bin width resolution = 8KHz sample rate/512 samples = 15Hz per bin
	// for FFT, 125us/sample --> 64ms/512 samples

	// Reset bandValues[]
	//for (int i = 0; i < NUM_BANDS; i++) {
	//	bandValues[i] = 0;
	//}

	//NOTE: I added the line below as somehow G_sampling_period_us2 was being changed...I have no idea how!!!!!
	//G_sampling_period_us2 = round(1000000 * (1.0 / SAMPLING_FREQ2));  // for FFT , 25us/sample --> 25.6ms/1024 samples



	// Sample the audio pin...takes 10ms total for 1024 samples
	for (int i = 0; i < SAMPLES2; i++) {
		newTime = micros();
		vReal2[i] = G_MIC_gain * analogRead(AUDIO_IN_PIN); // A conversion takes about 9.7uS on an ESP32
		vImag2[i] = 0;
		while (micros() < (newTime + G_sampling_period_us2)) { /* chill */ }
	}



	// Compute FFT
	//FFT2.DCRemoval();
	FFT.dcRemoval();
	//FFT2.Windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);
	FFT2.windowing(FFT_WIN_TYP_HAMMING, FFT_FORWARD);
	//FFT2.Compute(FFT_FORWARD);
	FFT2.compute(FFT_FORWARD);
	//FFT2.ComplexToMagnitude();
	FFT2.complexToMagnitude();


	//Serial.println(F(""));
	//for (int i = 2; i < (SAMPLES / 2); i++) // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.
	//{       

	//	Serial.print(F("vReal["));
	//	Serial.print(i);
	//	Serial.print(F("]= "));
	//	Serial.println((int)vReal[i]);

	//}


}

///////////////// for beat detector  /////////////////////
//// 20 - 200hz Single Pole Bandpass IIR Filter
//float bassFilter(float sample) {
//	static float xv[3] = { 0,0,0 }, yv[3] = { 0,0,0 };
//	xv[0] = xv[1]; xv[1] = xv[2];
//	xv[2] = (sample) / 3.f; // change here to values close to 2, to adapt for stronger or weeker sources of line level audio  
//
//
//	yv[0] = yv[1]; yv[1] = yv[2];
//	yv[2] = (xv[2] - xv[0])
//		+ (-0.7960060012f * yv[0]) + (1.7903124146f * yv[1]);
//	return yv[2];
//}
//
//// 10hz Single Pole Lowpass IIR Filter
//float envelopeFilter(float sample) { //10hz low pass
//	static float xv[2] = { 0,0 }, yv[2] = { 0,0 };
//	xv[0] = xv[1];
//	xv[1] = sample / 50.f;
//	yv[0] = yv[1];
//	yv[1] = (xv[0] + xv[1]) + (0.9875119299f * yv[0]);
//	return yv[1];
//}
//
//// 1.7 - 3.0hz Single Pole Bandpass IIR Filter
//float beatFilter(float sample) {
//	static float xv[3] = { 0,0,0 }, yv[3] = { 0,0,0 };
//	xv[0] = xv[1]; xv[1] = xv[2];
//	xv[2] = sample / 2.7f;
//	yv[0] = yv[1]; yv[1] = yv[2];
//	yv[2] = (xv[2] - xv[0])
//		+ (-0.7169861741f * yv[0]) + (1.4453653501f * yv[1]);
//	return yv[2];
//}



////////////////////////////////////////////////////////////////////////
// two intertwined triangles of different color
void BEAT_SHOW_0(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
// data1=hue2 
//data2, data3 = not used 

		// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000

{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }


	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
	//byte image_kind = 0;  // image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
	//byte total_increments = 3;  // number of images created between the two base sets, was 5


	static byte active_increment = 0;  // which of the total increments is active for this beat
	//static byte previous_increment = total_increments - 1;  // previously active increment
	static int direction = 1;


	/////////// START ///////////////////


	TWEEN_IMAGE_START[0].IMAGE_KIND = 4;  // triangle
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 4;
	TWEEN_IMAGE_START[0].XE = 11;
	TWEEN_IMAGE_START[0].YE = 16;
	TWEEN_IMAGE_START[0].HUE = hue1;  // blue
	TWEEN_IMAGE_START[0].DATA1 = hue2;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 4;  //2nd triangle
	TWEEN_IMAGE_START[1].XS = 0;
	TWEEN_IMAGE_START[1].YS = 17;
	TWEEN_IMAGE_START[1].XE = 11;
	TWEEN_IMAGE_START[1].YE = 6;
	TWEEN_IMAGE_START[1].HUE = hue2;  // green
	TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 4;  //triangle
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 4;
	TWEEN_IMAGE_END[0].XE = 1;
	TWEEN_IMAGE_END[0].YE = 5;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = hue2;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 4;  //triangle
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 17;
	TWEEN_IMAGE_END[1].XE = 1;
	TWEEN_IMAGE_END[1].YE = 16;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = hue2;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));






	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);



	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}

////////////////////////////////////////////////////////////////////////
// two lines moving from 0 slope to +/-45 degree slope
void BEAT_SHOW_1(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
// data1=hue2 
//data2, data3 = not used 

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000
{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }


	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
	//byte image_kind = 0;  // image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
	//byte total_increments = 3;  // number of images created between the two base sets, was 5


	static byte active_increment = 0;  // which of the total increments is active for this beat
	//static byte previous_increment = total_increments - 1;  // previously active increment
	static int direction = 1;



	/////////// START ///////////////////


	TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 11;
	TWEEN_IMAGE_START[0].XE = 15;
	TWEEN_IMAGE_START[0].YE = 11;
	TWEEN_IMAGE_START[0].HUE = hue1;  // blue
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 1;  //2nd line
	TWEEN_IMAGE_START[1].XS = 0;
	TWEEN_IMAGE_START[1].YS = 11;
	TWEEN_IMAGE_START[1].XE = 15;
	TWEEN_IMAGE_START[1].YE = 11;
	TWEEN_IMAGE_START[1].HUE = hue2;  // green
	TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 1;  //line
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 11;
	TWEEN_IMAGE_END[0].XE = 15;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 1;  //line
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 11;
	TWEEN_IMAGE_END[1].XE = 15;
	TWEEN_IMAGE_END[1].YE = 0;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = hue2;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));



	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);



	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}




////////////////////////////////////////////////////////////////////////
// two lines moving from 0 slope to +/-45 degree slope
void BEAT_SHOW_2(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
//data1, data2, data3 = not used 

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000
{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }


	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
	//byte image_kind = 0;  // image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
	//byte total_increments = 3;  // number of images created between the two base sets, was 5


	static byte active_increment = 0;  // which of the total increments is active for this beat
	//static byte previous_increment = total_increments - 1;  // previously active increment
	static int direction = 1;




	/////////// START ///////////////////


	TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 11;
	TWEEN_IMAGE_START[0].XE = 5;
	TWEEN_IMAGE_START[0].YE = 11;
	TWEEN_IMAGE_START[0].HUE = hue1;  // blue
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_START[1].XS = 0;  // center
	TWEEN_IMAGE_START[1].YS = 11; // center
	TWEEN_IMAGE_START[1].XE = 2;  // radius
	TWEEN_IMAGE_START[1].YE = 11;  // not used
	TWEEN_IMAGE_START[1].HUE = hue2;  // 
	TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 1;  //line
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 11;
	TWEEN_IMAGE_END[0].XE = 21;
	TWEEN_IMAGE_END[0].YE = 0;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 11;
	TWEEN_IMAGE_END[1].XE = 10;  // radius
	TWEEN_IMAGE_END[1].YE = 0;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));




	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);



	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}



////////////////////////////////////////////////////////////////////////
// circle moving up and down with changing radius 
void BEAT_SHOW_3(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 

		// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000
{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }


	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
	//byte image_kind = 0;  // image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
	//byte total_increments = 3;  // number of images created between the two base sets, was 5


	static byte active_increment = 0;  // which of the total increments is active for this beat
	//static byte previous_increment = total_increments - 1;  // previously active increment
	static int direction = 1;

	byte radius1 = 10;  // beat_count % 10;
	byte radius2 = 3; //beat_count % 5;



	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  // circle
	TWEEN_IMAGE_START[0].XS = 0;  // center
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = radius1;  // radius
	TWEEN_IMAGE_START[0].YE = 11;
	TWEEN_IMAGE_START[0].HUE = hue1;  // red
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	//TWEEN_IMAGE_START[1].XS = 0;  // center
	//TWEEN_IMAGE_START[1].YS = 11; // center
	//TWEEN_IMAGE_START[1].XE = 2;  // radius
	//TWEEN_IMAGE_START[1].YE = 11;  // not used
	//TWEEN_IMAGE_START[1].HUE = hue2;  // 
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_END[0].XS = 0;  // center
	TWEEN_IMAGE_END[0].YS = 21;
	TWEEN_IMAGE_END[0].XE = radius2;   // radius
	TWEEN_IMAGE_END[0].YE = 0;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 11;
	//TWEEN_IMAGE_END[1].XE = 10;  // radius
	//TWEEN_IMAGE_END[1].YE = 0;
	//TWEEN_IMAGE_END[1].HUE = hue2;
	//TWEEN_IMAGE_END[1].DATA1 = hue2;   // peaks  // not used
	//TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	//TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

///////////////*****************  new code for beat show ************************




		//Serial.println(F(""));
		//Serial.print(F("++++++BS12 : beat_count="));
		//Serial.println(beat_count);
		//Serial.println(F(""));


		//Serial.print(F("++++++BS12 : active_increment="));
		//Serial.println(active_increment);
		//Serial.print(F("   previous_increment="));
		//Serial.println(previous_increment);
		//Serial.print(F("   enable="));
		//Serial.println(enable);
		//Serial.println(F(""));



	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}




////////////////////////////////////////////////////////////////////////
// horizontally moving verticle line
void BEAT_SHOW_4(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000



{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10

	static byte active_increment = 0;  // which of the total increments is active for this beat

	static int direction = 1;



	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = 0;
	TWEEN_IMAGE_START[0].YE = 21;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	//TWEEN_IMAGE_START[1].XS = 0;  // center
	//TWEEN_IMAGE_START[1].YS = 11; // center
	//TWEEN_IMAGE_START[1].XE = 2;  // radius
	//TWEEN_IMAGE_START[1].YE = 11;  // not used
	//TWEEN_IMAGE_START[1].HUE = hue2;  // 
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 1;  //line
	TWEEN_IMAGE_END[0].XS = 21;
	TWEEN_IMAGE_END[0].YS = 0;
	TWEEN_IMAGE_END[0].XE = 21;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 11;
	//TWEEN_IMAGE_END[1].XE = 10;  // radius
	//TWEEN_IMAGE_END[1].YE = 0;
	//TWEEN_IMAGE_END[1].HUE = hue2;
	//TWEEN_IMAGE_END[1].DATA1 = hue2;   // peaks  // not used
	//TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	//TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

///////////////*****************  new code for beat show ************************




		//Serial.println(F(""));
		//Serial.print(F("++++++BS12 : beat_count="));
		//Serial.println(beat_count);
		//Serial.println(F(""));


		//Serial.print(F("++++++BS12 : active_increment="));
		//Serial.println(active_increment);
		//Serial.print(F("   previous_increment="));
		//Serial.println(previous_increment);
		//Serial.print(F("   enable="));
		//Serial.println(enable);
		//Serial.println(F(""));




	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}


////////////////////////////////////////////////////////////////////////
// vertically moving line that starts vertical and ends horizontal
void BEAT_SHOW_5(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000



{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10

	static byte active_increment = 0;  // which of the total increments is active for this beat

	static int direction = 1;


	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = 0;
	TWEEN_IMAGE_START[0].YE = 6;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	//TWEEN_IMAGE_START[1].XS = 0;  // center
	//TWEEN_IMAGE_START[1].YS = 11; // center
	//TWEEN_IMAGE_START[1].XE = 2;  // radius
	//TWEEN_IMAGE_START[1].YE = 11;  // not used
	//TWEEN_IMAGE_START[1].HUE = hue2;  // 
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 1;  //line
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 21;
	TWEEN_IMAGE_END[0].XE = 10;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 11;
	//TWEEN_IMAGE_END[1].XE = 10;  // radius
	//TWEEN_IMAGE_END[1].YE = 0;
	//TWEEN_IMAGE_END[1].HUE = hue2;
	//TWEEN_IMAGE_END[1].DATA1 = hue2;   // peaks  // not used
	//TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	//TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

///////////////*****************  new code for beat show ************************




		//Serial.println(F(""));
		//Serial.print(F("++++++BS12 : beat_count="));
		//Serial.println(beat_count);
		//Serial.println(F(""));


		//Serial.print(F("++++++BS12 : active_increment="));
		//Serial.println(active_increment);
		//Serial.print(F("   previous_increment="));
		//Serial.println(previous_increment);
		//Serial.print(F("   enable="));
		//Serial.println(enable);
		//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}



////////////////////////////////////////////////////////////////////////
// in and out moving circles
void BEAT_SHOW_6(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000


{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  // circle
	TWEEN_IMAGE_START[0].XS = 15;  // center
	TWEEN_IMAGE_START[0].YS = 5;  // center
	TWEEN_IMAGE_START[0].XE = 15;  // radius
	TWEEN_IMAGE_START[0].YE = 6;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_START[1].XS = 15;  // center
	TWEEN_IMAGE_START[1].YS = 16; // center
	TWEEN_IMAGE_START[1].XE = 15;  // radius
	TWEEN_IMAGE_START[1].YE = 11;  // not used
	TWEEN_IMAGE_START[1].HUE = hue2;  // 
	TWEEN_IMAGE_START[1].DATA1 = data1;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 5;
	TWEEN_IMAGE_END[0].XE = 1; // radius
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 16;
	TWEEN_IMAGE_END[1].XE = 1;  // radius
	TWEEN_IMAGE_END[1].YE = 0;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}



////////////////////////////////////////////////////////////////////////
// top and bottom shrinking squares
void BEAT_SHOW_7(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000


{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 3;  // rectangle
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 21;
	TWEEN_IMAGE_START[0].XE = 8;
	TWEEN_IMAGE_START[0].YE = 13;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 3;  // rectangle
	TWEEN_IMAGE_START[1].XS = 0;
	TWEEN_IMAGE_START[1].YS = 0;
	TWEEN_IMAGE_START[1].XE = 8;
	TWEEN_IMAGE_START[1].YE = 8;
	TWEEN_IMAGE_START[1].HUE = hue2;  // 
	TWEEN_IMAGE_START[1].DATA1 = data1;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 3;  // rectangle
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 21;
	TWEEN_IMAGE_END[0].XE = 1;
	TWEEN_IMAGE_END[0].YE = 20;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 3;  // rectangle
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 16;
	TWEEN_IMAGE_END[1].XE = 1;
	TWEEN_IMAGE_END[1].YE = 1;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}



/////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
// in and out moving circle
void BEAT_SHOW_8(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000


{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  // circle
	TWEEN_IMAGE_START[0].XS = 0;  // center
	TWEEN_IMAGE_START[0].YS = 0;  // center
	TWEEN_IMAGE_START[0].XE = 1;  // radius
	TWEEN_IMAGE_START[0].YE = 1;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_START[1].XS = 15;  // center
	TWEEN_IMAGE_START[1].YS = 16; // center
	TWEEN_IMAGE_START[1].XE = 15;  // radius
	TWEEN_IMAGE_START[1].YE = 11;  // not used
	TWEEN_IMAGE_START[1].HUE = hue2;  // 
	TWEEN_IMAGE_START[1].DATA1 = data1;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 21;
	TWEEN_IMAGE_END[0].XE = 11; // radius
	TWEEN_IMAGE_END[0].YE = 11;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 16;
	TWEEN_IMAGE_END[1].XE = 1;  // radius
	TWEEN_IMAGE_END[1].YE = 0;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}



////////////////////////////////////////////////////////////////////////
// top and bottom shrinking and expanding lines moving from top to bottom and bottom to top
void BEAT_SHOW_9(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000


{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 20;
	TWEEN_IMAGE_START[0].XE = 17;
	TWEEN_IMAGE_START[0].YE = 20;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[1].XS = 1;
	TWEEN_IMAGE_START[1].YS = 1;
	TWEEN_IMAGE_START[1].XE = 1;
	TWEEN_IMAGE_START[1].YE = 1;
	TWEEN_IMAGE_START[1].HUE = hue2;  // 
	TWEEN_IMAGE_START[1].DATA1 = data1;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////

	TWEEN_IMAGE_END[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_END[0].XS = 1;
	TWEEN_IMAGE_END[0].YS = 1;
	TWEEN_IMAGE_END[0].XE = 1;
	TWEEN_IMAGE_END[0].YE = 1;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_END[1].XS = 1;
	TWEEN_IMAGE_END[1].YS = 20;
	TWEEN_IMAGE_END[1].XE = 20;
	TWEEN_IMAGE_END[1].YE = 20;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}




////////////////////////////////////////////////////////////////////////
// two seperated hoz lines whose ends join
void BEAT_SHOW_10(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000


{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10
	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 16;
	TWEEN_IMAGE_START[0].XE = 10;
	TWEEN_IMAGE_START[0].YE = 16;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_START[1].XS = 0;
	TWEEN_IMAGE_START[1].YS = 5;
	TWEEN_IMAGE_START[1].XE = 10;
	TWEEN_IMAGE_START[1].YE = 5;
	TWEEN_IMAGE_START[1].HUE = hue1;  // 
	TWEEN_IMAGE_START[1].DATA1 = data1;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////

	TWEEN_IMAGE_END[0].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 16;
	TWEEN_IMAGE_END[0].XE = 10;
	TWEEN_IMAGE_END[0].YE = 11;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 1;  // line
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 5;
	TWEEN_IMAGE_END[1].XE = 10;
	TWEEN_IMAGE_END[1].YE = 11;
	TWEEN_IMAGE_END[1].HUE = hue2;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}



////////////////////////////////////////////////////////////////////////
// shrinking and expanding center circle
void BEAT_SHOW_11(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000


{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 2;  // circle
	TWEEN_IMAGE_START[0].XS = 0;  // center
	TWEEN_IMAGE_START[0].YS = 11;  // center
	TWEEN_IMAGE_START[0].XE = 1;  // radius
	TWEEN_IMAGE_START[0].YE = 1;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_START[1].XS = 15;  // center
	TWEEN_IMAGE_START[1].YS = 16; // center
	TWEEN_IMAGE_START[1].XE = 15;  // radius
	TWEEN_IMAGE_START[1].YE = 11;  // not used
	TWEEN_IMAGE_START[1].HUE = hue2;  // 
	TWEEN_IMAGE_START[1].DATA1 = data1;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 2;  //circle
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 11;
	TWEEN_IMAGE_END[0].XE = 11; // radius
	TWEEN_IMAGE_END[0].YE = 11;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 16;
	TWEEN_IMAGE_END[1].XE = 1;  // radius
	TWEEN_IMAGE_END[1].YE = 0;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}




////////////////////////////////////////////////////////////////////////

//BEAT_SHOW_2(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)

//horizonatal blue ziz zag that moves up:   1st TWEEN BEAT SHOW
void BEAT_SHOW_12(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes

{

	if (enable == 0) { return; }


	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
	//byte image_kind = 0;  // image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
	//byte total_increments = 3;  // number of images created between the two base sets, was 5


	static byte active_increment = 0;  // which of the total increments is active for this beat
	//static byte previous_increment = total_increments - 1;  // previously active increment
	int direction = 1;


	/////////// BANK 0 ///////////////////
	///////// zig_zag bottom

	TWEEN_IMAGE_START[0].IMAGE_KIND = 7;
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = 21;
	TWEEN_IMAGE_START[0].YE = 0;
	TWEEN_IMAGE_START[0].HUE = hue1;  //  171
	TWEEN_IMAGE_START[0].DATA1 = 4;   //4 peaks
	TWEEN_IMAGE_START[0].DATA2 = 4;  //4 amplitude

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
	//TWEEN_IMAGE_START[1].XS = 0;
	//TWEEN_IMAGE_START[1].YS = 0;
	//TWEEN_IMAGE_START[1].XE = 0;
	//TWEEN_IMAGE_START[1].YE = 21;
	//TWEEN_IMAGE_START[1].HUE = 42;  // yellow
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// BANK 1 ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 7;  //zig_zag
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 21;
	TWEEN_IMAGE_END[0].XE = 11;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;  //0
	TWEEN_IMAGE_END[0].DATA1 = 2;   // peaks
	TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 0;
	//TWEEN_IMAGE_END[1].XE = 0;
	//TWEEN_IMAGE_END[1].YE = 21;
	//TWEEN_IMAGE_END[1].HUE = 42;
	//TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
	//TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow

///////////////*****************  new code for beat show ************************




		//Serial.println(F(""));
		//Serial.print(F("++++++BS12 : beat_count="));
		//Serial.println(beat_count);
		//Serial.println(F(""));


		//Serial.print(F("++++++BS12 : active_increment="));
		//Serial.println(active_increment);
		//Serial.print(F("   previous_increment="));
		//Serial.println(previous_increment);
		//Serial.print(F("   enable="));
		//Serial.println(enable);
		//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;

		}

	}

}




////////////////////////////////////////////////////////////////////////
void BEAT_SHOW_13(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE)   //vertical red ziz zag that moves sidways:   2nd TWEEN BEAT SHOW
//SHOW: vertical large circle at bottom --> small circle at top
//modulus= an animation increments each modulus count

// total_increments = number of images created between the two base sets
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
{

	if (enable == 0) { return; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10




	static byte active_increment = 0;  // which of the total increments is active for this beat
	int direction = 1;

	/////////// START ///////////////////
	///////// zig_zag bottom

	TWEEN_IMAGE_START[0].IMAGE_KIND = 7;
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = 0;
	TWEEN_IMAGE_START[0].YE = 21;
	TWEEN_IMAGE_START[0].HUE = hue1;  // red
	TWEEN_IMAGE_START[0].DATA1 = 4;   // peaks
	TWEEN_IMAGE_START[0].DATA2 = 4;  // amplitude

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
	//TWEEN_IMAGE_START[1].XS = 0;
	//TWEEN_IMAGE_START[1].YS = 0;
	//TWEEN_IMAGE_START[1].XE = 0;
	//TWEEN_IMAGE_START[1].YE = 21;
	//TWEEN_IMAGE_START[1].HUE = 42;  // yellow
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 7;  //zig_zag
	TWEEN_IMAGE_END[0].XS = 21;
	TWEEN_IMAGE_END[0].YS = 0;
	TWEEN_IMAGE_END[0].XE = 21;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = 2;   // peaks
	TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 0;
	//TWEEN_IMAGE_END[1].XE = 0;
	//TWEEN_IMAGE_END[1].YE = 21;
	//TWEEN_IMAGE_END[1].HUE = 42;
	//TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
	//TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow

///////////////*****************  new code for beat show ************************




	//Serial.println(F(""));
	//Serial.print(F("++++++BS12 : beat_count="));
	//Serial.println(beat_count);
	//Serial.println(F(""));


	//Serial.print(F("++++++BS12 : active_increment="));
	//Serial.println(active_increment);
	//Serial.print(F("   previous_increment="));
	//Serial.println(previous_increment);
	//Serial.print(F("   enable="));
	//Serial.println(enable);
	//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;

		}

	}


}


////////////////////////////////////////////////////////////////////////
void BEAT_SHOW_14(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE)   //vertical red ziz zag that moves sidways:   2nd TWEEN BEAT SHOW
//SHOW: horizontal spikes with no axix that grow and shrink
//modulus= an animation increments each modulus count

// total_increments = number of images created between the two base sets
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
//3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes with axis, 9=spike no axix
{

	if (enable == 0) { return; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10




	static byte active_increment = 0;  // which of the total increments is active for this beat
	int direction = 1;

	/////////// START ///////////////////
	///////// zig_zag bottom

	TWEEN_IMAGE_START[0].IMAGE_KIND = 9;  // spike with no axis
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = 0;
	TWEEN_IMAGE_START[0].YE = 21;
	TWEEN_IMAGE_START[0].HUE = hue1;  // red
	TWEEN_IMAGE_START[0].DATA1 = 8;   // peaks  ... only 4 will show as only 4 are positive
	TWEEN_IMAGE_START[0].DATA2 = 1;  // amplitude
	TWEEN_IMAGE_START[0].DATA3 = hue2;  // spike color

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
	//TWEEN_IMAGE_START[1].XS = 0;
	//TWEEN_IMAGE_START[1].YS = 0;
	//TWEEN_IMAGE_START[1].XE = 0;
	//TWEEN_IMAGE_START[1].YE = 21;
	//TWEEN_IMAGE_START[1].HUE = 42;  // yellow
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 9;  //spike with no axis
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 0;
	TWEEN_IMAGE_END[0].XE = 0;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = 8;   // peaks
	TWEEN_IMAGE_END[0].DATA2 = 8;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 0;
	//TWEEN_IMAGE_END[1].XE = 0;
	//TWEEN_IMAGE_END[1].YE = 21;
	//TWEEN_IMAGE_END[1].HUE = 42;
	//TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
	//TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow

///////////////*****************  new code for beat show ************************




	//Serial.println(F(""));
	//Serial.print(F("++++++BS12 : beat_count="));
	//Serial.println(beat_count);
	//Serial.println(F(""));


	//Serial.print(F("++++++BS12 : active_increment="));
	//Serial.println(active_increment);
	//Serial.print(F("   previous_increment="));
	//Serial.println(previous_increment);
	//Serial.print(F("   enable="));
	//Serial.println(enable);
	//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			//direction = -1 * direction;  // change direction

		}

	}


}


////////////////////////////////////////////////////////////////////////
void BEAT_SHOW_15(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE)   //vertical red ziz zag that moves sidways:   2nd TWEEN BEAT SHOW
//SHOW: slanted spikes with no axix that grow and shrink
//modulus= an animation increments each modulus count

// total_increments = number of images created between the two base sets
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
//3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes with axis, 9=spike no axix
{

	if (enable == 0) { return; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10




	static byte active_increment = 0;  // which of the total increments is active for this beat
	int direction = 1;

	/////////// START ///////////////////
	///////// zig_zag bottom

	TWEEN_IMAGE_START[0].IMAGE_KIND = 9;  // spike with no axis
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = 10;
	TWEEN_IMAGE_START[0].YE = 21;
	TWEEN_IMAGE_START[0].HUE = hue1;  // red
	TWEEN_IMAGE_START[0].DATA1 = 4;   // peaks  ... only 4 will show as only 4 are positive
	TWEEN_IMAGE_START[0].DATA2 = 1;  // amplitude
	TWEEN_IMAGE_START[0].DATA3 = hue2;  // spike color

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
	//TWEEN_IMAGE_START[1].XS = 0;
	//TWEEN_IMAGE_START[1].YS = 0;
	//TWEEN_IMAGE_START[1].XE = 0;
	//TWEEN_IMAGE_START[1].YE = 21;
	//TWEEN_IMAGE_START[1].HUE = 42;  // yellow
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 9;  //spike with no axis
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 0;
	TWEEN_IMAGE_END[0].XE = 10;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = 4;   // peaks
	TWEEN_IMAGE_END[0].DATA2 = 8;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 0;
	//TWEEN_IMAGE_END[1].XE = 0;
	//TWEEN_IMAGE_END[1].YE = 21;
	//TWEEN_IMAGE_END[1].HUE = 42;
	//TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
	//TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow

///////////////*****************  new code for beat show ************************




	//Serial.println(F(""));
	//Serial.print(F("++++++BS12 : beat_count="));
	//Serial.println(beat_count);
	//Serial.println(F(""));


	//Serial.print(F("++++++BS12 : active_increment="));
	//Serial.println(active_increment);
	//Serial.print(F("   previous_increment="));
	//Serial.println(previous_increment);
	//Serial.print(F("   enable="));
	//Serial.println(enable);
	//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;

		}

	}


}


////////////////////////////////////////////////////////////////////////
void BEAT_SHOW_16(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE)   //vertical red ziz zag that moves sidways:   2nd TWEEN BEAT SHOW
//SHOW:  spikes with axix , with axis tilting and spike growing
//modulus= an animation increments each modulus count

// total_increments = number of images created between the two base sets
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
//3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes with axis, 9=spike no axix
{

	if (enable == 0) { return; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10




	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;

	/////////// START ///////////////////
	///////// zig_zag bottom

	TWEEN_IMAGE_START[0].IMAGE_KIND = 8;  // spike with axis
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 0;
	TWEEN_IMAGE_START[0].XE = 0;
	TWEEN_IMAGE_START[0].YE = 21;
	TWEEN_IMAGE_START[0].HUE = hue1;  // red
	TWEEN_IMAGE_START[0].DATA1 = 4;   // peaks  ... only 4 will show as only 4 are positive
	TWEEN_IMAGE_START[0].DATA2 = 2;  // amplitude
	TWEEN_IMAGE_START[0].DATA3 = hue2;  // spike color

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
	//TWEEN_IMAGE_START[1].XS = 0;
	//TWEEN_IMAGE_START[1].YS = 0;
	//TWEEN_IMAGE_START[1].XE = 0;
	//TWEEN_IMAGE_START[1].YE = 21;
	//TWEEN_IMAGE_START[1].HUE = 42;  // yellow
	//TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 8;  //spike with axis
	TWEEN_IMAGE_END[0].XS = 11;
	TWEEN_IMAGE_END[0].YS = 0;
	TWEEN_IMAGE_END[0].XE = 0;
	TWEEN_IMAGE_END[0].YE = 21;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = 4;   // peaks
	TWEEN_IMAGE_END[0].DATA2 = 4;  // amplitude

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 0;
	//TWEEN_IMAGE_END[1].XE = 0;
	//TWEEN_IMAGE_END[1].YE = 21;
	//TWEEN_IMAGE_END[1].HUE = 42;
	//TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
	//TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
	//TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow

///////////////*****************  new code for beat show ************************




	//Serial.println(F(""));
	//Serial.print(F("++++++BS12 : beat_count="));
	//Serial.println(beat_count);
	//Serial.println(F(""));


	//Serial.print(F("++++++BS12 : active_increment="));
	//Serial.println(active_increment);
	//Serial.print(F("   previous_increment="));
	//Serial.println(previous_increment);
	//Serial.print(F("   enable="));
	//Serial.println(enable);
	//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}


}

////////////////////////////////////////////////////////////////////////
// shrinking and expanding center triangle
void BEAT_SHOW_17(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte data1, byte data2, byte data3)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes 
//data1, data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000


{

	if (enable == 0) { return; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = 4;  // triangle
	TWEEN_IMAGE_START[0].XS = 0;  // center
	TWEEN_IMAGE_START[0].YS = 11;  // center
	TWEEN_IMAGE_START[0].XE = 1;  // radius
	TWEEN_IMAGE_START[0].YE = 1;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_START[0].DATA2 = data2;  // not used
	TWEEN_IMAGE_START[0].DATA3 = data3;  // not used

	TWEEN_IMAGE_START[1].IMAGE_KIND = 4;  //triangle
	TWEEN_IMAGE_START[1].XS = 15;  // center
	TWEEN_IMAGE_START[1].YS = 20; // center
	TWEEN_IMAGE_START[1].XE = 15;  // radius
	TWEEN_IMAGE_START[1].YE = 15;  // not used
	TWEEN_IMAGE_START[1].HUE = hue2;  // 
	TWEEN_IMAGE_START[1].DATA1 = data1;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 4;  //triangle
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 11;
	TWEEN_IMAGE_END[0].XE = 11; // radius
	TWEEN_IMAGE_END[0].YE = 20;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = data1;   // not used
	TWEEN_IMAGE_END[0].DATA2 = data2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = data3;  // amplitude

	TWEEN_IMAGE_END[1].IMAGE_KIND = 4;  //triangle
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 16;
	TWEEN_IMAGE_END[1].XE = 1;  // radius
	TWEEN_IMAGE_END[1].YE = 0;
	TWEEN_IMAGE_END[1].HUE = hue1;
	TWEEN_IMAGE_END[1].DATA1 = data1;   // peaks  // not used
	TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

	///////////////*****************  new code for beat show ************************




			//Serial.println(F(""));
			//Serial.print(F("++++++BS12 : beat_count="));
			//Serial.println(beat_count);
			//Serial.println(F(""));


			//Serial.print(F("++++++BS12 : active_increment="));
			//Serial.println(active_increment);
			//Serial.print(F("   previous_increment="));
			//Serial.println(previous_increment);
			//Serial.print(F("   enable="));
			//Serial.println(enable);
			//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;
		}

	}

}

////////////////////////////////////////////////////////////////////////
void BEAT_SHOW_18(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE)   //vertical red ziz zag that moves sidways:   2nd TWEEN BEAT SHOW
//SHOW: horizontal spikes with axis move towards each other
//modulus= an animation increments each modulus count

// total_increments = number of images created between the two base sets
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 
//3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes with axis, 9=spike no axix
{

	if (enable == 0) { return; }

	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10

	static byte active_increment = 0;  // which of the total increments is active for this beat
	int direction = 1;

	/////////// START ///////////////////
	///////// zig_zag bottom

	TWEEN_IMAGE_START[0].IMAGE_KIND = 8;  // spike with no axis
	TWEEN_IMAGE_START[0].XS = 0;
	TWEEN_IMAGE_START[0].YS = 5;
	TWEEN_IMAGE_START[0].XE = 11;
	TWEEN_IMAGE_START[0].YE = 5;
	TWEEN_IMAGE_START[0].HUE = hue1;  // red
	TWEEN_IMAGE_START[0].DATA1 = 6;   // peaks  ... only 4 will show as only 4 are positive
	TWEEN_IMAGE_START[0].DATA2 = 5;  // amplitude
	TWEEN_IMAGE_START[0].DATA3 = hue2;  // spike color

	TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
	TWEEN_IMAGE_START[1].XS = 0;
	TWEEN_IMAGE_START[1].YS = 15;
	TWEEN_IMAGE_START[1].XE = 11;
	TWEEN_IMAGE_START[1].YE = 15;
	TWEEN_IMAGE_START[1].HUE = hue2;  // yellow
	TWEEN_IMAGE_START[1].DATA1 = 6;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = hue1;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 8;  //spike with no axis
	TWEEN_IMAGE_END[0].XS = 0;
	TWEEN_IMAGE_END[0].YS = 15;
	TWEEN_IMAGE_END[0].XE = 11;
	TWEEN_IMAGE_END[0].YE = 15;
	TWEEN_IMAGE_END[0].HUE = hue1;
	TWEEN_IMAGE_END[0].DATA1 = 6;   // peaks
	TWEEN_IMAGE_END[0].DATA2 = 2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = hue2;  // spike color

	TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
	TWEEN_IMAGE_END[1].XS = 0;
	TWEEN_IMAGE_END[1].YS = 5;
	TWEEN_IMAGE_END[1].XE = 11;
	TWEEN_IMAGE_END[1].YE = 5;
	TWEEN_IMAGE_END[1].HUE = hue2;
	TWEEN_IMAGE_END[1].DATA1 = 6;   // peaks
	TWEEN_IMAGE_END[1].DATA2 = 2;  // amplitude
	TWEEN_IMAGE_END[1].DATA3 = hue1;  // spike color yellow

	///////////////*****************  new code for beat show ************************




		//Serial.println(F(""));
		//Serial.print(F("++++++BS12 : beat_count="));
		//Serial.println(beat_count);
		//Serial.println(F(""));


		//Serial.print(F("++++++BS12 : active_increment="));
		//Serial.println(active_increment);
		//Serial.print(F("   previous_increment="));
		//Serial.println(previous_increment);
		//Serial.print(F("   enable="));
		//Serial.println(enable);
		//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			//direction = -1 * direction;  // change direction

		}

	}


}

////////////////////////////////////////////////////////////////////////
void BEAT_SHOW_19(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE)   //vertical red ziz zag that moves sidways:   2nd TWEEN BEAT SHOW
//SHOW: verticle spikes with axis move towards each other
//modulus= an animation increments each modulus count

// total_increments = number of images created between the two base sets
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, ...
//3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes with axis, 9=spike no axix
{

	if (enable == 0) { return; }

	byte number_of_images = 2;  // number of  images to create for each base set...no more than 10

	static byte active_increment = 0;  // which of the total increments is active for this beat
	static int direction = 1;

	/////////// START ///////////////////
	///////// zig_zag bottom

	TWEEN_IMAGE_START[0].IMAGE_KIND = 8;  // spike with no axis
	TWEEN_IMAGE_START[0].XS = 4;
	TWEEN_IMAGE_START[0].YS = 5;
	TWEEN_IMAGE_START[0].XE = 4;
	TWEEN_IMAGE_START[0].YE = 15;
	TWEEN_IMAGE_START[0].HUE = hue1;  // red
	TWEEN_IMAGE_START[0].DATA1 = 6;   // peaks  ... only 4 will show as only 4 are positive
	TWEEN_IMAGE_START[0].DATA2 = 5;  // amplitude
	TWEEN_IMAGE_START[0].DATA3 = hue2;  // spike color

	TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes no axis
	TWEEN_IMAGE_START[1].XS = 10;
	TWEEN_IMAGE_START[1].YS = 15;
	TWEEN_IMAGE_START[1].XE = 10;
	TWEEN_IMAGE_START[1].YE = 5;
	TWEEN_IMAGE_START[1].HUE = hue2;  // yellow, hue2
	TWEEN_IMAGE_START[1].DATA1 = 4;   // peaks
	TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
	TWEEN_IMAGE_START[1].DATA3 = hue1;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = 8;  //spike with no axis
	TWEEN_IMAGE_END[0].XS = 10;
	TWEEN_IMAGE_END[0].YS = 5;
	TWEEN_IMAGE_END[0].XE = 10;
	TWEEN_IMAGE_END[0].YE = 15;
	TWEEN_IMAGE_END[0].HUE = hue1;
	TWEEN_IMAGE_END[0].DATA1 = 6;   // peaks
	TWEEN_IMAGE_END[0].DATA2 = 2;  // amplitude
	TWEEN_IMAGE_END[0].DATA3 = hue2;  // spike color

	TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes no axis
	TWEEN_IMAGE_END[1].XS = 5;
	TWEEN_IMAGE_END[1].YS = 15;
	TWEEN_IMAGE_END[1].XE = 5;
	TWEEN_IMAGE_END[1].YE = 5;
	TWEEN_IMAGE_END[1].HUE = hue2;  //hue2
	TWEEN_IMAGE_END[1].DATA1 = 4;   // peaks
	TWEEN_IMAGE_END[1].DATA2 = 2;  // amplitude
	TWEEN_IMAGE_END[1].DATA3 = hue1;  // spike color yellow

	///////////////*****************  new code for beat show ************************




		//Serial.println(F(""));
		//Serial.print(F("++++++BS12 : beat_count="));
		//Serial.println(beat_count);
		//Serial.println(F(""));


		//Serial.print(F("++++++BS12 : active_increment="));
		//Serial.println(active_increment);
		//Serial.print(F("   previous_increment="));
		//Serial.println(previous_increment);
		//Serial.print(F("   enable="));
		//Serial.println(enable);
		//Serial.println(F(""));

	TWEEN(image_kind, number_of_images, total_increments, active_increment, HUE_CODE, direction);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment;

		if (active_increment > total_increments)
		{
			active_increment = 0;
			direction = -1 * direction;  // change direction

		}

	}


}







////////////////////////////////////////////////////////////////////////
// randomly generated beat show
byte BEAT_SHOW_RAND(unsigned long beat_count, byte modulus, byte enable, byte total_increments, byte image_kind, int hue1, int hue2, int HUE_CODE, byte restart_flag, byte index)
//SHOW: vertical large circle at bottom --> small circle at top
//modulus=beats to complete show, 0=don't execute
//enable=1 for show to execute, 0=do nothing
//total_increments=  number of images created between the two base sets, was 5
// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes , 100 = RANDOM_IMAGE_KIND
// data2, data3 = not used 
//hue1=image1 starting and ending hue,  hue2= image2 starting and ending hue
// restart_flag =1 to re-initalize the random variables
// index = defines which TWEEN is being referenced 


// return 1 if show completes 1 bounce or is not enabled

	// HUE CODES
////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000

{
#define NUMBER_OF_IMAGE_KINDS 9  // at the moment there are only 8 types of images...LINE, CIRCLE, RECTANGLE etc. ...

	//Serial.println(F("+++++  BS_RAND: 0 >>>>>>>>>>>>>"));

	if ((enable == 0) || (index >= MAX_NUMBER_RANDOM_TWEEN)) { return 1; }

	if (modulus == 0) { modulus = 1; }

	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
	byte rv = 0; // return value

	static byte active_increment[MAX_NUMBER_RANDOM_TWEEN];  // which of the total increments is active for this beat
	static int direction[MAX_NUMBER_RANDOM_TWEEN];

#define MAX_RANDOM_RANGE 15

	//Serial.println(F("+++++  BS_RAND: A >>>>>>>>>>>>>"));
	//Serial.println(restart_flag);
	//Serial.println(image_kind);
	//Serial.println(index);


	//Serial.println(F("+++++  BS_RAND: AA >>>>>>>>>>>>>"));

	/// random variables
	if (restart_flag == 1)
	{
		//Serial.println(F("+++++  BS_RAND: B >>>>>>>>>>>>>"));

		randomSeed(analogRead(0));

		direction[index] = 1; // initialize
		active_increment[index] = 0; // initialize

		if (image_kind == RANDOM_IMAGE_KIND)  // random KIND
		{
			//Serial.println(F(""));
			//Serial.println(F("+++++++++  BS_RAND: C >>>>>>>>>>>>>"));
			//Serial.println(F(""));

			// note: below I add 1 to NUMBER_OF_IMAGE_KINDS because random() excludes the MAX value but includes the MIN value
			TWEEN_RANDOM_START[index].IMAGE_KIND = randomI(1, NUMBER_OF_IMAGE_KINDS); // at the moment there are only 9 types of images

			// below is for TEST ONLY
			//TWEEN_RANDOM_START[index].IMAGE_KIND = randomI(1, NUMBER_OF_IMAGE_KINDS-2); // at the moment there are only 8 types of images


			//************ below is for TEST ONLY //////////////////
			//TWEEN_RANDOM_START[index].IMAGE_KIND = 9;
			///////////////////////////////////////////////


			TWEEN_RANDOM_END[index].IMAGE_KIND = TWEEN_RANDOM_START[index].IMAGE_KIND;

			//Serial.println(F(""));
			//Serial.print(F("----------------------------------->BS:  TWEEN_RANDOM_START[index].IMAGE_KIND= "));
			//Serial.println(TWEEN_RANDOM_START[index].IMAGE_KIND);
			//Serial.print(F("------------------------------------------>BS:  index= "));
			//Serial.println(index);
			//Serial.println(F(""));
		}
		else
		{
			//Serial.println(F("+++++  BS_RAND: D >>>>>>>>>>>>>"));

			if (image_kind == 0) { image_kind = 1; }  // default image kind = line

			//TWEEN_IMAGE_START[index].IMAGE_KIND = image_kind;  // specified image kind
			//TWEEN_IMAGE_END[index].IMAGE_KIND = image_kind;  // specified image kind

			//Serial.println(F("+++++  BS_RAND: DD >>>>>>>>>>>>>"));

			TWEEN_RANDOM_START[index].IMAGE_KIND = image_kind;  // specified image kind
			TWEEN_RANDOM_END[index].IMAGE_KIND = image_kind;  // specified image kind
		}

		//Serial.println(F("+++++  BS_RAND: 1 >>>>>>>>>>>>>"));

		TWEEN_RANDOM_START[index].HUE = hue1;
		TWEEN_RANDOM_START[index].XS = random(0, MAX_RANDOM_RANGE);
		TWEEN_RANDOM_START[index].YS = random(0, 21);
		TWEEN_RANDOM_START[index].XE = random(0, MAX_RANDOM_RANGE);  //radius if circle
		TWEEN_RANDOM_START[index].YE = random(0, 21);
		TWEEN_RANDOM_START[index].DATA1 = random(1, 6);   // number of peaks
		TWEEN_RANDOM_START[index].DATA2 = random(1, 8);   // starting amplitude
		TWEEN_RANDOM_START[index].DATA3 = random(0, 255); // random spike hue

		//Serial.println(F("+++++  BS_RAND: 2 >>>>>>>>>>>>>"));

		TWEEN_RANDOM_END[index].HUE = hue2;
		TWEEN_RANDOM_END[index].XS = random(0, MAX_RANDOM_RANGE);
		TWEEN_RANDOM_END[index].YS = random(0, 21);
		TWEEN_RANDOM_END[index].XE = random(0, MAX_RANDOM_RANGE);
		TWEEN_RANDOM_END[index].YE = random(0, 21);
		TWEEN_RANDOM_END[index].DATA1 = random(1, 6);   // number of peaks
		TWEEN_RANDOM_END[index].DATA2 = random(1, 8);   // ending amplitude
		TWEEN_RANDOM_END[index].DATA3 = TWEEN_RANDOM_START[index].DATA3;  // random spike hue

		//Serial.println(F("+++++  BS_RAND: 3 >>>>>>>>>>>>>"));
		//Serial.print(F(" -------------------------->>>>>>TWEEN_RANDOM_START[index].IMAGE_KIND= "));
		//Serial.println(TWEEN_RANDOM_START[index].IMAGE_KIND);
		//Serial.print(F(" ----------------------->>>>index = "));
		//Serial.println(index);
		//Serial.println(F(""));

		// make sure beginning and ending images are a minimum length (tweens can be smaller)
		if ((TWEEN_RANDOM_START[index].IMAGE_KIND == 7) || (TWEEN_RANDOM_START[index].IMAGE_KIND == 8)) // zig-zag or spikes
		{

			TWEEN_RANDOM_START[index].XS = 0;
			TWEEN_RANDOM_END[index].XS = 0;

			TWEEN_RANDOM_START[index].XE = random(12, MAX_RANDOM_RANGE);
			TWEEN_RANDOM_END[index].XE = random(12, MAX_RANDOM_RANGE);

		}


	}

	////// for TEST ONLY  ///
	//if (restart_flag == 1)
	//{
	//	hue1 = 171;
	//	hue2 = 171; 

	//}
	//else
	//{
	//	hue1 = 0;
	//	hue2 = 0;
	//}
	//////////////////////




	/////////// START ///////////////////

	TWEEN_IMAGE_START[0].IMAGE_KIND = TWEEN_RANDOM_START[index].IMAGE_KIND;
	TWEEN_IMAGE_START[0].XS = TWEEN_RANDOM_START[index].XS;  // center
	TWEEN_IMAGE_START[0].YS = TWEEN_RANDOM_START[index].YS;  // center
	TWEEN_IMAGE_START[0].XE = TWEEN_RANDOM_START[index].XE;  // radius
	TWEEN_IMAGE_START[0].YE = TWEEN_RANDOM_START[index].YE;
	TWEEN_IMAGE_START[0].HUE = hue1;
	TWEEN_IMAGE_START[0].DATA1 = TWEEN_RANDOM_START[index].DATA1;   //// number of peaks
	TWEEN_IMAGE_START[0].DATA2 = TWEEN_RANDOM_START[index].DATA2;  // // starting amplitude
	TWEEN_IMAGE_START[0].DATA3 = TWEEN_RANDOM_START[index].DATA3;  // spike hue

	//TWEEN_IMAGE_START[1].IMAGE_KIND = 2;  //circle
	//TWEEN_IMAGE_START[1].XS = 15;  // center
	//TWEEN_IMAGE_START[1].YS = 16; // center
	//TWEEN_IMAGE_START[1].XE = 15;  // radius
	//TWEEN_IMAGE_START[1].YE = 11;  // not used
	//TWEEN_IMAGE_START[1].HUE = hue2;  // 
	//TWEEN_IMAGE_START[1].DATA1 = 0;   // peaks
	//TWEEN_IMAGE_START[1].DATA2 = data2;  // amplitude
	//TWEEN_IMAGE_START[1].DATA3 = data3;  // spike color yellow



	/////////////////////////

	/////////// END ///////////////////



	TWEEN_IMAGE_END[0].IMAGE_KIND = TWEEN_RANDOM_END[index].IMAGE_KIND;
	TWEEN_IMAGE_END[0].XS = TWEEN_RANDOM_END[index].XS;
	TWEEN_IMAGE_END[0].YS = TWEEN_RANDOM_END[index].YS;
	TWEEN_IMAGE_END[0].XE = TWEEN_RANDOM_END[index].XE; // radius
	TWEEN_IMAGE_END[0].YE = TWEEN_RANDOM_END[index].YE;
	TWEEN_IMAGE_END[0].HUE = hue2;
	TWEEN_IMAGE_END[0].DATA1 = TWEEN_RANDOM_END[index].DATA1;   //// number of peaks
	TWEEN_IMAGE_END[0].DATA2 = TWEEN_RANDOM_END[index].DATA2;  // // starting amplitude
	TWEEN_IMAGE_END[0].DATA3 = TWEEN_RANDOM_END[index].DATA3;  // spike hue

	//TWEEN_IMAGE_END[1].IMAGE_KIND = 2;  //line
	//TWEEN_IMAGE_END[1].XS = 0;
	//TWEEN_IMAGE_END[1].YS = 16;
	//TWEEN_IMAGE_END[1].XE = 1;  // radius
	//TWEEN_IMAGE_END[1].YE = 0;
	//TWEEN_IMAGE_END[1].HUE = hue1;
	//TWEEN_IMAGE_END[1].DATA1 = 0;   // peaks  // not used
	//TWEEN_IMAGE_END[1].DATA2 = data2;  // amplitude  // not used
	//TWEEN_IMAGE_END[1].DATA3 = data3;  // spike color yellow  // not used

///////////////*****************  new code for beat show ************************




		//Serial.println(F(""));
		//Serial.print(F("++++++BS12 : beat_count="));
		//Serial.println(beat_count);
		//Serial.println(F(""));


		//Serial.println(F("++++++BS_RAND ***"));
		//Serial.print(F("image_kind= "));
		//Serial.println(image_kind);
		//Serial.print(F("total_increments= "));
		//Serial.println(total_increments);
		//Serial.print(F("image_kind= "));
		//Serial.println(image_kind);

	 //   Serial.println(F(""));
		//Serial.println(F("--------------------------------> BEAT_SHOW_RAND: before TWEEN "));
		//Serial.print(F("index= "));
		//Serial.println(index);
		//Serial.print(F("active_increment[index]= "));
		//Serial.println(active_increment[index]);
		//Serial.print(F("total_increments= "));
		//Serial.println(total_increments);
		//Serial.println(F(""));


		//Serial.print(F(" direction[index]= "));
		//Serial.println(direction[index]);
		//Serial.print(F(" beat_count= "));
		//Serial.println(beat_count);
		//Serial.print(F(" beat_count%modulus= "));
		//Serial.println((beat_count%modulus));
		//Serial.println(F(""));


	if (image_kind == RANDOM_IMAGE_KIND) { image_kind = 0; }  // use stored random image

	TWEEN(image_kind, number_of_images, total_increments, active_increment[index], HUE_CODE, direction[index]);
	//TWEEN_RANDOM(image_kind, number_of_images, total_increments, active_increment[index], HUE_CODE, direction[index]);

	// update active_increment
	if ((beat_count % modulus) == 0)
	{
		++active_increment[index];

		if (active_increment[index] > total_increments)
		{
			active_increment[index] = 0;
			direction[index] = -1 * direction[index];

			if (direction[index] == 1) { rv = 1; }  // signal completion of 1 full bounce
		}

	}


	//Serial.println(F(">>>>>>> BS_RAND: END "));
	//Serial.print(F("rv= "));
	//Serial.println(rv);
	//Serial.println(F(""));

	return rv;
}

///////////
//////////////////////////////////////////////////////////////////////////
//byte BEAT_SHOW_12_backup(unsigned long beat_count, byte modulus, byte enable, byte extra, byte hue)   // ziz zag  1st TWEEN BEAT SHOW
////SHOW: vertical large circle at bottom --> small circle at top
////modulus=beats to complete show, 0=don't execute
////enable=1 for show to execute, 0=erase pervious 
//// extra = not defined for this show
//// return 0 when show is complete otherwise return 1 while show is active
//// return 0 and do not execute show if enable=0;
//{
//
//	//if (enable == 0) { return 0; }
//
//
//#define BOUNCES_PER_IMAGE 3  // number of time each image type will bounce between each image
//
//	byte number_of_images = 1;  // number of  images to create for each base set...no more than 10
//	byte image_kind = 0;  // image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
//	byte total_increments = 3;  // number of images created between the two base sets, was 5
//	int time_between_frames = 1000;
//	byte bounce_cycles = 2;  // 
//	static byte active_increment = 0;  // which of the total increments is active for this beat
//	static byte previous_increment = total_increments - 1;  // previously active increment
//	int direction = 1;
//
//	byte rv = 0;
//
//	/////////// BANK 0 ///////////////////
//	///////// zig_zag bottom
//
//	TWEEN_IMAGE_START[0].IMAGE_KIND = 7;
//	TWEEN_IMAGE_START[0].XS = 0;
//	TWEEN_IMAGE_START[0].YS = 0;
//	TWEEN_IMAGE_START[0].XE = 21;
//	TWEEN_IMAGE_START[0].YE = 0;
//	TWEEN_IMAGE_START[0].HUE = 171;
//	TWEEN_IMAGE_START[0].DATA1 = 4;   // peaks
//	TWEEN_IMAGE_START[0].DATA2 = 4;  // amplitude
//
//	TWEEN_IMAGE_START[1].IMAGE_KIND = 8;  // spikes with axis
//	TWEEN_IMAGE_START[1].XS = 0;
//	TWEEN_IMAGE_START[1].YS = 0;
//	TWEEN_IMAGE_START[1].XE = 0;
//	TWEEN_IMAGE_START[1].YE = 21;
//	TWEEN_IMAGE_START[1].HUE = 42;  // yellow
//	TWEEN_IMAGE_START[1].DATA1 = 8;   // peaks
//	TWEEN_IMAGE_START[1].DATA2 = 5;  // amplitude
//	TWEEN_IMAGE_START[1].DATA3 = 42;  // spike color yellow
//
//
//
//	/////////////////////////
//
//	/////////// BANK 1 ///////////////////
//
//
//
//	TWEEN_IMAGE_END[0].IMAGE_KIND = 7;  //zig_zag
//	TWEEN_IMAGE_END[0].XS = 0;
//	TWEEN_IMAGE_END[0].YS = 21;
//	TWEEN_IMAGE_END[0].XE = 11;
//	TWEEN_IMAGE_END[0].YE = 21;
//	TWEEN_IMAGE_END[0].HUE = 0;
//	TWEEN_IMAGE_END[0].DATA1 = 2;   // peaks
//	TWEEN_IMAGE_END[0].DATA2 = 6;  // amplitude
//
//	TWEEN_IMAGE_END[1].IMAGE_KIND = 8;  //spikes
//	TWEEN_IMAGE_END[1].XS = 0;
//	TWEEN_IMAGE_END[1].YS = 0;
//	TWEEN_IMAGE_END[1].XE = 0;
//	TWEEN_IMAGE_END[1].YE = 21;
//	TWEEN_IMAGE_END[1].HUE = 42;
//	TWEEN_IMAGE_END[1].DATA1 = 8;   // peaks
//	TWEEN_IMAGE_END[1].DATA2 = 1;  // amplitude
//	TWEEN_IMAGE_END[1].DATA3 = 42;  // spike color yellow
//
//	////////
//
//
//
//
//	////////
//
//	image_kind = 0;  // use stored image kind
//
//
//
/////////////////*****************  new code for beat show ************************
//
//
//
//	// generate active_increment
//	if ((beat_count%modulus) == 0)
//	{
//
//		Serial.println(F(""));
//		Serial.print(F("++++++BS12 : beat_count="));
//		Serial.println(beat_count);
//		Serial.println(F(""));
//
//
//
//
//
//
//		Serial.print(F("++++++BS12 : active_increment="));
//		Serial.println(active_increment);
//		Serial.print(F("   previous_increment="));
//		Serial.println(previous_increment);
//		Serial.print(F("   enable="));
//		Serial.println(enable);
//		Serial.println(F(""));
//
//		if (enable == 0) // skip a new draw and erase any old ones
//		{
//
//			//if (do_once == 1)  // erase image
//			{
//
//
//				TWEEN(image_kind, number_of_images, total_increments, previous_increment, ERASE_IMAGE, direction);
//
//				rv = 0;
//			}
//
//		}
//
//		if (enable != 0)
//		{
//
//			TWEEN(image_kind, number_of_images, total_increments, active_increment, STARTING_IMAGE_HUE, direction);
//
//
//
//			rv = 1;
//
//
//			previous_increment = active_increment;
//
//			++active_increment;
//
//
//			if (active_increment > total_increments)
//			{
//				active_increment = 0;
//				previous_increment = total_increments;
//			}
//
//
//		}
//
//
//
//		return rv;
//
//	}
//
//
//
//	//Serial.println(F("++++++PROD2: show 15 : direction = forward"));
//
//	//if (G_interceeded_flag == 1)  // next show forced so exit
//	//{
//	//	break;
//	//}
//
//
//
//
//
///////////////////****************************************************************
//
//
//
//
//
//}





////////////////////////////////////////////////////////////
byte SOUND_DETECT(byte threshold, byte bypass_FFT)  // return a 1 if a sound is detected above pre-defined threshold
{
	// this function takes 123ms to complete


	//Serial.println(F("** SOUND_DETECT: position 0 **"));

	if (G_MIC_ON_flag == 0) { return 0; }

	byte rv = 0;

	if (bypass_FFT == 0)
	{
		//Serial.println(F("** SOUND_DETECT: position 1 **"));

		FFT_COMPUTE(); ////sample analog input and  Compute FFT

		//Serial.println(F("** SOUND_DETECT: position 2 **"));

		BAND(G_COMB_bandValues);  // combine frequencies into BANDs 

		//Serial.println(F("** SOUND_DETECT: position 3 **"));
	}

	int summed_bands = 0;  // sum of all band values

	for (byte band = 0; band < 22; band++)
	{

		// Scale the bars for the display
		//int barHeight = bandValues[band] / AMPLITUDE;
		int barHeight = bandValues[band] / AMPLITUDE;

		summed_bands = summed_bands + barHeight;


		//if (barHeight > TOP) barHeight = TOP;


	}

	//Serial.print(F("+++++++>  SD summed_bands="));
	//Serial.println(summed_bands);

	if (summed_bands > threshold)
	{
		rv = 1;




		//Serial.println(F(""));
		//Serial.print(F("threshold="));
		//Serial.println(threshold);
		//Serial.print(F("summed_bands="));
		//Serial.println(summed_bands);

		//for (byte band = 0; band < 22; band++)
		//{
		//	
		//	if (bandValues[band] > 0)
		//	{
		//		Serial.print(F("bandValues["));
		//		Serial.print(band);
		//		Serial.print(F("]/AMPLITUDE="));
		//		Serial.println(bandValues[band]/AMPLITUDE);
		//	}
		//
		//}
	}

	if (rv == 0)
	{
		MODIFY_GUI4(16);  // turn oFF SOUND DETECT indicator
	}
	else
	{
		MODIFY_GUI4(15);  // turn on SOUND DETECT indicator
	}

	//Serial.println(F("** SOUND_DETECT: END **"));

	return rv;

}

////////////////////////////////////////////////////////////
//byte SOUND_DETECT2(byte threshold, byte bypass_FFT)  // use FFT:   return a 1 if a sound is detected above pre-defined threshold
//{
//
//#define noise_level 6
//	int amplitude = 2000;  // was 3000
//
//	byte rv = 0;
//	int sum = 0;
//	byte starting_bin = 14;  // filter out very low freq which is causing false trigger
//
//	if (bypass_FFT == 0)
//	{
//		FFT_COMPUTE(); ////sample analog input and  Compute FFT
//		
//		for (int i = starting_bin; i < (SAMPLES / 2); i++)
//		{       // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.
//
//			if (vReal[i] > NOISE)
//			{
//				sum = sum + (int)(vReal[i]/amplitude);
//
//			}
//
//		}
//
//		Serial.print(F("+++++++>  SD2 sum="));
//		Serial.println(sum);
//
//	}
//
//
//	if (sum > threshold)
//	{
//		rv = 1;
//
//		//Serial.println(F(""));
//		//Serial.print(F("SD2 threshold="));
//		//Serial.println(threshold);
//		//Serial.print(F("summed_bands="));
//		//Serial.println(summed_bands);
//
//		//for (byte band = 0; band < 22; band++)
//		//{
//		//	
//		//	if (bandValues[band] > 0)
//		//	{
//		//		Serial.print(F("bandValues["));
//		//		Serial.print(band);
//		//		Serial.print(F("]/AMPLITUDE="));
//		//		Serial.println(bandValues[band]/AMPLITUDE);
//		//	}
//		//
//		//}
//
//		// Serial.print(F(""));
//	}
//
//	if (sum > threshold)
//	{
//		Serial.print(F("rv="));
//		Serial.println(rv);
//		Serial.print(F("SD2 sum="));
//		Serial.println(sum);
//		Serial.println(F(""));
//
//		
//		//for (int i = 2; i < (SAMPLES / 2); i++) // Don't use sample 0 and only first SAMPLES/2 are usable. Each array element represents a frequency bin and its value the amplitude.
//		//{       
//		//	if ((int)(vReal[i] / amplitude) > 0)
//		//	{
//		//		Serial.print(F("vReal["));
//		//		Serial.print(i);
//		//		Serial.print(F("]/amplitude= "));
//		//		Serial.println((int)(vReal[i] / amplitude));
//
//		//	}
//		//}
//		//	Serial.println(F(""));
//
//	}
//
//	return rv;
//
//}

////////////////////////////////////////////////////////////
byte BEAT_DETECT(int minimum_threshold)  // return a 1 if a BEAT is detected above pre-defined threshold and at a peak
{

	// minimum_threshold = below this audio level no BEAT is detected


#define HIGHEST_BAND 15  // emphasize BASE bands
#define MAX_BEAT_TIME 1000 // 60 beats per minuet	
#define MIN_BEAT_TIME 300   // minimum time between beats = 200 bpm

// (PEAK_DECAY_RATE)exp[seconds*1000/(sample rate in ms)]   = .5 
#define PEAK_DECAY_RATE .99995  // lower numbers decay quicker

#define THRESHOLD_PERCENTAGE 80 // percentage of peak amplitude that defines the threshold value

	static unsigned long beat_start_time = millis();
	static unsigned long beat_end_time = millis();
	static byte beat_hold_off_flag = 0;  // if 1 then no BEAT is reported

	static float peak_amplitude = 0;  // maximum of adjusted audio_pin_A2D_value
	static float unadjusted_peak_amplitude = 0;




	//// test only  ////////////////////////////////////
	static unsigned long previous_beat_detect;
	unsigned long delta_time_beat_detect;


	delta_time_beat_detect = millis() - previous_beat_detect;
	previous_beat_detect = millis();
	////////////////////////////////////////////////////



	//////////////////////////  new beat detect scheme  ///////////////////////////////////
	int audio_pin_A2D_value;


	//audio_pin_A2D_value = G_MIC_gain * analogRead(AUDIO_IN_PIN);
	//audio_pin_A2D_value = analogRead(AUDIO_IN_PIN);
	audio_pin_A2D_value = abs(analogRead(AUDIO_IN_PIN) - 1820);  // 1820 = DC offset

	// find maximum
	if (audio_pin_A2D_value > peak_amplitude)
	{
		peak_amplitude = float(audio_pin_A2D_value);
		//unadjusted_peak_amplitude = audio_pin_A2D_value;
	}
	else  // ** decay peak_amplitude **
	{

		//peak_amplitude = (PEAK_DECAY_RATE*peak_amplitude) / 10000;
		//peak_amplitude = ((1000*peak_amplitude) -1)/1000;
		peak_amplitude = (PEAK_DECAY_RATE * peak_amplitude);

	}

	if (audio_pin_A2D_value > unadjusted_peak_amplitude)
	{
		unadjusted_peak_amplitude = audio_pin_A2D_value;
	}

	// find beat_detect_threshold
	G_beat_detect_threshold = (peak_amplitude * THRESHOLD_PERCENTAGE) / 100;


	// calculate peak_amplitude percentage decay
	G_percentage_beat_detect_amplitude_reduction = 100 - ((peak_amplitude * 100) / unadjusted_peak_amplitude);

	if (audio_pin_A2D_value < minimum_threshold)
	{
		return 0;
	}

	/////////////////////////////////////////////////////////////////////////////////

	//Serial.print(F(" BEAT_DETECT: delta_time_beat_detect =  "));
	//Serial.println(delta_time_beat_detect);
	//Serial.print(F("BD: audio_pin_A2D_value =  "));
	//Serial.println(audio_pin_A2D_value);
	//Serial.print(F("BD: peak_amplitude =  "));
	//Serial.println(peak_amplitude);
	////Serial.print(F(" G_MIC_gain =  "));
	////Serial.println(G_MIC_gain);
	//Serial.println(F(""));



	// check that a valid BEAT ends before time out of MAX_BEAT_TIME
	// this prevents a continuous tone from issuing a beat
	//if ((audio_pin_A2D_value < beat_detect_threshold) && (beat_in_progress_flag == 1))
	if (audio_pin_A2D_value > G_beat_detect_threshold)
	{
		beat_end_time = millis();

		if ((beat_end_time - beat_start_time) > MIN_BEAT_TIME)
		{
			//Serial.println(F("0 BD: audio<th & dtime > MAX_BEAT_TIME"));

			//beat_in_progress_flag = 0; 

			beat_hold_off_flag = 0;
			//return 10;
		}

		//if ((beat_end_time - beat_start_time) < MIN_BEAT_TIME)
		//{
		//	//Serial.println(F("0 BD: audio<th & dtime < MIN_BEAT_TIME"));
		//	
		//	//beat_in_progress_flag = 1;
		//	return 11;
		//}

	}


	// only return a beat if no previous BEAT is in progress
	// this prevents a continuous tone from issuing a beat
	//if (audio_pin_A2D_value > beat_detect_threshold) 
	if ((audio_pin_A2D_value > G_beat_detect_threshold) && (beat_hold_off_flag == 0))
	{

		beat_start_time = millis();
		//beat_in_progress_flag = 1;

		beat_hold_off_flag = 1;

		//Serial.println(F("** 1 **BD"));

		return 1;

	}


	//Serial.println(F("0 BD: END"));
	return 0;

}


////////////////////////////////////////////////////////////////////
//byte MUSIC_DETECT_new(byte junk) // NEW:   return a 1 if at least two beats are detected in the SOUND_DETECT_INVERVAL, junk not needed
//// note: This function consumes 
//{
//	if (G_MIC_ON_flag == 0) { return 0; }
//
//	
//	byte beat = 0;
//	unsigned long sound_detect_interval_start ;
//	unsigned long beat_counts = 0;
//	
//	unsigned long SOUND_DETECT_INVERVAL = 2000; // 2 seconds 
//
//	if (SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0) == 0)  // return if no sound is detected
//	{
//		return 0;
//
//	}
//
//	sound_detect_interval_start = millis();
//
//	// if sound is detected make sure it has a beat
//	while (((millis() - sound_detect_interval_start) < SOUND_DETECT_INVERVAL))  // sound detected over SOUND_DETECT_INTERVAL
//	{
//		//Serial.println(F("** MD: position 3 **"));
//
//		beat = BEAT_DETECT(BEAT_DETECT_THRESHOLD); // 200 was determined by turning off sound and looking at the adjusted peak threshold
//
//		if (beat == 1)
//		{
//			++beat_counts;
//
//			//Serial.println(F("** MD: position 4 **"));
//
//		}
//
//		// music not detected
//		if ((beat_counts == 0) && ((millis() - sound_detect_interval_start)  >  SOUND_DETECT_INVERVAL / 2))  // a minimum of 1 beat must be detected in half the SOUND_DETECT_INVERVAL
//		{
//			SPACE
//			Serial.println(F("** MusicD: NO MUSIC"));
//			SPACE
//				
//				G_MUSIC_detected_flag = 0;  // will be set to 1 if MUSIC is detected
//				MODIFY_GUI4(12); // turn off MUSIC DETECT indicator
//			
//			return 0; 
//
//		}
//		
//
//	}
//
//	if (beat_counts >= 2)  // MUSIC detected
//	{
//		SPACE
//			Serial.println(F("$$$$$$$$$$$$ MusicD: DETECTED"));
//		SPACE
//
//			G_MUSIC_detected_flag = 1;  // will be set to 1 if MUSIC is detected
//			MODIFY_GUI4(11); // turn on MUSIC DETECT indicator
//
//		
//		
//		return 1; 
//	}
//	
//
//}

//////////////////////////////////////////////////////////////////////
//byte MUSIC_DETECT(unsigned long SOUND_DETECT_INVERVAL) // used to determine how often this is run
//{
//	static unsigned long previous_time_stamp = millis();
//
//	unsigned long delta_time = millis() - previous_time_stamp;
//
//	previous_time_stamp = millis();
//
//	SPACE
//	Serial.print(F("$$$$$$$$$$$$ Music: DETECT: delta_time = "));
//	Serial.println(delta_time);
//	SPACE
//
//
//	return 0;
//}




////////////////////////////////////////////////////////////////////
byte MUSIC_DETECT(unsigned long SOUND_DETECT_INVERVAL, byte count_threshold) // return a 1 if sound is detected over an interval defined by SOUND_DETECT_INVERVAL
//count_threshold = number of counts within SOUND_DETECT_INTERVAL that when exceeded or equal returns a 1
//NOTE: This routine looks if sound is detected over the SOUND_DETECT_INTERVAL but is spread out over multiple calls of this function
//NOTE: If intermittent sound is detected over the SOUND_DETECT_INTERVAL then  MUSIC_DETECT will return a 1=G_MUSIC_detected_flag
// this function takes 133ms to complete
{

	//Serial.print(F("+++++++++++++++++++ MUSIC_DETECT: start  ++++++++++++++++++++++++"));

	static byte sound_detect_count = 0;
	static unsigned long sound_detect_interval_start = millis();

	if (G_music_only_switch == 1)
	{
		G_MUSIC_detected_flag = 1;
		sound_detect_count = 1;
		return 1;
		
	}

	if (G_MIC_ON_flag == 0)
	{ 
		G_MUSIC_detected_flag = 0;
		sound_detect_count = 0;
		return 0; 
	}

//#define count_threshold 3 // number of counts within SOUND_DETECT_INTERVAL that when exceeded or equal returns a 1
	


	//Serial.println(F("** MD: position 0 **"));
	//Serial.print(F("G_sampling_period_us= "));
	//Serial.println(G_sampling_period_us);


	if (SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0) == 1)
	{
		//	Serial.println(F("** MD: position 1a **"));

		++sound_detect_count;

	}
	

		// when a sound is detected check if there is more sound within the SOUND_DETECT_INVERVAL

		//Serial.println(F("** MD: position 2 **"));


	//if (((millis() - sound_detect_interval_start) > SOUND_DETECT_INVERVAL)|| (sound_detect_count >= count_threshold))  // make MUSIC_DETECT decision
	if (((millis() - sound_detect_interval_start) > SOUND_DETECT_INVERVAL) || (sound_detect_count >= count_threshold))  // make MUSIC_DETECT decision
	// return 1 if (sound_detect_count >= count_threshold) within the SOUND_DETECT_INVERVAL
	{
		
		if (sound_detect_count >= count_threshold)
		{
			
			G_music_start_time = millis();  // keep track of last MUSIC detection time
			G_MUSIC_detected_flag = 1; // will be set to 1 if MUSIC is detected

			//Serial.print(F("++++++++++++++++++++++++++ MUSIC_DETECT: detected: sound_detect_count="));
			//Serial.println(sound_detect_count);

		}
		else
		{
			G_MUSIC_detected_flag = 0;

		}

		sound_detect_interval_start = millis();   // reset static variable
		sound_detect_count = 0;  // reset static variable
	} 


	//Serial.println(F("** MD: END **"));

	if (G_MUSIC_detected_flag == 1)
	{
		MODIFY_GUI4(11); // turn on MUSIC DETECT indicator

	}
	else
	{
		MODIFY_GUI4(12); // turn off MUSIC DETECT indicator

	}

	SPACE
	Serial.print(F("+++++++++++++++++++ MUSIC_DETECT++++++: G_MUSIC_detected_flag= "));
	Serial.println(G_MUSIC_detected_flag);
	SPACE

	return G_MUSIC_detected_flag;

}

//////////////////////////////////////////////////////////////////////
//byte MUSIC_DETECT_previous(unsigned long SOUND_DETECT_INVERVAL) // return a 1 if sound is detected over an interval defined by SOUND_DETECT_INVERVAL
//{
//
//	if (G_MIC_ON_flag == 0) { return 0; }
//
//#define count_threshold 2 // number of counts within SOUND_DETECT_INTERVAL that when exceeded or equal returns a 1
//	byte rv = 0;
//	byte sound_detect_count = 0;
//	unsigned long sound_detect_interval_start;
//
//	//Serial.println(F("** MD: position 0 **"));
//	//Serial.print(F("G_sampling_period_us= "));
//	//Serial.println(G_sampling_period_us);
//
//
//	if (SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0) == 1)
//	{
//		//	Serial.println(F("** MD: position 1a **"));
//
//		++sound_detect_count;
//
//		if (sound_detect_count == 1) { sound_detect_interval_start = millis(); }
//
//	}
//	//	else
//	//	{
//	//		Serial.println(F("** MD: 1b **"));
//
//			//return 0;
//
//		//	rv = 0;
//	//	}
//
//		// when a sound is detected check if there is more sound within the SOUND_DETECT_INVERVAL
//
//		//Serial.println(F("** MD: position 2 **"));
//
//	if (sound_detect_count > 0)
//	{
//		while (((millis() - sound_detect_interval_start) < SOUND_DETECT_INVERVAL))  // sound detected over SOUND_DETECT_INTERVAL
//		{
//			//Serial.println(F("** MD: position 3 **"));
//
//			if (SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0) == 1)
//			{
//				++sound_detect_count;
//
//				//Serial.println(F("** MD: position 4 **"));
//
//			}
//			else
//			{
//				sound_detect_count = 0;
//
//			}
//
//		}
//	}
//
//	if (sound_detect_count >= count_threshold)
//	{
//
//		rv = 1;
//		G_music_start_time = millis();  // keep track of last MUSIC detection time
//	}
//
//	//Serial.println(F("** MD: END **"));
//
//	if (rv == 1)
//	{
//		MODIFY_GUI4(11); // turn on MUSIC DETECT indicator
//
//	}
//	else
//	{
//		MODIFY_GUI4(12); // turn off MUSIC DETECT indicator
//
//	}
//
//	return rv;
//
//}

/////////////////////////////////////////////////////////////////////
byte NOTE_DETECT2(byte note, int threshold)  // decide if a "note" is detected, return 1 if note is detected
{

	// NOTE: FFT2:   bin width resolution = 8KHz sample rate/512 samples = 15Hz per bin
	// for FFT, 125us/sample --> 64ms/512 samples

		/* NOTE detection works by using FFT2 then running FIND_MAX_CORRELATION_VALUE().
		This is needed to measure G_ND_correlation to determine threshold for NOTE_DETECT2.
		G_ND_correlation is the maximum correlation from any of the MNOTES relative to the FFT2 bins (all bins).
		The threshold for NOTE_DETECT2 is a fixed fraction of G_ND_correlation.
		Also, all the MNOTE data is scaled according to MNOTE[].gain_factor. The MNOTE data is retrieved from TEST #51.
		This data is captured from the microphone after playing each note. But, because playing a note multiple times results in
		data that is not consistant in amplitude, I need to scale the MNOTE data to normalize it.
		The MNOTE[].gain_factor is obtained by playing a NOTE multiple times and finding the maximum correlation value
		as reported by NOTE_DETECT2. I then normalized everything to NOTE 0's maximum correlation value.
		*/

	unsigned long amplitude = 1000;  // was 2000
	int bin = 0;
	byte rv = 0;


	//byte bin_start = MNOTE[note].bin_start;
	unsigned long correlation = 0;

	// calculate correlation between NOTE and FFT bins

  //for (byte bin = starting_bin; bin < starting_bin + 22; ++bin)
	for (byte index = 0; index < MNOTE_SIZE; ++index)
	{
		bin = MNOTE[note].bin[index];

		correlation = correlation + (int((vReal2[bin] / amplitude))) * MNOTE[note].data[index];

	}


	if (correlation > threshold)
	{
		rv = 1;

		//Serial.println(F(""));
		//Serial.print(F(" NOTE_DETECTED="));
		//Serial.println(note);
		//Serial.print(F("correlation="));
		//Serial.println(correlation);

	}

	return rv;

}

/////////////////////////////////////////////////////////////////////
int FIND_MAX_CORRELATION_VALUE()  // return the maximum MNOTE correlation as G_ND_correlation...used to set threshold in NOTE_DETECT
{


	unsigned long note_detect_array[NUMBER_OF_MNOTES]; // the index with the maximum value is the detected note
	unsigned long amplitude = 1000;  // was 2000
	int bin = 0;


	for (int n = 0; n < NUMBER_OF_MNOTES; ++n)  // initalize
	{
		note_detect_array[n] = 0;
	}


	//for (byte note = 0; note < 5; ++note)  // check correlation for each note using 4 of the FFT bins
	for (byte note = 0; note < NUMBER_OF_MNOTES; ++note)  // check correlation for each note using 4 of the FFT bins
	{
		//byte bin_start = MNOTE[note].bin_start;
		unsigned long correlation = 0;

		// calculate correlation between NOTE and FFT bins

	  //for (byte bin = starting_bin; bin < starting_bin + 22; ++bin)
		for (byte index = 0; index < MNOTE_SIZE; ++index)
		{
			bin = MNOTE[note].bin[index];

			correlation = correlation + (int((vReal2[bin] / amplitude))) * MNOTE[note].data[index];



		}

		note_detect_array[note] = correlation;

	}

	unsigned long maximum = 1;
	byte current_likely_note = 255;  // not a valid note

	//Serial.println(F(""));
	//Serial.println(F(" FIND_MAX_CORRELATION_VALUE"));

	//for (byte note = 0; note < 5; ++note)  // find the most likely note
	for (byte note = 0; note < NUMBER_OF_MNOTES; ++note)  // find the most likely note
	{

		if (note_detect_array[note] > maximum)
		{
			current_likely_note = note;
			maximum = note_detect_array[note];
		}


		//Serial.print(F("note_detect_array["));
		//Serial.print(note);
		//Serial.print(F("]="));
		//Serial.println(note_detect_array[note]);




	}

	G_ND_correlation = maximum;

	return maximum;

}


///////////////////////////////////////////////////////////////////////
void MERGE_LOAD(int bmp, int hue)  // merge the bmp into the existing displayed image
// colorize the image with hue, if hue<0 then don't colorize image
{
	CLEAR_FONT_BUFFER_1();  // clear leds_buffer1
	LOAD_BMP_PANEL(bmp, 5);  // this loads into leds_buffer1


	for (int adr = 0; adr < NUM_LEDS; ++adr)
	{
		if ((leds_buffer1[adr].r > 0) || (leds_buffer1[adr].g > 0) || (leds_buffer1[adr].b > 0))  // merge
		{
			if (hue >= 0)  // colorize
			{
				leds_buffer1[adr].setHue(hue);  // change the LED hue
			}

			leds1[adr] = leds_buffer1[adr];
			leds3[adr] = leds_buffer1[adr];

			int adr2 = modify_adr(0, 0, adr);

			leds2[adr2] = leds_buffer1[adr];
			leds4[adr2] = leds_buffer1[adr];
		}

	}


	//LOAD_BMP_PANEL(bmp, 1);
	//LOAD_BMP_PANEL(bmp, 2);
	//LOAD_BMP_PANEL(bmp, 3);
	//LOAD_BMP_PANEL(bmp, 4);



}


///////////////////////////////////////////////////////////////////////////
void MAP_image_array(byte map)  // store bmp image numbers into the image_array
{
	if (map == 1)
	{
		for (int note = 0; note < NUMBER_OF_MNOTES; ++note)
		{
			image_array[note] = 72 + note; // 72 is starting bmp image
		}




	}
}

//////////////////////////////////////////////////////////////////////
void MAP_MNOTE_HUES(int hue_start, int hue_end)  // assign a HUE to each musical note
// note: if (hue_end - hue_start )/NUMBER_OF_MNOTES isn't an integer then the final MNOTE hue won't equal hue_end (but should be close)
{
	int direction = 1;  // equals 1 if hue_end > hue_start otherwise equals -1

	if (hue_end < hue_start) { direction = -1; }

	int hue_increment = (hue_end - hue_start) / NUMBER_OF_MNOTES;

	if (hue_increment == 0) { hue_increment = direction; }  // either 1 or -1

	for (byte n = 0; n < NUMBER_OF_MNOTES; ++n)
	{
		int mnote_hue = hue_start + n * hue_increment;

		if (mnote_hue < 0) { mnote_hue = 256 + mnote_hue; }  // roll hues

		MNOTE[n].hue = byte(mnote_hue);


	}


	// peg end with specified colors 
	MNOTE[NUMBER_OF_MNOTES - 1].hue = hue_end;



}


////////////////////////////////////////////////////////////////////////
void UPDATE_PRODUCTION_NAME()  // print the name of the production in GUI4
{
	if (G_GUI != 4) { return; }

	SerialBT.print("*N");  // update production name 

	switch (G_production) {
	case 1:
		SerialBT.print("MAIN SHOW");
		break;
	case 2:
		SerialBT.print("CYLINDRICAL COORDINATES");
		break;
	case 3:
		SerialBT.print("FFT SPECTRUM");
		break;
	case 4:
		SerialBT.print("BEAT SHOW");
		break;
	case 5:
		SerialBT.print("MAPPED NOTES");
		break;
	default:
		// statements
		break;
	}



	SerialBT.print("*");


}


/////////////////////////////////////////////////
void SET_HUE_COLOR_INDICATOR()  // change HUE indicator as set by G_hue 
{
	byte r_last = leds1[0].r;
	byte g_last = leds1[0].g;
	byte b_last = leds1[0].b;

	//leds1

	G_hue = atoi(text_array);

	Serial.print(F("BTCH:  G_hue="));
	Serial.println(G_hue);

	// HSV (Rainbow) to RGB color conversion
	CHSV hsv(G_hue, 255, 255);
	hsv2rgb_rainbow(hsv, leds1[0]); // leds1[0] will now be the color


	String BT_string2send = String("*MR" + String(leds1[0].r) + "G" + String(leds1[0].g) + "B" + String(leds1[0].b) + "*");

	SerialBT.print(BT_string2send);  // turn indicator to HUE color

	// restore previous values
	leds1[0].r = r_last;
	leds1[0].g = g_last;
	leds1[0].b = b_last;



}

/////////////////////////////////////////////////////////////////////
byte X_TRANSLATE(float xstart, float xend, float total_increments, float increment)  // translate the x coordinate to a new x coordinate over a number of increments
// xstart=first x coordinate, xend=last x coordinate, total_increments=number of points to generate inbetween, increment=current point to generate
{
	float span;
	float delta_x;
	int new_x;

	span = (1 + abs(xend - xstart));
	delta_x = (span / (total_increments));

	if (xstart > xend)
	{
		delta_x = -1 * delta_x;
	}

	new_x = int((delta_x * increment)) + xstart;

	//Serial.print(F("span="));
	//Serial.println(span);
	//Serial.print(F("delta_x="));
	//Serial.println(delta_x);
	//Serial.print(F("new_x="));
	//Serial.println(new_x);


	//print("X_TRANSLATE", 0);
	//print("span=", span);
	//print("delta_x=", delta_x);
	//print("new_x=", new_x);
	//print("increment=", increment);
	//print("total_increments=", total_increments);
	//SPACE


	if (new_x < 0) { new_x = 0; }
	if (new_x >= NUM_COLUMNS) { new_x = NUM_COLUMNS - 1; }

	if (total_increments - 1 == increment)
	{
		new_x = xend;
	}


	return new_x;

}

/////////////////////////////////////////////////////////////////////
byte Y_TRANSLATE(float ystart, float yend, float total_increments, float increment)  // translate the y coordinate to a new y coordinate over a number of increments
// ystart=first y coordinate, yend=last y coordinate, total_increments=number of points to generate inbetween, increment=current point to generate
{
	float span;
	float delta_y;
	int new_y;

	span = 1 + abs(yend - ystart);

	delta_y = span / (total_increments);

	if (ystart > yend)
	{
		delta_y = -1 * delta_y;
	}


	new_y = int((delta_y * increment)) + ystart;

	//print("Y_TRANSLATE", 0);
	//print("span=", span);
	//print("delta_y=", delta_y);
	//print("new_y=", new_y);
	//print("increment=", increment);
	//print("total_increments=", total_increments);
	//SPACE

	if (new_y < 0) { new_y = 0; }
	if (new_y >= NUM_ROWS) { new_y = NUM_ROWS - 1; }

	if (total_increments - 1 == increment)
	{
		new_y = yend;
	}

	return new_y;

}

////////////////////////////////////////////////////////////////////////////////////
void TWEEN(byte image_kind, byte number_of_images, byte total_increments, byte increment, int hue_code, int direction)  // generate images based on xy pairs from two different images
{
	// image_kind= 0 use stored image kind,  1 for LINE, 2=circle, 3=rectangle, 4= triangle, 5=HOZ_V no XY swap, 6=HOZ_V with XY swap, 7=ZIG_ZAG, 8=spikes
	// number_of_images = total number of images in a set to generate tween images for note: number_of_images is not the same as the total_increments
	// total_increments = how many tween images are generated between the two base sets of images stored in XS1, XS, YS1, YS and XE1, XE, YE1, YE
	// increment = which tween image to generate
	// hue_code = 0 to 255 will force hue; 999=ERASE image;  1000  = generate a weighted blend between start and end images;  2000=use hue from starting image, 3000=use hue from ending image
	// direction= 1 = starting image tweens to ending image;   direction= -1 = ending image tweens to starting image;

	// note: increment can equal total_increments, number of images drawn by the tween will equal total_increments+1 
	// note: for CIRCLE : RADIUS= xe

////#define ERASE_IMAGE 999 
////#define BLEND_START_END_HUE 1000
////#define STARTING_IMAGE_HUE 2000
////#define ENDING_IMAGE_HUE 3000

	if (image_kind > NUMBER_OF_IMAGE_TYPES) { return; }

	byte xs;
	byte ys;

	byte xe;
	byte ye;

	int hue;
	byte image_kind_type = 0;
	byte image_kind_start = 0; // starting image kind
	byte image_kind_end = 0;   // ending image kind

	int hue_spikes;


	int radius;

	if (image_kind > 0)
	{
		image_kind_type = image_kind;
	}

	//++total_increments;  // need one more to get it right// removed 06/17/24

	for (byte n = 0; n < number_of_images; ++n)
	{
		if (direction == -1)
		{



			xs = X_TRANSLATE(TWEEN_IMAGE_END[n].XS, TWEEN_IMAGE_START[n].XS, total_increments, increment);
			ys = Y_TRANSLATE(TWEEN_IMAGE_END[n].YS, TWEEN_IMAGE_START[n].YS, total_increments, increment);

			xe = X_TRANSLATE(TWEEN_IMAGE_END[n].XE, TWEEN_IMAGE_START[n].XE, total_increments, increment);
			ye = Y_TRANSLATE(TWEEN_IMAGE_END[n].YE, TWEEN_IMAGE_START[n].YE, total_increments, increment);


			radius = xe; //*** RADIUS

			if ((hue_code >= 1000) && (hue_code < 1999))  // transition the hue
			{

				hue = HUE_TRANSITION(TWEEN_IMAGE_END[n].HUE, TWEEN_IMAGE_START[n].HUE, total_increments, increment);

				hue_spikes = HUE_TRANSITION(TWEEN_IMAGE_END[n].DATA3, TWEEN_IMAGE_START[n].DATA3, total_increments, increment);
			}

			if (image_kind == 0)  // use stored image kind 
			{
				image_kind_type = TWEEN_IMAGE_END[n].IMAGE_KIND;
				image_kind_start = TWEEN_IMAGE_END[n].IMAGE_KIND;
				image_kind_end = TWEEN_IMAGE_START[n].IMAGE_KIND;

				if (increment >= total_increments / 2)  // switch kind at half way point
				{

					image_kind_type = TWEEN_IMAGE_START[n].IMAGE_KIND;
				}
			}

		}

		if (direction == 1)
		{


			xs = X_TRANSLATE(TWEEN_IMAGE_START[n].XS, TWEEN_IMAGE_END[n].XS, total_increments, increment);
			ys = Y_TRANSLATE(TWEEN_IMAGE_START[n].YS, TWEEN_IMAGE_END[n].YS, total_increments, increment);

			xe = X_TRANSLATE(TWEEN_IMAGE_START[n].XE, TWEEN_IMAGE_END[n].XE, total_increments, increment);
			ye = Y_TRANSLATE(TWEEN_IMAGE_START[n].YE, TWEEN_IMAGE_END[n].YE, total_increments, increment);

			//pprint("tween: ye= ", ye);
			//pprint("increment= ", increment);
			//SPACE

				radius = xe;

			if ((hue_code >= 1000) && (hue_code < 1999))
			{

				hue = HUE_TRANSITION2(TWEEN_IMAGE_START[n].HUE, TWEEN_IMAGE_END[n].HUE, total_increments, increment);

				hue_spikes = HUE_TRANSITION2(TWEEN_IMAGE_START[n].DATA3, TWEEN_IMAGE_END[n].DATA3, total_increments, increment);
			}

			if (image_kind == 0)  // use stored image kind 
			{
				image_kind_type = TWEEN_IMAGE_START[n].IMAGE_KIND;

				image_kind_start = TWEEN_IMAGE_START[n].IMAGE_KIND;
				image_kind_end = TWEEN_IMAGE_END[n].IMAGE_KIND;

				if (increment >= total_increments / 2)  // switch kind at half way point
				{
					image_kind_type = TWEEN_IMAGE_END[n].IMAGE_KIND;
				}
			}

		}



		if (hue_code < 256)  // ues hue supplied in TWEEN hue
		{
			hue = hue_code;
			hue_spikes = hue_code;
		}

		if ((hue_code >= 2000) && (hue_code < 2999))  // use hue from BANK 0 image
		{

			hue = TWEEN_IMAGE_START[n].HUE;
			hue_spikes = TWEEN_IMAGE_START[n].DATA3;

		}

		if ((hue_code >= 3000) && (hue_code < 3999))  // use hue from BANK 1 image
		{

			hue = TWEEN_IMAGE_END[n].HUE;
			hue_spikes = TWEEN_IMAGE_END[n].DATA3;

		}

		if (hue_code == ERASE_IMAGE)
		{
			hue = ERASE_IMAGE;
			hue_spikes = ERASE_IMAGE;
		}

		//Serial.println("");
		//Serial.print(F("TWEEN: image#="));
		//Serial.println(n);
		//Serial.print(F("hue_code="));
		//Serial.println(hue_code);
		//Serial.print(F("hue="));
		//Serial.println(hue);
		//Serial.println("");

		//Serial.print(F("----++>>>> GENERATE_TWEEN:  direction= "));
		//Serial.println(direction);
		//Serial.print(F("increment="));
		//Serial.println(increment);
		//Serial.print(F("xs="));
		//Serial.println(xs);
		//Serial.print(F("ys="));
		//Serial.println(ys);
		//Serial.print(F("xe="));
		//Serial.println(xe);
		//Serial.print(F("ye="));
		//Serial.println(ye);
		//Serial.print(F("radius="));
		//Serial.println(radius);
		//Serial.print(F("image_kind_type="));
		//Serial.println(image_kind_type);
		//Serial.print(F("image number n="));
		//Serial.println(n);
		//Serial.print(F("XE="));
		//Serial.println(XE[n]);
		//Serial.print(F("XE1="));
		//Serial.println(XE1[n]);
		//Serial.println("");



	//	int hue = (HUE_IMAGE1[n] + HUE_IMAGE[n]) / 2;   // average beginning and ending hues

		///////////////
		if (image_kind_type == 1)  // line
		{
			LINE(xs, ys, xe, ye, hue);
		}

		/////////////
		if (image_kind_type == 2) // sphere
		{

			// calculate radius
		//	int delta_X = XE[n];
		//	int delta_Y = YE[n];

			//int radius = sqrt((delta_X*delta_X) + (delta_Y*delta_Y));

			CIRCLE((double)radius, xs, ys, hue);



		}

		////////////
		if (image_kind_type == 3)   // RECTANGLE mode
		{

			RECTANGLE(xs, ys, xe, ye, hue);

		}

		/////////////////
		if (image_kind_type == 4)   // TRIANGLE mode
		{

			TRIANGLE(xs, ys, xe, ye, hue);

		}

		/////////////////
		if (image_kind_type == 5)   // HOZ_V mode NO SWAP SE  
		{

			HOZ_V(xs, ys, xe, ye, 0, hue);

		}

		if (image_kind_type == 6)   // HOZ_V mode SWAP SE
		{

			HOZ_V(xs, ys, xe, ye, 1, hue);

		}

		if (image_kind_type == 7)   // ZIG_ZAG
		{
			double peaks_start = double(TWEEN_IMAGE_START[n].DATA1);   // number of peaks
			double peaks_end = double(TWEEN_IMAGE_END[n].DATA1);   // number of peaks a finish

			double amp_start = double(TWEEN_IMAGE_START[n].DATA2);   // starting amplitude
			double amp_end = double(TWEEN_IMAGE_END[n].DATA2);   // ending amplitude



			if (direction == -1)
			{
				double temp = peaks_end;
				peaks_end = peaks_start;
				peaks_start = temp;

				temp = amp_end;
				amp_end = amp_start;
				amp_start = temp;

			}

			//Serial.print(F("direction= "));
			//Serial.println(direction);
			//Serial.print(F("peaks_start= "));
			//Serial.println(peaks_start);
			//Serial.print(F("peaks_end= "));
			//Serial.println(peaks_end);
			//Serial.print(F("amp_start= "));
			//Serial.println(amp_start);
			//Serial.print(F("amp_end= "));
			//Serial.println(amp_end);
			//Serial.println("");

			double ratio = (double(increment) / double(total_increments - 1));

			byte peaks_current = byte(abs(ratio * (peaks_end - peaks_start) + peaks_start));
			double amp_current = double(ratio * (amp_end - amp_start) + amp_start);

			//Serial.print(F("increment= "));
			//Serial.println(increment);			
			//Serial.print(F("---->peaks_current= "));
			//Serial.println(peaks_current);
			//Serial.print(F("ratio= "));
			//Serial.println(ratio);
			//Serial.print(F("---->amp_current= "));
			//Serial.println(amp_current);
			//Serial.println("");

			ZIG_ZAG(int(xs), int(ys), int(xe), int(ye), peaks_current, amp_current, hue);
		}

		//////////////////////////

		if ((image_kind_type == 8) || (image_kind_type == 9))  // spikes with and without AXIS 8=with, 9=without
		{
			double peaks_start = double(TWEEN_IMAGE_START[n].DATA1);   // number of peaks
			double peaks_end = double(TWEEN_IMAGE_END[n].DATA1);   // number of peaks at finish

			double amp_start = double(TWEEN_IMAGE_START[n].DATA2);   // starting amplitude
			double amp_end = double(TWEEN_IMAGE_END[n].DATA2);   // ending amplitude

			byte mode_s = 0;  // starting mode...for SPIKES
			byte mode_e = 0;  // ending mode...for SPIKES



			if (image_kind == 0)
			{
				if (image_kind_start == 8)
				{
					mode_s = 1;  // with axis
				}
				else
				{
					mode_s = 0;  // no axis
				}

				if (image_kind_end == 8)
				{
					mode_e = 1;  // with axis
				}
				else
				{
					mode_e = 0;  // no axis
				}

			}
			else  // image kind specified as 8 or 9
			{
				if (image_kind_type == 8)  // with axis
				{
					mode_e = 1;
					mode_s = 1;
				}
			}



			byte mode = mode_s;



			if (direction == -1)
			{
				double temp = peaks_end;
				peaks_end = peaks_start;
				peaks_start = temp;

				temp = amp_end;
				amp_end = amp_start;
				amp_start = temp;


				temp = mode_e;
				mode_e = mode_s;
				mode_s = temp;
				mode = mode_e;

			}

			if (mode_s != mode_e)
			{
				if (increment >= total_increments / 2)  // switch mode at half way point
				{
					mode = mode_e;
				}
			}

			//Serial.print(F("*** TWEEN ***"));
			//Serial.print(F("direction= "));
			//Serial.println(direction);

			//Serial.print(F("peaks_start= "));
			//Serial.println(peaks_start);
			//Serial.print(F("peaks_end= "));
			//Serial.println(peaks_end);

			//Serial.print(F("amp_start= "));
			//Serial.println(amp_start);
			//Serial.print(F("amp_end= "));
			//Serial.println(amp_end);
			//Serial.println("");

			double ratio = (double(increment) / double(total_increments - 1));


			byte peaks_current = byte(abs(ratio * (peaks_end - peaks_start) + peaks_start));
			double amp_current = double(ratio * (amp_end - amp_start) + amp_start);

			//if (image_kind_type == 9)   // for TEST
			{
				//Serial.println("");
				//Serial.println(F("---------------------------------------------------->TWEEN: BEFORE SPIKES "));
				//Serial.print(F("increment= "));
				//Serial.println(increment);	
				//Serial.print(F("total_increments= "));
				//Serial.println(total_increments);
				//Serial.print(F("---->peaks_current= "));
				//Serial.println(peaks_current);
				//Serial.print(F("---->peaks_end= "));
				//Serial.println(peaks_end);
				//Serial.print(F("---->peaks_start= "));
				//Serial.println(peaks_start);
				//Serial.print(F("ratio= "));
				//Serial.println(ratio);
				//Serial.print(F("---->amp_current= "));
				//Serial.println(amp_current);
				//Serial.print(F("xs= "));
				//Serial.println(xs);
				//Serial.print(F("ys= "));
				//Serial.println(ys);
				//Serial.print(F("xe= "));
				//Serial.println(xe);
				//Serial.print(F("ye= "));
				//Serial.println(ye);

				//Serial.print(F("hue= "));
				//Serial.println(hue);
				//Serial.print(F("hue_spikes= "));
				//Serial.println(hue_spikes);
				//Serial.println("");
			}

			if (image_kind_type == 9) { mode = 0; }  // no axis

			SPIKES(int(xs), int(ys), int(xe), int(ye), peaks_current, amp_current, mode, hue, hue_spikes);
		}




		//SHOW_slow();
		//BT_DELAY(600);
		//LINE(xs, ys, xe, ye, 999);  // erase line
	}
}



/////////////////////////////////////////////
// generate a hue that is a transition between start and end
// this tends to generate lots of different colors
byte HUE_TRANSITION(int start_hue, int end_hue, double total_increments, double increment)
{

	double ratio = increment + 1 / total_increments;
	double hue_s = start_hue * (1 - ratio);
	double hue_e = end_hue * ratio;

	double hue = (hue_s + hue_e);

	return byte(hue);

}

/////////////////////////////////////////////
// generate a hue that is a transition between start and end
// a different way than HUE_TRANSITION
// this generates well defined colors between the two colors
byte HUE_TRANSITION2(int start_hue, int end_hue, double total_increments, double increment)
{

	//double ratio = increment + 1 / total_increments;
	//double hue_s = start_hue * (1 - ratio);
	//double hue_e = end_hue * ratio;

	//double delta_hue = hue_e - hue_s;

	double delta_hue = abs(start_hue - end_hue);
	double hue_increment = delta_hue / total_increments;
	int direction = 1;

	if (start_hue > end_hue)
	{
		direction = -1;
	}

	//byte hue = byte(abs(hue_s + hue_increment));  

	byte hue = byte(abs(start_hue + direction * increment * hue_increment));

	if (direction == 1)
	{
		if (hue > end_hue) { hue = end_hue; }
		if (hue < start_hue) { hue = start_hue; }
	}
	else
	{
		if (hue < end_hue) { hue = end_hue; }
		if (hue > start_hue) { hue = start_hue; }
	}


	return hue;

}

/////////////////////////////////////////////////////



/////////////////////////////////////////////////////
//void RECORD_IMAGE(byte image_kind, byte xs, byte ys, byte xe, byte ye, byte hue, byte image_bank, byte image_number ) // recored a specified image_kind and store its parameters in an array indexed by image_number
//{
//// image_kind: 1=line, 2=circle, 3=rectangle, 4=triangle
//// xs,ys = starting coordinates, xe,ye=ending coordintes
//// if CIRCLE: xs=radius, ys=radius: xe,ye=circle center
//// hue=color of image
//// image_bank = 0 or 1 : a group of images are stored in each bank
//// image_number=store image generation parameters in XE,XS,YE,YS arrays indexed by the image_number: must not exceed (MAX_NUMBER_OF_XY_PAIRS-1)
//
//
//	if (image_number >= MAX_NUMBER_IMAGES_to_TWEEN) { image_number = MAX_NUMBER_IMAGES_to_TWEEN -1; }  // guard against array overflow
//
//	if (image_bank == 0)
//	{
//		HUE_IMAGE[image_number] = hue;
//		IMAGE_KIND[image_number] = image_kind; 
//
//		// store XY pairs for use with X_TRANSLATE and Y_TRANSLATE
//		XE[image_number] = xe;
//		XS[image_number] = xs;
//		YE[image_number] = ye;
//		YS[image_number] = ys;
//
//	}
//
//	if (image_bank == 1)
//	{
//		HUE_IMAGE1[image_number] = hue;
//		IMAGE_KIND1[image_number] = image_kind;
//
//		// store XY pairs for use with X_TRANSLATE and Y_TRANSLATE
//		XE1[image_number] = xe;
//		XS1[image_number] = xs;
//		YE1[image_number] = ye;
//		YS1[image_number] = ys;
//
//	}
//
//
//}

//////////////////////////////////////////////////////////////////////////////////////////////
int TOTAL_SHOWS_IN_PRODUCTION()  // return the number of shows in the current production 
{
	int rv;

	switch (G_production)
	{
	case 1:
		rv = NUMBER_OF_PRODUCTION1_SHOWS;
		break;
	case 2:
		rv = NUMBER_OF_PRODUCTION2_SHOWS;
		break;
	case 3:
		rv = NUMBER_OF_PRODUCTION3_SHOWS;
		break;
	case 4:
		rv = NUMBER_OF_PRODUCTION4_SHOWS;
		break;
	case 5:
		rv = NUMBER_OF_PRODUCTION5_SHOWS;
		break;

	default:
		rv = 0;
		break;
	}

	return rv;
}


///////////////////////////////////////////////////////////////////////
//byte DETECT_BASE_COMMUNICATION()  // detect if the BASE is trying to communicate with the HEAD through the A2D port
//{
//#define BASE_COMUNICATION_DETECTION_THRESHOLD 3800  // a2d value
//#define DETECTION_TIME 300 // originally =1000
//#define A2D_AVERAGING 10 // number of a2d readings to average
//	
//	int audio_pin_A2D_value = 0;
//	unsigned long time_HIGH_start = millis();
//	//unsigned long time_HIGH_end = millis();
//
//	for (byte n = 0; n < A2D_AVERAGING; ++n)
//	{
//		audio_pin_A2D_value = audio_pin_A2D_value + analogRead(AUDIO_IN_PIN);
//
//	}
//
//	audio_pin_A2D_value = audio_pin_A2D_value / A2D_AVERAGING;
//
//	Serial.println("");
//	Serial.print(F("^^^^^^^^^^ DETECT_BASE_COMMUNICATION: audio_pin_A2D_value= "));
//	Serial.println(audio_pin_A2D_value);
//	
//		while (audio_pin_A2D_value > BASE_COMUNICATION_DETECTION_THRESHOLD)
//		{
//			audio_pin_A2D_value = 0;
//			
//			for (byte n = 0; n < A2D_AVERAGING; ++n)
//			{
//				audio_pin_A2D_value = audio_pin_A2D_value + analogRead(AUDIO_IN_PIN);
//
//			}
//
//			audio_pin_A2D_value = audio_pin_A2D_value / A2D_AVERAGING;
//
//			//Serial.print(F("in while loop:  DETECT_BASE_COMMUNICATION(): audio_pin_A2D_value ="));
//			//Serial.println(audio_pin_A2D_value );
//
//
//			if ((millis() - time_HIGH_start) > DETECTION_TIME)
//			{
//				break;
//			}
//
//		}
//
//
//		Serial.println("");
//		Serial.print(F("+++ BELOW THRESHOLD value: audio_pin_A2D_value ="));
//		Serial.println(audio_pin_A2D_value);
//		//Serial.print(F("time_HIGH_start ="));
//		//Serial.println(time_HIGH_start);
//		//Serial.print(F("time_HIGH_end ="));
//		//Serial.println(millis());
//		Serial.print(F("delta time ="));
//		Serial.println(millis() - time_HIGH_start);
//		Serial.println("");
//
//		if ((millis() - time_HIGH_start) > DETECTION_TIME )  
//		{
//			Serial.println(F("%%%%%%% DETECT_BASE_COMMUNICATION: returning 1 "));
//			return 1;
//		}
//
//		Serial.println(F("%%%%%%% DETECT_BASE_COMMUNICATION: returning 0 "));
//		return 0; 
//
//}


///////////////////////////////////////////////////////////////////////
byte DETECT_BASE_COMMUNICATION2()  // detect if the BASE is trying to communicate with the HEAD through HEAD_COM
{
	//#define FORCE_HEAD_COM_DURATION 60000  //** For TESTING only: time in ms that FORCE_HEAD_COM=1 will be asserted
	//	unsigned long head_com_duration;

	if (G_FORCE_HEAD_COM == -1) // for testing only: turns on and off head_com
	{
		
		return 0;
	}

	byte head_com = digitalRead(HEAD_COM);
	static byte forced_head_com_HIGH_start_flag = 0; // will be set to 1 at start of head com force... for testing only
	//static byte force_head_com_LOW_start_flag = 0; 

	if (G_FORCE_HEAD_COM == 1)  // for testing only: turns on and off head_com
	{
		head_com = 1;

		if (forced_head_com_HIGH_start_flag == 0)
		{
			forced_head_com_HIGH_start_flag = 1;
			//force_head_com_LOW_start_flag = 0;

			head_com_duration_start_time = millis();

			Serial.println(F(""));
			Serial.println(F("^^^^^^^FORCED HEAD COM ~~~~~~~ "));
			Serial.println(F(""));
		}

		if ((millis() - head_com_duration_start_time) > FORCE_HEAD_COM_HIGH_DURATION)
		{
			//if (force_head_com_LOW_start_flag == 0)
			//{
			//	force_head_com_LOW_start_flag = 1;
			//	head_com_LOW_duration_start_time = millis();
			//}

			head_com = 0;
			forced_head_com_HIGH_start_flag = 0;
		}

	}


	if (head_com == 1)
	{
		MODIFY_GUI4(13); // turn on HEAD COM indicator
		Serial.println(F("%%%%%%% DETECT_BASE_COMMUNICATION: returning 1 "));
		G_force_sound_productions = -1;   // exclude sound production
		//MIC_ON_OFF(0);  // don't allow SOUND productions if HEAD COM is HIGH
		G_Hall_sync = 0;  // for COME_HITHER display
		return 1;
	}
	else  // head_com = 0
	{
		MODIFY_GUI4(14); // turn OFF HEAD COM indicator
		Serial.println(F("%%%%%%% DETECT_BASE_COMMUNICATION: returning 0 "));
		G_force_sound_productions = G_force_sound_productions_original;
		//MIC_ON_OFF(1);  // allow SOUND productions if HEAD COM is LOW and MIC was ON prior to HEAD COM signal
		G_Hall_sync = G_Hall_sync_original;  // return to original value
		return 0;
	}


}

///////////////////////////////////////////////////////////////////////
void DETECT_BASE_COMMUNICATION_and_COME_HITHER()
// detect if the BASE is trying to communicate with the HEAD through the A2D port and if YES then execute COME_HITHER_SHOW() until BASE signal goes LOW
// COME_HITHER_SHOW() starts when DETECT_BASE_COMMUNICATION()==1 
// COME_HITHER_SHOW() ends when next DETECT_BASE_COMMUNICATION()==0 
{
	
	//return;   // TEST ONLY
	
	Serial.println(F("++++++++++++ DETECT_BASE_COMMUNICATION_and_COME_HITHER()  +++++++++++"));
	Serial.print(F("G_Hall_sync="));
	Serial.println(G_Hall_sync);
	Serial.println("");

	//Serial.println(F(""));
	//Serial.print(F("$$$$$$$$$ 77: G_dim= "));
	//Serial.println(G_dim);
	//Serial.println(F(""));

	//	byte base_detect_flag = 0;

	if (G_TEST == 0) // check if BASE is trying to communicate with the HEAD
	{


		// this will cause normal shows to dispaly except those involving HALL_SYNC: this is a COME_HITHER show alternative
		//if (1 == DETECT_BASE_COMMUNICATION2())
		//{
		//	
		//	
		//	if (G_Hall_sync == 1)  // only do one time			
		//	{
		//		G_come_hither_flag = 1;
		//		
		//		G_BT_command = 'L';  // enter SHOW mode, exit CREATE MODE and exit PLAY SAVES mode (by doing a RESET inside BT COMMAND HANDLER COMMAND L
		//		
		//		BLUE_TOOTH_COMMAND_HANDLER(1);

		//	}

		//	G_Hall_sync = 0;  // only for COME_HITHER display
		//	
		//}
		//else
		//{
		//	G_Hall_sync = G_Hall_sync_original;  // return to original value
		//}


		// this will cause normal shows to dispaly except those involving HALL_SYNC: this is a COME_HITHER show alternative
		if (1 == DETECT_BASE_COMMUNICATION2())
		{

			if (G_come_hither_flag == 0)  // only do one time		
			{
				G_come_hither_flag = 1;  // signal come hither mode

				G_BT_command = 'L';  // enter SHOW mode, exit CREATE MODE and exit PLAY SAVES mode (by doing a RESET inside BT COMMAND HANDLER COMMAND L

				BLUE_TOOTH_COMMAND_HANDLER(1);

			}

		}
		else
		{
			G_come_hither_flag = 0;
		}





		///  ****  the below is useful if I want a seperate come hither show   ****


		while (1 == DETECT_BASE_COMMUNICATION2())
		{

			//Serial.println(F("execute COME_HITHER_SHOW()"));

			COME_HITHER_SHOW();
		}

		//FastLED.clear();
	 //   SHOW_slow();

		//// ***  return to normal interrupted show  ****
		//SerialBT.print("*I");  // update production number
		//SerialBT.print(G_production);
		//SerialBT.print("*");

		//
		//UPDATE_PRODUCTION_NAME();



	}

}

///////////////////////////////////////////////////////////////////////
void COME_HITHER_SHOW()  // this show is displayed when (1 == DETECT_BASE_COMMUNICATION())
{
	if ((G_GUI == 3) || (G_GUI == 4))  // update GUI
	{
		SerialBT.print("*I");  // update production number
		SerialBT.print(999);
		SerialBT.print("*");

		// update production name
		SerialBT.print("*N");  // update production name 
		SerialBT.print("COME HITHER");
		SerialBT.print("*");

	}

	FastLED.clear();

	Serial.println(F(""));
	Serial.print(F("$$$$$$$$$ 99: G_dim= "));
	Serial.println(G_dim);
	Serial.println(F(""));

	BEAT_SHOW_PRODUCTION(1);

	//LOAD_BMP(15);
	//SHOW_slow();
	//delay(500);

	//FastLED.clear();
	//LOAD_BMP(19);
	//SHOW_slow();
	//delay(500);
}

/////////////////////////////////////////////////////////////////////////////
void MIC_ON_OFF(byte on)  // 1 will turn on MICROPHOHE, 0 will turn off MICROPHONE if it is ON
{
	if ((on == 0) && (G_MIC_ON_flag == 1))  // turn MIC off
	{
		G_force_sound_productions = -1;  // disallow sound productions
		G_MIC_ON_flag = 0;
		G_sound_detected_flag = 0;
		MODIFY_GUI4(12);  // turn off MUSIC indicator
		MODIFY_GUI4(16);  // turn oFF SOUND DETECT indicator

		if (G_production >= FIRST_SOUND_PRODUCTION)  // currently in a SOUND production but must exit
		{
			//if (G_production == 3) 
			//{
			//	G_production3_counts = NUMBER_OF_TIMES_TO_EXECUTE_PRODUCTION3;  // make sure production 3 terminates
			//}
			//
			//
			//G_force_production_end = 1;

			G_forced_production = 0;
			MODIFY_GUI4(2);  // turn off PRODUCTION LOCK

			G_forced_show = 0;
			MODIFY_GUI4(4);  // turn off SHOW LOCK

			//if (DEFAULT_PRODUCTION < 3)  // not a sound production
			//{
			//	G_next_production = DEFAULT_PRODUCTION;
			//	G_production = G_next_production;  
			//}

			RESET(1);  // full reset except for dimming

			//G_start_next_production_flag = 1;  // insures G_next_production is executed


		}
	}

	if ((on == 1) && (G_MIC_ON_flag == 0))  // turn MIC on if it was on previously
	{

		//if (G_MIC_ON_flag == 1)
		//{
			G_force_sound_productions = G_force_sound_productions_original;
			G_MIC_ON_flag = 1;
		//}


	}



}

////////////////////////////////////////////////////////////////////////////////////////
// generate random enables for non-random beat shows
void GENERATE_RANDOM_BEAT_SHOW_ENABLES(byte number_of_bs_to_display, byte number_of_beat_shows)
{
	byte enable_index = 0;
	byte enable_count = 0;  // keep track of how many BS_enables are enabled


	for (byte n = 0; n < number_of_beat_shows; ++n)
	{
		BS_enables[n] = 0;  // initialize array
	}

	//total_increments = random(4, 8);  // number of increments to complete a BS

	// generate RANDOM BS_enables
	while (enable_count < number_of_bs_to_display)
	{
		enable_index = random(0, number_of_beat_shows);

		if (BS_enables[enable_index] == 0)
		{
			++enable_count;
			BS_enables[enable_index] = 1;  // set as enabled

		}
	}
}


///////////////////////////////////////////////////////////////////////

// generate a show of BEAT_SHOWs used with BEAT detector and COME HITHER show
void BEAT_SHOW_PRODUCTION(byte come_hither_show_flag)
// come_hither_show_flag =1 if this production is used in a COME HITHER show (turns off strobe and sets beat=1)
{
	
	
	
	G_RESET = 0; // added 2/27/24 necessart as BT_DELAY wasn't working

	unsigned long BS_production_run_time = 90000; // 1.5 min in ms=90000 ...how long prior to doing the next PRODUCTION,  15 sec for testing
	int BEATS_DELAY = 200;  // sets how fast display changes occur with COME HITER show, in ms

#define NUMBER_OF_TRACE_BEATS 5  // number of beats in TRACE mode before screen is cleared...TRACE mode leaves previous draws on the screen

	//#define NUMBER_OF_PRODUCTION4_SHOWS  1 // one show devided into different cases

	unsigned long last_BT_check = millis();
	unsigned long BT_check_interval = 300;  // check BT every 300ms

	//G_dim = 252;  // for debug only with hood off

	// note: width of each bin = sample rate/number of samples


	//int number_of_shows = 100;       // number of SHOWs
	int show_num = 0;

	int stringSize = 0;
	int hue = -1;  // white
	//	byte BT_interrupt = 0;

#define NUMBER_OF_BEAT_SHOW_RAND 5  // number of random beat shows
#define NUMBER_OF_BS_TO_DISPLAY 3   // defines how many non-random beat shows will display at once
#define MAXIMUM_BS_TYPE_TIME 10000  // 10 sec. for each type of BEAT SHOW (note: do not exceed MAXIMUM_BS_TYPE_TIME*NUMBER_BS_TYPES > run_time 
#define NUMBER_BS_TYPES 6  // number of BEAT SHOW types: 0=non-random BS, 1=random BS, 2=ROLL hoz BS, 3=ROLL vert BS, 4=TRACE mode, 5=ROLL vert and hoz BS, 
	                       //TO BE ADDED: 6=HUE IMPRINT shows,no TRACE, 7=HUE IMPRINT shows,with TRACE

#define max_no_beat_time  2000 // maximum amount of time between beats before threshold is reset to initial value
//#define STUTTER_BLANK_DISPLAY_FRAMES 4  // number of times display remains blank, 2
#define BLANK_DISPLAY_TIME_INTERVAL 45   //181=1 display, 45=4 displays

	byte enable_stutter_flag = 1; // set to 0 to disable stutter effect
	byte display_cleared_flag = 0;  // set to 1 when display is cleared

	byte stutter_blanks_count = 0;  // holds how long display has been blank
	byte bs_show_type = 0; // is set to 1 to use BEAT_SHOW_RAND to generate BEAT_SHOWs

	byte beat = 0;
	int active_leds = 22 * 22;
	unsigned long time = micros(); // Used to track rate
	float thresh = 150; // initial threshold value
	byte BT_interrupt;
	unsigned long blank_frame_start_time = millis();
	byte initialize_other_flag = 1;  // set to 1 to initialize HOZ and VERT rolls

	//int initial_thresh_value = thresh;
	//unsigned char i;
	//unsigned long i = 0;
	static byte do_once = 0;
	//int beat_values[num_beat_values_index];  // used to keep a running average of the last beat values
	//byte beat_values_index = 0;
	//byte ok2avg_flag = 0; // equals 1 if OK to take beat_values average
	//int beat_avg = thresh;
	//float beat_avg_factor = 2.5; // this devides the beat_avg to generate a new threshold value
	//unsigned long previous_beat_time = millis();
	unsigned long start_time = millis();
	static byte hue_rolling = 0;
	byte rv0 = 1;
	byte rv1 = 1;
	byte rv2 = 1;
	byte rv3 = 1;
	byte rv4 = 1;

	byte total_increments = 8; // number of increments to complete a BEAT_SHOW
	byte current_column = 0;  // keep track of which column is being rolled
	byte roll_count = 0;  // keep track of the number of rolls

	byte check_head_come_once_flag = 1;  // use in detecting head come while this production is playing

	// for show
	unsigned long beat_count = 0; // increments on each detected beat

	//#define NUMBER_OF_BS_COMBINATIONS 10  // this corresponds to the number of different combinations of beat shows... this is not the number of BEAT SHOWS
	//#define MAX_NUMBER_BS_IN_A_COMBINATION 3  // each combination can contain up to NUMBER_BS_IN_A_COMBINATION , all the shows in a combination will execute for a given "show"



	byte initialize_BS_enables_flag = 1;   // set to 1 to initialize BS_enables with data





	///////////////////////////// define hue's  ///////////////////////////////////////////////////
	//int hue1_bs[NUMBER_OF_BEAT_SHOWS];
	//int hue2_bs[NUMBER_OF_BEAT_SHOWS];
	int start_hue = 0;
	int end_hue = 213;
	int hue_code = STARTING_IMAGE_HUE;



	//Serial.println(F("hue1_bs: "));
	//for (int n = 0; n < NUMBER_OF_BEAT_SHOWS; ++n)
	//{
	//	Serial.println(hue1_bs[n]);
	//}
	//Serial.println(F(""));


	//static unsigned long total_beat_time = millis(); // an accumulation of time displaying a particular BS type:  used to set how long a type of BEAT SHOW is displayed
	unsigned long total_beat_time = millis(); // an accumulation of time displaying a particular BS type:  used to set how long a type of BEAT SHOW is displayed
	byte change_non_random_bs_flag = 1; // set to 1 to start a new non-random BS

	//static unsigned long previous_beat_time = millis();  // used to generate beats with COME HITHER show



	if (come_hither_show_flag == 1)
	{
		enable_stutter_flag = 0;  // no stutter for come hither show
		total_increments = 14; // number of increments to complete a BEAT_SHOW
		BS_production_run_time = 2 * BS_production_run_time;

	}

	////////////////////////////////////////////  start WHILE loop  ///////////////////////////////////////////////////////////////////
	while (millis() < start_time + BS_production_run_time)
	{
		// check if head is spinning with (come_hither_show_flag == 1)
		// : note: when HEAD_COM=1 the head is not spinning or soon will not be, if HEAD_COM=0 then head is spinning
		if ((digitalRead(HEAD_COM) == 0) && (G_FORCE_HEAD_COM < 1) && (check_head_come_once_flag == 1) && (come_hither_show_flag == 1))  // HEAD COM no longer asserted and not TESTing HEAD COM
		{
			check_head_come_once_flag = 0;
			BS_production_run_time = BS_production_run_time / 2;
			enable_stutter_flag = 1;  // enable stutter if head is spinning
			total_increments = 8; // number of increments to complete a BEAT_SHOW is less if the head is spinning

		}


		if ((millis() - last_BT_check) > BT_check_interval)
		{
			//check_BT_count = 0; 

			last_BT_check = millis();

			if (G_BT_message_flag == 0)
			{
				G_BT_message_flag = CHECK_BLUE_TOOTH();  // get BT command

			}

			if (G_BT_message_flag == 1)
			{
				TURN_OFF_PLAY_SAVES_MODE();
				BLUE_TOOTH_COMMAND_HANDLER(1);

				return;
			}

		}

		//beat = MUSIC_DETECT(50);
		//beat = SOUND_DETECT(SOUND_DETECT_THRESHOLD, 0);
		//beat = BEAT_DETECT_backup(40, 0);

		if (come_hither_show_flag == 0)  // use BEAT DETECTOR if not a COME HITHER show
		{
			beat = BEAT_DETECT(BEAT_DETECT_THRESHOLD); // 200 was determined by turning off sound and looking at the adjusted peak threshold
		}

		if (come_hither_show_flag == 1)
		{

			BT_DELAY(BEATS_DELAY);

			//delay(BEATS_DELAY);

			beat = 1;
		}

		//static unsigned long beat_detected_time; // record what time a BEAT is detected
		static unsigned long delta_beat_time;  // amount of time between BEATs
		//static unsigned long beat_check_count = 0; // incremented each time the BEAT_DETECTOR is checked


		//++beat_check_count; // incremented each time the BEAT_DETECTOR is checked


		////////////////// create STUTTER display ///////////////////////
		if (initialize_BS_enables_flag == 0)  // make sure a BS has been created
		{
			//if (bs_random_flag < 2)  // don't clear for rolls
			//{
			//	FastLED.clear();
			//}

			if (beat == 0)
			{
				if (enable_stutter_flag == 1)  // stutter display
				{
					if (display_cleared_flag == 0)  // minimize the number of SHOW_var's for faster BEAT updates
					{
						FastLED.clear();

						display_cleared_flag = 1;

						SHOW_var(active_leds);
					}


					//++stutter_blanks_count;

				//old method that isn't BEAT sensitive:	if (stutter_blanks_count == STUTTER_BLANK_DISPLAY_FRAMES)
				//new method: in order to be sensitive to detecting BEATs, blanking time needs to be set by a clock not by adding blank FastLED.show's
					if ((millis() - blank_frame_start_time) > BLANK_DISPLAY_TIME_INTERVAL)  // show display after BLANK_DISPLAY_TIME_INTERVAL display time
					{
						//stutter_blanks_count = 0;
						blank_frame_start_time = millis();

						display_cleared_flag = 0;

						LOAD_BACKGROUND();

						BT_interrupt = SHOW_var(active_leds);

						if (BT_interrupt > 0) { return; }  // leave while loop
					}
				}
			}
		}



		if (beat == 1) // valid beat detect
			//if (abs(beat) > thresh)
		{
			if (come_hither_show_flag == 0)
			{
				++G_sound_detected_flag;
			}

			++beat_count;
			++hue_rolling;
			++hue_rolling;

			//////////////////////////////////////////////////////////////


			////////////////////// CREATE A BEAT_SHOW sequence  //////////////////////////////
			//if ((beat_count % BEATS_PER_SHOW == 0)||(initialize_BS_enables_flag==1))  // determine when to increment a show
			{

				//initialize_BS_enables_flag = 0;  // only need to initalize one time

				if (millis() - total_beat_time > MAXIMUM_BS_TYPE_TIME)  // change bs_show_type 
				{
					total_beat_time = millis();

					++bs_show_type;

					if (come_hither_show_flag == 0)  // added 070924
					{
						MUSIC_DETECT(MUSIC_DETECTION_INTERVAL, MUSIC_DETECTION_COUNT);  // increase sampling
					}

					current_column = 0;  // initialize for rolls 
					roll_count = 0; // initialize
					change_non_random_bs_flag = 1;

					if (bs_show_type >= NUMBER_BS_TYPES)
					{
						bs_show_type = 0;
						initialize_BS_enables_flag = 1;
					}

					// exclude BS=4= TRACE MODE unless HEAD_COM=high
					if ((come_hither_show_flag == 0) && (bs_show_type == 4))
					{
						bs_show_type = 0;
						initialize_BS_enables_flag = 1;
					}

					if (G_GUI == 4)
					{
						SerialBT.print("*!");  // update GUI4 text with bs_show_type
						SerialBT.print(bs_show_type);
						SerialBT.print("*");
					}


					//// setup HUEs  /////////////////////////
					if (bs_show_type == 0)
					{
						for (byte bs = 0; bs < NUMBER_OF_BEAT_SHOWS; ++bs)
						{
							// spread the hue's evenly across the number of BEAT_SHOWs using 2 different HUE spreaders
							hue1_bs[bs] = HUE_TRANSITION2(start_hue, end_hue, NUMBER_OF_BEAT_SHOWS, bs);
							hue2_bs[bs] = HUE_TRANSITION(start_hue, end_hue, NUMBER_OF_BEAT_SHOWS, bs);
						}
					}

					if (bs_show_type > 0)
					{
						for (byte bs = 0; bs < NUMBER_OF_BEAT_SHOW_RAND; ++bs)
						{
							// spread the hue's evenly across the number of BEAT_SHOWs using 2 different HUE spreaders
							hue1_bs[bs] = HUE_TRANSITION2(start_hue, end_hue, NUMBER_OF_BEAT_SHOW_RAND, bs);
							hue2_bs[bs] = HUE_TRANSITION(start_hue, end_hue, NUMBER_OF_BEAT_SHOW_RAND, bs);
						}
					}

					///////////////////////////////////////////


				}




				// change to a new non-random bs_show_type in the middle of bs_show_type=0 
				if ((millis() - total_beat_time > (MAXIMUM_BS_TYPE_TIME / 2)) && (change_non_random_bs_flag == 1) && ((bs_show_type == 0) || (bs_show_type == 4)))
				{
					change_non_random_bs_flag = 0;  // only allow for 1 change
					GENERATE_RANDOM_BEAT_SHOW_ENABLES(NUMBER_OF_BS_TO_DISPLAY, NUMBER_OF_BEAT_SHOWS); // determine which non-random bs will play


					Serial.println(F(""));
					Serial.print(F(">>>>>>>>>>>>>>>>>>>> 2nd NON-RANDOM BS: come_hither_show_flag= "));
					Serial.println(come_hither_show_flag);
					Serial.println(F(""));

				}


				/// set up non-random BS /////////////////////////
				//total_increments = random(4, 8);  // number of increments to complete a BS


				/////////  TEST ONLY ///////////////
				//bs_show_type = 0;  //
				//BS_enables[10] = 1;
				/////////////////////////////////////

				if ((bs_show_type == 0) || (bs_show_type == 4))
				{
					if (initialize_BS_enables_flag == 1)
					{
						initialize_BS_enables_flag = 0;  // only need to initalize one time
						GENERATE_RANDOM_BEAT_SHOW_ENABLES(NUMBER_OF_BS_TO_DISPLAY, NUMBER_OF_BEAT_SHOWS); // determine which non-random bs will play
					}
				}


				// report the BS type
				//if (bs_show_type == 0)
				//{

				//	Serial.println(F(""));
				//	Serial.print(F(">>>>>>>>>> 0: NON-RANDOM BS :come_hither_show_flag= "));
				//	Serial.println(come_hither_show_flag);
				//	Serial.println(F(""));

				//}




				//if (bs_show_type == 1)
				//{

				//	Serial.println(F(""));
				//	Serial.print(F(">>>>>>>>>> 1: RANDOM BS: come_hither_show_flag= "));
				//	Serial.println(come_hither_show_flag);
				//	Serial.println(F(""));
				//}

				//if (bs_show_type == 2)
				//{

				//	Serial.println(F(""));
				//	Serial.print(F(">>>>>>>>>> 2: HOZ ROLL BS: come_hither_show_flag="));
				//	Serial.println(come_hither_show_flag);
				//	Serial.println(F(""));
				//}

				//if (bs_show_type == 3)
				//{

				//	Serial.println(F(""));
				//	Serial.print(F(">>>>>>>>>> 3: VERT ROLL BS: come_hither_show_flag="));
				//	Serial.println(come_hither_show_flag);
				//	Serial.println(F(""));
				//}

				//if (bs_show_type == 4)
				//{

				//	Serial.println(F(""));
				//	Serial.print(F(">>>>>>>>>> 4: TRACE MODE BS: come_hither_show_flag="));
				//	Serial.println(come_hither_show_flag);
				//	Serial.println(F(""));
				//}

				//if (bs_show_type == 5)
				//{

				//	Serial.println(F(""));
				//	Serial.print(F(">>>>>>>>>> 5: VERT & HOZ ROLL: come_hither_show_flag="));
				//	Serial.println(come_hither_show_flag);
				//	Serial.println(F(""));
				//}

				//Serial.println(F(""));
				//Serial.println(F(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PROD4: create BS sequence"));
				//Serial.println(F(""));



				//total_increments = random(4, 8);  // number of increments to complete a BS

			}

			/////////////////////////////////////////////

			if (bs_show_type < 2)  // for 0 or 1 bs_show_type
			{
				FastLED.clear();  // clear image
			}

			//Serial.println(F("PROD4: pos 1"));

			//Serial.println(F(""));
			//Serial.println(F("???????????????????????  >>>>>>>>>>>>>>>>>>BS_enables[enable_index]"));
			//for (int n = 0; n < 14;++n)
			//{
			//	Serial.println(BS_enables[n]);
			//}
			//Serial.println(F(""));


			

			//Serial.println(F(""));
			//Serial.print(F("come_hither_show_flag ="));
			//Serial.println(come_hither_show_flag);
			//Serial.print(F("enable_stutter_flag ="));
			//Serial.println(enable_stutter_flag);
			//Serial.println(F(""));

			/////////***************************************************************//////////////////////////////////////////////////////////////////////////////////////
			//*** note: make sure number_of_shows is updated

			//*** note: the modulus of the BEAT_SHOW (using TWEENS) refers to how often a BEAT changes the TWEEN
			//*** note: for BEAT_SHOW (using TWEENS) the total_increments is the number of BEATs

			//////////// TESTING ONLY  /////////////
			//bs_show_type = 6;
			///////////////////////////////////////


			/////////// non-random mode=0 ///////////  and TRACE mode=4 ///////////// bs_show_type = 6=IMPRINT HUE NO TRACE, 7=IMPRINT HUE WITH TRACE
			//if ((bs_show_type == 0) || (bs_show_type == 4) || (bs_show_type == 6) || (bs_show_type == 7))
			if ((bs_show_type == 0) || (bs_show_type == 4) )
			{
				//BEAT_SHOW_0(beat_count, 1, 1, total_increments, 0, 85, hue2_bs[0], hue_code, 0, 0, 0);
				//BEAT_SHOW_11(beat_count, 3, 1, total_increments, 0, 171, hue2_bs[11], hue_code, 0, 0, 0);

				enable_stutter_flag = 0; // no stutter for these shows

				//if (((bs_show_type == 4) || (bs_show_type == 7)) && ((beat_count % NUMBER_OF_TRACE_BEATS) == 0)) // random BS, clear screen in TRACE mode
				if ((bs_show_type == 4)  && ((beat_count % NUMBER_OF_TRACE_BEATS) == 0)) // random BS, clear screen in TRACE mode
				{
					delay(200); // hold the final TRACE image a bit longer
					FastLED.clear();
				}

				///////////// start new code for IMPRINT HUE  ////////////////////
				//if (bs_show_type == 6)
				//{
				//	printD("BEAT_SHOW_PRODUCTION: bs_show_type ="), 6);
				//	SPACE
				//	
				//	hue_code = 171; // force BLUE in BS



				//}




				//////////////// end new code for IMPRINT HUE //////////////////
				



				//Serial.println(F(""));
				//Serial.print(F("$$$$$$$$$ 0: G_dim= "));
				//Serial.println(G_dim);
				//Serial.println(F(""));

				BEAT_SHOW_ALL(beat_count, total_increments, hue_code);

				//Serial.println(F(""));
				//Serial.print(F("$$$$$$$$$ 1: G_dim= "));
				//Serial.println(G_dim);
				//Serial.println(F(""));

				//BEAT_SHOW_0(beat_count, 1, BS_enables[0], total_increments, 0, hue1_bs[0], hue2_bs[0], hue_code, 0, 0, 0);
				//BEAT_SHOW_1(beat_count, 1, BS_enables[1], total_increments, 0, hue1_bs[1], hue2_bs[1], hue_code, 0, 0, 0);
				//BEAT_SHOW_2(beat_count, 1, BS_enables[2], total_increments, 0, hue1_bs[2], hue2_bs[2], hue_code, 0, 0, 0);
				//BEAT_SHOW_3(beat_count, 1, BS_enables[3], total_increments, 0, hue1_bs[3], hue2_bs[3], hue_code, 0, 0, 0);
				//BEAT_SHOW_4(beat_count, 1, BS_enables[4], total_increments, 0, hue1_bs[4], hue2_bs[4], hue_code, 0, 0, 0);
				//BEAT_SHOW_5(beat_count, 2, BS_enables[5], total_increments, 0, hue1_bs[5], hue2_bs[5], hue_code, 0, 0, 0);
				//BEAT_SHOW_6(beat_count, 2, BS_enables[6], total_increments, 0, hue1_bs[6], hue2_bs[6], hue_code, 0, 0, 0);
				//BEAT_SHOW_7(beat_count, 2, BS_enables[7], total_increments, 0, hue1_bs[7], hue2_bs[7], hue_code, 0, 0, 0);
				//BEAT_SHOW_8(beat_count, 2, BS_enables[8], total_increments, 0, hue1_bs[8], hue2_bs[8], hue_code, 0, 0, 0);
				//BEAT_SHOW_9(beat_count, 2, BS_enables[9], total_increments, 0, hue1_bs[9], hue2_bs[9], hue_code, 0, 0, 0);
				//BEAT_SHOW_10(beat_count, 3, BS_enables[10], total_increments, 0, hue1_bs[10], hue2_bs[10], hue_code, 0, 0, 0);
				//BEAT_SHOW_11(beat_count, 3, BS_enables[11], total_increments, 0, hue1_bs[11], hue2_bs[11], hue_code, 0, 0, 0);
				//BEAT_SHOW_12(beat_count, 3, BS_enables[12], 5, 0, hue1_bs[12], hue2_bs[12], hue_code);
				//BEAT_SHOW_13(beat_count, 3, BS_enables[13], 5, 0, hue1_bs[13], hue2_bs[13], hue_code);
				//BEAT_SHOW_14(beat_count, 1, BS_enables[14], 4, 0, hue1_bs[14], hue2_bs[14], hue_code);
				//BEAT_SHOW_15(beat_count, 1, BS_enables[15], 4, 0, hue1_bs[15], hue2_bs[15], hue_code);
				//BEAT_SHOW_16(beat_count, 1, BS_enables[16], 4, 0, hue1_bs[16], hue2_bs[16], hue_code);   // pre-programed kind
				//BEAT_SHOW_17(beat_count, 3, BS_enables[17], total_increments, 0, hue1_bs[17], hue2_bs[17], hue_code, 0, 0, 0);
				//BEAT_SHOW_18(beat_count, 2, BS_enables[18], total_increments, 0, hue1_bs[18], hue2_bs[18], hue_code);
				//BEAT_SHOW_19(beat_count, 2, BS_enables[19], total_increments, 0, hue1_bs[19], hue2_bs[19], hue_code);
				////////////////////re-used but changed
				//BEAT_SHOW_16(beat_count, 1, BS_enables[20], 4, 9, hue1_bs[20], hue2_bs[18], hue_code);  // forced kind=9
				//BEAT_SHOW_5(beat_count, 3, BS_enables[21], total_increments, 5, hue1_bs[21], hue2_bs[21], hue_code, 0, 0, 0);   // forced kind=5
				//BEAT_SHOW_8(beat_count, 1, BS_enables[22], total_increments, 3, hue1_bs[22], hue2_bs[22], hue_code, 0, 0, 0); // forced kind=3
				//BEAT_SHOW_10(beat_count, 2, BS_enables[23], total_increments, 3, hue1_bs[23], hue2_bs[23], hue_code, 0, 0, 0); // forced kind=3


			}

			// generate RANDOM BEAT_SHOWs
			if (bs_show_type == 1)
			{
				//Serial.println(F(">>>>>>>>>> BS PROD: 1"));

				if (come_hither_show_flag == 0)
				{
					enable_stutter_flag = 1; // enable stutter if HEAD COM is low
				}

				rv0 = BEAT_SHOW_RAND(beat_count, 1, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[0], hue2_bs[0], STARTING_IMAGE_HUE, rv0, 0);
				rv1 = BEAT_SHOW_RAND(beat_count, 1, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[1], hue2_bs[1], STARTING_IMAGE_HUE, rv1, 1);
				rv2 = BEAT_SHOW_RAND(beat_count, 1, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[2], hue2_bs[2], ENDING_IMAGE_HUE, rv2, 2);
				rv3 = BEAT_SHOW_RAND(beat_count, 2, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[3], hue2_bs[3], STARTING_IMAGE_HUE, rv3, 3);


				//rv4 = BEAT_SHOW_RAND(beat_count, 3, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[4], hue2_bs[4], STARTING_IMAGE_HUE, rv4, 4);

			}

			//Serial.println(F(">>>>>>>>>> BS PROD: 2"));

			// for test only ///
			//bs_show_type = 2; // hoz roll
			//enable_stutter_flag = 1; // set to 0 to disable stutter effect

			////////////////////

			//Serial.println(F(""));
			//Serial.print(F("---> bs_show_type= "));
			//Serial.println(bs_show_type);
			//Serial.println(F(""));

			/////////////////// HORIZONTAL and VERTICAL ROLL  ////////////////////////
			if ((bs_show_type == 2) || (bs_show_type == 3) || (bs_show_type == 5))
			{
				byte roll_increment = 2;
				byte total_rolls = 2;  // number of times before a new BS is generated

				if (come_hither_show_flag == 0)
				{
					enable_stutter_flag = 1; // enable stutter if HEAD COM is low
				}

				LOAD_BACKGROUND();

				if (bs_show_type == 2)  // HOZ roll
				{
					ROLL_HOZ(roll_increment);
				}

				if (bs_show_type == 3)  // VERT roll
				{
					ROLL_VERT(roll_increment);
				}

				if (bs_show_type == 5)  // VERT and HOZ roll
				{
					ROLL_VERT(roll_increment);
					ROLL_HOZ(roll_increment);
				}

				current_column = current_column + roll_increment;  // keep track of which column is being rolled

				if (current_column >= NUM_COLUMNS)
				{
					current_column = 0;
					++roll_count;  // keep track of the number of rolls
				}

				if ((roll_count > total_rolls) || (initialize_other_flag == 1)) // generate a new RANDOM BEAT_SHOW imgage
				{

					initialize_other_flag = 0;

					roll_count = 0;

					FastLED.clear();

					//note: by feeding the return value back into the restart_flag I generates a new random image

					//Serial.println(F(""));
					//Serial.println(F(">>>>>>>>>>>>>>>>>>>> BS PROD: 3"));
					//Serial.println(F(""));

					rv0 = BEAT_SHOW_RAND(beat_count, 1, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[0], hue2_bs[0], STARTING_IMAGE_HUE, rv0, 0);
					rv1 = BEAT_SHOW_RAND(beat_count, 1, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[1], hue2_bs[1], STARTING_IMAGE_HUE, rv1, 1);
					rv2 = BEAT_SHOW_RAND(beat_count, 1, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[2], hue2_bs[2], ENDING_IMAGE_HUE, rv2, 2);
					rv3 = BEAT_SHOW_RAND(beat_count, 2, 1, total_increments, RANDOM_IMAGE_KIND, hue1_bs[3], hue2_bs[3], STARTING_IMAGE_HUE, rv3, 3);

				}

			}




			SAVE_BACKGROUND();  // needed for stutter display

			BT_interrupt = SHOW_var(active_leds);

			if (enable_stutter_flag == 1)
			{
				FastLED.clear();  // prevent streaking

				BT_interrupt = SHOW_var(active_leds);
			}



			if (BT_interrupt > 0) { return; }  // leave while loop

			//Serial.println(F(">>>>>>>>>> BS PROD: 4"));

		}
	}

}

/////////////////////////////////////////////////////////////////////////////

// generate a random number from min to max .... INCLUSIVE of both
// note: the original random function EXCLUDES the max value
long randomI(long min, long max)
{
	max = max + 1;

	return random(min, max);
}

///////////////////////////////////////////////
void FLUSH_BT_BUFFER()  // flush the BT buffer note SerialBT.flush() doesn't work
{
	byte incomingByte;

	while (SerialBT.available())  // added 4/17/21
	{
		//SerialBT.flush();  // doesn't work
		incomingByte = SerialBT.read();  // flush BT buffer
	}

}

//////////////////////////////////////////////////////////////////////
void BEAT_SHOW_ALL(unsigned long beat_count, byte total_increments, int hue_code)
{
	BEAT_SHOW_0(beat_count, 1, BS_enables[0], total_increments, 0, hue1_bs[0], hue2_bs[0], hue_code, 0, 0, 0);
	BEAT_SHOW_1(beat_count, 1, BS_enables[1], total_increments, 0, hue1_bs[1], hue2_bs[1], hue_code, 0, 0, 0);
	BEAT_SHOW_2(beat_count, 1, BS_enables[2], total_increments, 0, hue1_bs[2], hue2_bs[2], hue_code, 0, 0, 0);
	BEAT_SHOW_3(beat_count, 1, BS_enables[3], total_increments, 0, hue1_bs[3], hue2_bs[3], hue_code, 0, 0, 0);
	BEAT_SHOW_4(beat_count, 1, BS_enables[4], total_increments, 0, hue1_bs[4], hue2_bs[4], hue_code, 0, 0, 0);
	BEAT_SHOW_5(beat_count, 2, BS_enables[5], total_increments, 0, hue1_bs[5], hue2_bs[5], hue_code, 0, 0, 0);
	BEAT_SHOW_6(beat_count, 2, BS_enables[6], total_increments, 0, hue1_bs[6], hue2_bs[6], hue_code, 0, 0, 0);
	BEAT_SHOW_7(beat_count, 2, BS_enables[7], total_increments, 0, hue1_bs[7], hue2_bs[7], hue_code, 0, 0, 0);
	BEAT_SHOW_8(beat_count, 2, BS_enables[8], total_increments, 0, hue1_bs[8], hue2_bs[8], hue_code, 0, 0, 0);
	BEAT_SHOW_9(beat_count, 2, BS_enables[9], total_increments, 0, hue1_bs[9], hue2_bs[9], hue_code, 0, 0, 0);
	BEAT_SHOW_10(beat_count, 3, BS_enables[10], total_increments, 0, hue1_bs[10], hue2_bs[10], hue_code, 0, 0, 0);
	BEAT_SHOW_11(beat_count, 3, BS_enables[11], total_increments, 0, hue1_bs[11], hue2_bs[11], hue_code, 0, 0, 0);
	BEAT_SHOW_12(beat_count, 3, BS_enables[12], 5, 0, hue1_bs[12], hue2_bs[12], hue_code);
	BEAT_SHOW_13(beat_count, 3, BS_enables[13], 5, 0, hue1_bs[13], hue2_bs[13], hue_code);
	BEAT_SHOW_14(beat_count, 1, BS_enables[14], 4, 0, hue1_bs[14], hue2_bs[14], hue_code);
	BEAT_SHOW_15(beat_count, 1, BS_enables[15], 4, 0, hue1_bs[15], hue2_bs[15], hue_code);
	BEAT_SHOW_16(beat_count, 1, BS_enables[16], 4, 0, hue1_bs[16], hue2_bs[16], hue_code);   // pre-programed kind
	BEAT_SHOW_17(beat_count, 3, BS_enables[17], total_increments, 0, hue1_bs[17], hue2_bs[17], hue_code, 0, 0, 0);
	BEAT_SHOW_18(beat_count, 2, BS_enables[18], total_increments, 0, hue1_bs[18], hue2_bs[18], hue_code);
	BEAT_SHOW_19(beat_count, 2, BS_enables[19], total_increments, 0, hue1_bs[19], hue2_bs[19], hue_code);
	//////////////////re-used but changed
	BEAT_SHOW_16(beat_count, 1, BS_enables[20], 4, 9, hue1_bs[20], hue2_bs[18], hue_code);  // forced kind=9
	BEAT_SHOW_5(beat_count, 3, BS_enables[21], total_increments, 5, hue1_bs[21], hue2_bs[21], hue_code, 0, 0, 0);   // forced kind=5
	BEAT_SHOW_8(beat_count, 1, BS_enables[22], total_increments, 3, hue1_bs[22], hue2_bs[22], hue_code, 0, 0, 0); // forced kind=3
	BEAT_SHOW_10(beat_count, 2, BS_enables[23], total_increments, 3, hue1_bs[23], hue2_bs[23], hue_code, 0, 0, 0); // forced kind=3
}

//////////////////////////////////////////////////////////////////////

//// Template function to print a message followed by a variable and a newline
//template <typename T>
//void printF(const char* message, T var) {
//	Serial.print(message);  // Print the message
//	Serial.println(var);    // Print the variable followed by a newline
//}

///////  custom PRINT function////////////

/*
Example usage:

	printD("good boy ="), variable);
	SPACE  // adds a line after the above


*/

#define printD printF(F

// Template function to print a flash - stored message followed by a variable and a newline
template <typename T>
void printF(const __FlashStringHelper * flashMsg, T var) {
	Serial.print(flashMsg);  // Print the flash-stored message
	Serial.println(var);     // Print the variable followed by a newline
}


///////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////
void IMPRINT(int method)  //imprint the hue onto the current display
// method =1: hue the imprint screen replaces hue of active screen pixels: IHUE
// method =2: XOR the buffer onto  the active screen pixels: IXOR
// method =3: AND the buffer and  the active screen pixels, leave buffer pixles: IAND_BUFFER  (i.e. leave the overlap buffer region with the buffer color)
// method =4: AND the buffer and  the active screen pixels, leave screen pixles: IAND_SCREEN (i.e. leave the overlap buffer region with the screen pixles color)
// method =5  AND the buffer and the active screen pixels, EXCLUDE the AND'd region from the active screen pixels (i.e. cut out the buffer region)

{
	int adr2;

	for (int adr = 0; adr < NUM_LEDS; ++adr)
	{
		if (method == 1)  //imprint buffer onto screen 
		{

			if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))
			{
				if ((leds_buffer1[adr].r > 0) || (leds_buffer1[adr].g > 0) || (leds_buffer1[adr].b > 0))

				{

					leds1[adr] = leds_buffer1[adr];
					leds3[adr] = leds_buffer1[adr];

					//if ((leds_buffer1[adr].r > 0) || (leds_buffer1[adr].g > 0) || leds_buffer1[adr].b > 0)
					//{
					//	print("IMPRINT: STB: adr=", adr);
					//	//print("leds_buffer1[adr].r=", leds_buffer1[adr].r);
					//	//print("leds_buffer1[adr].g=", leds_buffer1[adr].g);
					//	//print("leds_buffer1[adr].b=", leds_buffer1[adr].b);

					//	print("leds1[adr].r=", leds1[adr].r);
					//	print("leds1[adr].g=", leds1[adr].g);
					//	print("leds1[adr].b=", leds1[adr].b);

					//	print("", 0);
					//}

					adr2 = modify_adr(0, 0, adr);

					leds2[adr2] = leds_buffer1[adr];
					leds4[adr2] = leds_buffer1[adr];

				}


			}
		}

	
		////////////////////
		if (method == 2)  // XOR
		{

			if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))
			{
				if ((leds_buffer1[adr].r > 0) || (leds_buffer1[adr].g > 0) || (leds_buffer1[adr].b > 0))

				{

					leds1[adr].r = leds_buffer1[adr].r ^ leds1[adr].r;  // xor
					leds1[adr].g = leds_buffer1[adr].g ^ leds1[adr].g;  // xor
					leds1[adr].b = leds_buffer1[adr].b ^ leds1[adr].b;  // xor

					leds3[adr] = leds1[adr];

					adr2 = modify_adr(0, 0, adr);

					leds2[adr2] = leds1[adr];

					leds4[adr2] = leds2[adr2];

				}


			}
		}

		///////////////////////////////////

		if (method == 3)  //  AND the buffer and  the active screen pixels: leave buffer pixles
		{

			if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))
			{
				// note: the above two if statements effectively do the AND function

				if ((leds_buffer1[adr].r > 0) || (leds_buffer1[adr].g > 0) || (leds_buffer1[adr].b > 0))

				{

					leds1[adr] = leds_buffer1[adr];
					leds3[adr] = leds_buffer1[adr];

					adr2 = modify_adr(0, 0, adr);

					leds2[adr2] = leds_buffer1[adr];
					leds4[adr2] = leds_buffer1[adr];

				}
				else
				{
					leds1[adr] = CRGB( 0,0,0 );
					leds3[adr] = CRGB(0, 0, 0);


					adr2 = modify_adr(0, 0, adr);

					leds2[adr2] = CRGB(0, 0, 0);
					leds4[adr2] = CRGB(0, 0, 0);

				}


			}
		}


		///////////////////////////////////

		if (method == 4)  //  AND the buffer and  the active screen pixels: leave screen pixles
		{

			if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))
			{
				// note: the above two if statements effectively do the AND function

				if ((leds_buffer1[adr].r > 0) || (leds_buffer1[adr].g > 0) || (leds_buffer1[adr].b > 0))

				{
					// do nothing

				}
				else
				{
					leds1[adr] = CRGB(0, 0, 0);
					leds3[adr] = CRGB(0, 0, 0);


					adr2 = modify_adr(0, 0, adr);

					leds2[adr2] = CRGB(0, 0, 0);
					leds4[adr2] = CRGB(0, 0, 0);

				}


			}
		}

		///////////////////////////////////

		if (method == 5)  //  AND the buffer and the active screen pixels, EXCLUDE the AND'd region from the active screen pixels (i.e. cut out the buffer region)
		{

			if ((leds1[adr].r > 0) || (leds1[adr].g > 0) || (leds1[adr].b > 0))
			{
				// note: the above two if statements effectively do the AND function

				if ((leds_buffer1[adr].r > 0) || (leds_buffer1[adr].g > 0) || (leds_buffer1[adr].b > 0))

				{
					leds1[adr] = CRGB(0, 0, 0);
					leds3[adr] = CRGB(0, 0, 0);


					adr2 = modify_adr(0, 0, adr);

					leds2[adr2] = CRGB(0, 0, 0);
					leds4[adr2] = CRGB(0, 0, 0);

				}
				else
				{
					// do nothing

				}


			}
		}

	}



}

///////////////////////////////////////////////////////////////////////
// generate various imprints
//byte IMPRINT_SHOW(byte imp, int hue_start, int hue_end, byte total_cycles, byte reset)
byte IMPRINT_SHOW(byte imp_show, int hue_start, int hue_end, byte total_cycles, byte DELTA_PER_CYCLE, byte NUMBER_OF_INSTANCES, byte DISTANCE_BETWEEN_INSTANCES, byte FILL_DEPTH, float brightness_percentage, byte reset)
// NOTE: the cycle count is incremented each time IMPRINT_SHOW is called
// imp_show = chooses imprint show, return 1 when current imprint show completes
// reset=1 to restart cycle count
// hue_start = starting hue or if <0 use hue imbedded in show and ignore hue_end
// hue_end = ending hue  
// brightness_percentage = percentage increase or decrease over G_dim for IMPRINT only, 200=2x as bright 

//if (imp_show == 1)  // verticle moving HOZ fill lines
//if (imp_show == 2)  // horizontal moving VERT fill lines
//if (imp_show == 3)  // stationary checker board
//if (imp_show == 4)  // vertical HUE gradient
//if (imp_show == 5)  // horizontal HUE gradient
//if (imp_show== 6)  //MIDDLE vertical HUE gradient
//if (imp_show == 7)  // UP and down trianle , hue varies with cycle : DON-->>need to add the changine HUE with cycle


{
	//SAVE_TO_BUFFER(2); // save current display

	FastLED.clear();
	
	static byte cycle = 0;   // keep track of imprint cycle
	int hue = 0;  //current hue
	//int hue_direction = 0; // 1 if: hue_start < hue_end,  -1 if: hue_start > hue_end,  
	float hue_delta = 0; //change in hue per cycle

#define HUE_INCREMENT 255/total_cycles

	printD("EXECUTING IMPRINT_SHOW: cycle="), cycle);
	printD("  imprint show ="), imp_show);
	SPACE



		if (reset == 1)
		{
			cycle = 0;
		}



	hue = HUE_TRANSITION2(hue_start, hue_end, total_cycles, cycle);



	///////////////////////// SHOW 1  ///////////////////////////////////
	if (imp_show == 1)  // verticle moving HOZ fill lines
	{
		//#define TOT_CYCLES_2 20 // number of HOZ cycles
		//#define DELTA_PER_CYCLE 3  // how far HOZ fills move each cycle
		//#define NUMBER_OF_INSTANCES 4
		//#define DISTANCE_BETWEEN_INSTANCES 4 // spacing between instances
		//#define FILL_DEPTH 2 // number of lines filled, 0=1 line
		//#define HUE_INCREMENT 255/total_cycles

				//static int hue2 = 0 ;
		byte y = 0;

		//hue2 = hue2 + HUE_INCREMENT;

		//printD("hue="), hue);
		//SPACE

			//FastLED.clear();


		// use the same starting image each call
		for (byte instance = 0; instance < NUMBER_OF_INSTANCES; ++instance)
		{
			//print("doing FILL: y=", y);
			//print("    instance=", instance);
			//SPACE

			y = instance * DISTANCE_BETWEEN_INSTANCES;

			FILL_VERT(0, y, NUM_COLUMNS - 1, y, 1, FILL_DEPTH, hue);



			if (y > NUM_ROWS - 1)
			{
				y = NUM_ROWS - 1;
			}
		}


		for (byte roll = 0; roll < cycle;++roll)
		{
			ROLL_VERT(DELTA_PER_CYCLE);
		}


	}

	///////////////////////// SHOW 2  ///////////////////////////////////
	if (imp_show == 2)  // horizontal moving VERT fill lines
	{
		//#define TOT_CYCLES_2 20 // number of HOZ cycles
//#define DELTA_PER_CYCLE 3  // how far HOZ fills move each cycle
//#define NUMBER_OF_INSTANCES 6
//#define DISTANCE_BETWEEN_INSTANCES 4 // spacing between instances
//#define FILL_DEPTH 0 // number of lines filled, 0=1 line
//#define HUE_INCREMENT 255/total_cycles

		//static int hue2 = 0 ;
		byte x = 0;

		//hue2 = hue2 + HUE_INCREMENT;

		//printD("hue="), hue);
		//SPACE

			//FastLED.clear();


		// use the same starting image each call
		for (byte instance = 0; instance < NUMBER_OF_INSTANCES; ++instance)
		{
			//print("doing FILL: y=", y);
			//print("    instance=", instance);
			//SPACE

			x = instance * DISTANCE_BETWEEN_INSTANCES;

			FILL_HOZ(x, 0, x, NUM_ROWS - 1, 1, FILL_DEPTH, hue);



			if (x > NUM_COLUMNS - 1)
			{
				x = NUM_COLUMNS - 1;
			}
		}


		for (byte roll = 0; roll < cycle;++roll)
		{
			ROLL_HOZ(DELTA_PER_CYCLE);
		}


	}


	///////////////////////// SHOW 3  ///////////////////////////////////
	if (imp_show == 3)  // stationary checker board
	{
		// First generate HOZ bars using the method in  SHOW3. Save to buffer 1 then clear screen.
		// Then generate VERT bars using the method in SHOW4. IMPRINT this (using AND) image with buffer 1 to generate the final imprint.

//#define TOT_CYCLES_2 20 // number of HOZ cycles
//#define DELTA_PER_CYCLE 3  // how far HOZ fills move each cycle
//#define NUMBER_OF_INSTANCES 6
//#define DISTANCE_BETWEEN_INSTANCES 4 // spacing between instances
//#define FILL_DEPTH 0 // number of lines filled, 0=1 line
//#define HUE_INCREMENT 255/total_cycles

		//static int hue2 = 0 ;
		byte x = 0;
		byte y = 0;

		//hue2 = hue2 + HUE_INCREMENT;

		//printD("hue="), hue);
		//SPACE

			//FastLED.clear();

		// GENERATE HOZ lines
		// use the same starting image each call
		for (byte instance = 0; instance < NUMBER_OF_INSTANCES; ++instance)
		{
			//print("doing FILL: y=", y);
			//print("    instance=", instance);
			//SPACE

			x = instance * DISTANCE_BETWEEN_INSTANCES;

			FILL_HOZ(x, 0, x, NUM_ROWS - 1, 1, FILL_DEPTH, hue);



			if (x > NUM_COLUMNS - 1)
			{
				x = NUM_COLUMNS - 1;
			}
		}

		SAVE_TO_BUFFER(1);
		FastLED.clear();

		// GENERATE VERT lines
	// use the same starting image each call
		for (byte instance = 0; instance < NUMBER_OF_INSTANCES; ++instance)
		{
			//print("doing FILL: y=", y);
			//print("    instance=", instance);
			//SPACE

			y = instance * DISTANCE_BETWEEN_INSTANCES;

			FILL_VERT(0, y, NUM_COLUMNS - 1, y, 1, FILL_DEPTH, hue);



			if (y > NUM_ROWS - 1)
			{
				y = NUM_ROWS - 1;
			}
		}


		IMPRINT(4);


		//for (byte roll = 0; roll < cycle;++roll)
		//{
		//	ROLL_HOZ(DELTA_PER_CYCLE);
		//}


	}

	///////////////////////// SHOW 4  ///////////////////////////////////
	if (imp_show == 4)  // vertical HUE gradient
	{
		for (byte y = 0; y < NUM_ROWS; ++y)
		{

			//hue_delta = (hue_end - hue_start) / (NUM_ROWS - 1);
			//hue = hue_start + int(y * hue_delta);

			//if (hue_delta >= 0)
			//{
			//	if (hue > hue_end) { hue = hue_end; }
			//	if (hue < hue_start) { hue = hue_start; }
			//}
			//else
			//{
			//	if (hue > hue_start) { hue = hue_start; }
			//	if (hue < hue_end) { hue = hue_end; }

			//}

			hue = HUE_TRANSITION2(hue_start, hue_end, NUM_ROWS, y);

			LINE(0, y, NUM_COLUMNS, y, hue);

			//print("y=", y);
			//print("hue2=", hue);
			//print("hue_delta2=", hue_delta);
			//print("y*hue_delta2=", y * hue_delta);
			//SPACE


		}

		for (byte roll = 0; roll < cycle;++roll)
		{
			ROLL_VERT(DELTA_PER_CYCLE);
		}


	}

	///////////////////////// SHOW 5  ///////////////////////////////////
	if (imp_show == 5)  // horizontal HUE gradient
	{
		for (byte x = 0; x < NUM_COLUMNS; ++x)
		{

			//hue_delta = (hue_end - hue_start) / (NUM_ROWS - 1);
			//hue = hue_start + int(x * hue_delta);


			//if (hue_delta >= 0)
			//{
			//	if (hue > hue_end) { hue = hue_end; }
			//	if (hue < hue_start) { hue = hue_start; }
			//}
			//else
			//{
			//	if (hue > hue_start) { hue = hue_start; }
			//	if (hue < hue_end) { hue = hue_end; }

			//}

			hue = HUE_TRANSITION2(hue_start, hue_end, NUM_COLUMNS, x);

			LINE(x, 0, x, NUM_ROWS, hue);

			//print("x=", x);
			//print("hue2=", hue);
			//print("hue_delta2=", hue_delta);
			//print("x*hue_delta2=", x * hue_delta);
			//SPACE


		}

		for (byte roll = 0; roll < cycle;++roll)
		{
			ROLL_HOZ(DELTA_PER_CYCLE);
		}


	}

	///////////////////////// SHOW 6  ///////////////////////////////////
	if (imp_show == 6)  //MIDDLE vertical HUE gradient
	{
		byte y_down = (NUM_ROWS / 2) - 1;
		byte yhs = NUM_ROWS / 2;  // y coordinate for symetery below this line, 11, used in copy

		for (byte y = NUM_ROWS / 2; y < NUM_ROWS; ++y)
		{

			//hue_delta = (hue_end - hue_start) / (NUM_ROWS - 1);
			//hue = hue_start + int(2*y * hue_delta);  // 2* because filling half the space

			//if (hue_delta >= 0)
			//{
			//	if (hue > hue_end) { hue = hue_end; }
			//	if (hue < hue_start) { hue = hue_start; }
			//}
			//else
			//{
			//	if (hue > hue_start) { hue = hue_start; }
			//	if (hue < hue_end) { hue = hue_end; }

			//}

			hue = HUE_TRANSITION2(hue_start, hue_end, NUM_ROWS / 2, y - (NUM_ROWS / 2));

			///////////  TEST ONLY  /////////////////////
			//LINE(0, 11, NUM_COLUMNS, yhs, hue);
			//LINE(0, 10, NUM_COLUMNS, yhs-1, hue);

			/////////////////////////////////////////

			LINE(0, y, NUM_COLUMNS, y, hue);
			LINE(0, y_down, NUM_COLUMNS, y_down, hue);



			//print("****IMPRINT_SHOW 7", 0);
			//print("y=", y);
			//print("y_down=", y_down);
			//print("hue=", hue);

			//SPACE

				if (y_down > 0)
				{
					y_down = y_down - 1;
				}
				else
				{
					y_down = 0;
				}


		}

		for (byte roll = 0; roll < cycle;++roll)
		{
			ROLL_VERT(DELTA_PER_CYCLE);  // roll up
		}


		int adr;
		int adr_copy;
		int yc = yhs - 1;  // y address of copy for lower half

		// now copy top half into bottom half
		for (byte yv = yhs; yv < NUM_ROWS; ++yv)
		{
			for (byte xc = 0; xc < NUM_COLUMNS; ++xc)
			{
				adr_copy = GET_XY_ADR(xc, yc);
				adr = GET_XY_ADR(xc, yv);
				leds1[adr_copy] = leds1[adr];
			}

			yc = abs(yc - 1);

		}


	}

	///////////////////////// SHOW 7  ///////////////////////////////////
	if (imp_show == 7)  // UP and down trianle , hue varies with cycle : DON-->>need to add the changine HUE with cycle
	{
		byte y_down = (NUM_ROWS / 2) - 1;
		byte yhs = NUM_ROWS / 2;  // y coordinate for symetery below this line, 11, used in copy

		for (byte y = NUM_ROWS / 2; y < NUM_ROWS; ++y)
		{


			///////////  TEST ONLY  /////////////////////
			//LINE(0, y, NUM_COLUMNS, 21, hue);
			//LINE(0, y_down, NUM_COLUMNS, 0, hue);

			/////////////////////////////////////////

			LINE(0, y, NUM_COLUMNS - 1, NUM_ROWS - 1, hue);




			//print("****IMPRINT_SHOW 7", 0);
			//print("y=", y);
			//print("y_down=", y_down);
			//print("hue=", hue);

			//SPACE

				if (y_down > 0)
				{
					y_down = y_down - 1;
				}
				else
				{
					y_down = 0;
				}


		}


		int adr;
		int adr_copy;
		int yc = yhs - 1;  // y address of copy for lower half

		// now copy top half into bottom half
		for (byte yv = yhs; yv < NUM_ROWS; ++yv)
		{
			for (byte xc = 0; xc < NUM_COLUMNS; ++xc)
			{
				adr_copy = GET_XY_ADR(xc, yc);
				adr = GET_XY_ADR(xc, yv);
				leds1[adr_copy] = leds1[adr];
			}

			yc = abs(yc - 1);

		}


	}

	///////////////////////// SHOW 8  ///////////////////////////////////
	if (imp_show == 8)  // center circle 
	{
		for (byte r = 1; r <= cycle + 1; ++r)
		{

			FILL_HOZ(21, 0, 21, 21, -1, 4, hue);

			CIRCLE(r, 0, 11, hue);

			//SPACE
			//print("imprint_show =", 8);
			//print("r=", r);
			//print("hue=", hue);
			//SPACE


		}



	}


	//**************************************************************************************************************
	
	//////////// ADJUST brightness of IMPRINT //////////////////////////////////////////////////////////
	
	// NOTE: brightness_percentage = percentage how much brighter or dimmer the IMPRINT is vs. the normal display = G_dim

	float dimming = 255 - ((255-float(G_dim)) * (brightness_percentage/100 ));

	//printD("IMPRINT_SHOW: dimming="), dimming);

	if (dimming < 0) { dimming = 0; }
	if (dimming > 255) { dimming = 255; }

	//printD("IMPRINT_SHOW: dimming="), dimming);
	//printD("IMPRINT_SHOW: G_dim="), G_dim);
	//printD("IMPRINT_SHOW: brightness_percentage="), brightness_percentage);
	//SPACE

	DIM_VAR_LEDS(byte(dimming), NUM_LEDS);

	///////////////////////////////////////////////////////////////////////////////////////

	SAVE_TO_BUFFER(1);  // HUE IMPRINT STORED here ready for IMPRINT function

	FastLED.clear();
	//LOAD_FROM_BUFFER(2);  // restore original display


	++cycle;

	if (cycle >= total_cycles + 1) // add 1 to accomodate full range of hue
	{
		cycle = 0;
		return 1;
	}


	return 0;


}

/////////////////////////////////////////////////////////////////////////
// fill from given line down to bottom or up (as set by direction)
void FILL_VERT(byte xs, byte ys, byte xe, byte ye, int direction, byte depth, int hue)
{
	// if direction>0 then fill up,  if direction<0 thrn fill down
	// fill starts at specified line and fills in the given direction at the specified depth

	int yss = ys;  // dy is added or subtracted
	int yee = ye;



	for (byte dy = 0; dy <= depth; ++dy)
	{

		yss = ys + direction * dy;
		yee = ye + direction * dy;

		if (yss > NUM_ROWS - 1)
		{
			yss = NUM_ROWS - 1;
		}

		if (yss < 0)
		{
			yss = 0;
		}

		if (yee < 0)
		{
			yee = 0;
		}


		LINE(xs, yss, xe, yee, hue);

	}


}

/////////////////////////////////////////////////////////////////////////
// fill from given line horizontally left and right
void FILL_HOZ(byte xs, byte ys, byte xe, byte ye, int direction, byte depth, int hue)
{
	// if direction>0 then fill right,  if direction<0 thrn fill left
	// fill starts at specified line and fills in the given direction at the specified depth


	int xss = xs;  // dx is added or subtracted
	int xee = xe;


	for (byte dx = 0; dx <= depth; ++dx)
	{

		xss = xs + direction * dx;
		xee = xe + direction * dx;

		if (xss > NUM_COLUMNS - 1)
		{
			xss = NUM_COLUMNS - 1;
		}

		if (xss < 0)
		{
			xss = 0;
		}

		if (xee < 0)
		{
			xee = 0;
		}


		LINE(xss, ys, xee, ye, hue);

	}


}

////////////////////////////////////////////////////////////////////////////////////
void SAVE_TO_BUFFER(byte buf)  // save leds1 to specified buffer, used in IMPRINT
{
	for (int adr = 0; adr < NUM_LEDS; ++adr)
	{
		if (buf == 1)
		{
			leds_buffer1[adr] = leds1[adr];

			//if ((leds_buffer1[adr].r>0) || (leds_buffer1[adr].g>0) || leds_buffer1[adr].b>0)
			//{
			//	print("STB: adr=", adr);
			//	print("leds_buffer1[adr].r=", leds_buffer1[adr].r);
			//	print("leds_buffer1[adr].g=", leds_buffer1[adr].g);
			//	print("leds_buffer1[adr].b=", leds_buffer1[adr].b);
			//}
		}

		if (buf == 2)
		{
			leds_buffer2[adr] = leds1[adr];
		}
	}

}

////////////////////////////////////////////////////////////////////////////////////
void LOAD_FROM_BUFFER(byte buf)  // load leds with specified buffer, used in IMPRINT
{
	int adr2;

	for (int adr = 0; adr < NUM_LEDS; ++adr)
	{
		if (buf == 1)
		{
			leds1[adr] = leds_buffer1[adr] ;
			leds3[adr] = leds_buffer1[adr];

			adr2 = modify_adr(0, 0, adr);

			leds2[adr2] = leds_buffer1[adr];
			leds4[adr2] = leds_buffer1[adr];

			//if ((leds_buffer1[adr].r>0) || (leds_buffer1[adr].g>0) || leds_buffer1[adr].b>0)
			//{
			//	print("STB: adr=", adr);
			//	print("leds_buffer1[adr].r=", leds_buffer1[adr].r);
			//	print("leds_buffer1[adr].g=", leds_buffer1[adr].g);
			//	print("leds_buffer1[adr].b=", leds_buffer1[adr].b);
			//}
		}

		if (buf == 2)
		{
			leds1[adr] = leds_buffer2[adr];
			leds3[adr] = leds_buffer2[adr];

			adr2 = modify_adr(0, 0, adr);

			leds2[adr2] = leds_buffer2[adr];
			leds4[adr2] = leds_buffer2[adr];
		}
	}

}


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get values for the VALUES[] array from the Serial Monitor: ex. v3 55  will set VALUES[3]=55
void GET_VALUES() {
	if (Serial.available() > 0) { // Check if data is available to read
		String input = Serial.readStringUntil('\n'); // Read the incoming string until newline
		input.trim(); // Remove any leading/trailing whitespace

		// Check if input follows the format v<index> <value>
		if (input.charAt(0) == 'v' && input.length() > 2) {
			int spaceIndex = input.indexOf(' '); // Find the index of the space character
			if (spaceIndex > 1) {
				int arrayIndex = input.substring(1, spaceIndex).toInt(); // Get the index part of the input
				int newValue = input.substring(spaceIndex + 1).toInt(); // Get the value part of the input

				// Validate the array index and the new value
				if (arrayIndex >= 0 && arrayIndex < SIZE_of_VALUES_array && (newValue != 0 || input.substring(spaceIndex + 1) == "0")) {
					VALUES[arrayIndex] = newValue;
					Serial.print("VALUES[");
					Serial.print(arrayIndex);
					Serial.print("] updated to: ");
					Serial.println(newValue);
				}
				else {
					Serial.println("Invalid input. Please enter a valid index (0-9) and a valid integer value.");
				}
			}
			else {
				Serial.println("Invalid format. Please use the format: v<index> <value>");
			}
		}
		else {
			Serial.println("Invalid format. Please use the format: v<index> <value>");
		}
		Serial.println("Enter a new value in the format: v<index> <value>");
	}

}

/////////////////////////////////////////////////////////////////////////
 void REPORT_VALUES()  // print the values of the VALUES[] array
 {
	 SPACE
	 printD("++ UPDATING IMPRINT  +++"), "");
	 SPACE

	 for (byte n = 0; n < SIZE_of_VALUES_array; ++n)
	 {
		 
		 Serial.print(F("VALUE["));
		 Serial.print(n);
		 Serial.print(F("]= "));
		 Serial.println(VALUES[n]);

	 }

	 SPACE

		 delay(3000);  // to allow time to view report
	 
 }

 //////////////////////////////////////////////////////////////////////

 void REFRESH_GUI4()
 {
	 G_GUI = 4;

	 GUI4();

	 ////////////// test only  ////////////
	 //SPACE
	 //printD("#################   ----->  G_MIC_ON_flag= "), G_MIC_ON_flag);
	 //SPACE
	 //delay(2000);
	 /////////////////////////////////////////

	 //if (G_MIC_ON_flag == 0)  // MIC off 
	 //{
	 //	MODIFY_GUI4(9);  // turn off MIC_ENABLE switch
	 //}
	 //else
	 //{
	 //	MODIFY_GUI4(8);  // turn on MIC_ENABLE switch
	 //}

	 if (G_music_only_switch == 1)  // MUSIC ONLY MODE ON, note: default is OFF 
	 {
		 
		 MODIFY_GUI4(20);  // turn on MUSIC ONLY MODE switch
	 }
	 else
	 {
		 MODIFY_GUI4(17); // turn on/off MUSIC DETECT indicator
	 }



	 if (G_MIC_ON_flag == 0)  // MIC off , note: default is ON
	 {
		 MODIFY_GUI4(9);  // turn off MIC_ENABLE switch
		 MODIFY_GUI4(17); // turn on/off MUSIC DETECT indicator
	 }


	 //MODIFY_GUI4(17); // turn on/off MUSIC DETECT indicator


	 //MIC_ON_OFF(1);  // turn MIC on

	 G_MIC_gain = DEFAULT_MIC_gain;

	 MODIFY_GUI4(10);  // display MIC gain and slider position

	 UPDATE_PRODUCTION_NAME();

	 //	MODIFY_GUI4(2);  // production LOCK switch is OFF
	 //	MODIFY_GUI4(4);  // SHOW LOCK switch is OFF

	 //if (G_GUI == 4)

	 SerialBT.print("*I");  // update GUI4 text
	 SerialBT.print(G_production);
	 SerialBT.print("*");

	 SerialBT.print("*!");  // update GUI4 text
	 SerialBT.print(G_show_num);
	 SerialBT.print("*");

	 SerialBT.print("*M");  // update GUI4 text for FINAL SHOW
	 SerialBT.print(G_number_of_shows);
	 SerialBT.print("*");




	 if (G_executing_CREATE_mode == 0)
	 {
		 SerialBT.print("*Loff*");  // update GUI4 text

		 //SerialBT.print("*L");  // update GUI4 text
		 //SerialBT.print("off");
		 //SerialBT.print("*");
	 }
	 else
	 {
		 SerialBT.print("*Lon*");  // update GUI4 text

		 //SerialBT.print("*L");  // update GUI4 text
		 //SerialBT.print("on");
		 //SerialBT.print("*");
	 }

	 if (G_forced_production > 0)  // production LOCK switch is ON
	 {
		 MODIFY_GUI4(1);
	 }


	 if (G_forced_show > 0)  // SHOW LOCK switch is ON
	 {
		 MODIFY_GUI4(3);
	 }

	 ////////




 // update GUI4 with CREATE mode setting
	// if (G_executing_CREATE_mode == 0)
	if (G_CREATE_mode == 0)
	 {
		 SerialBT.print("*Loff*");  // update GUI4 text


		 //SerialBT.print("*L");  // update GUI4 text
		 //SerialBT.print("off");
		 //SerialBT.print("*");
	 }
	 else
	 {
		 SerialBT.print("*Lon*");  // update GUI4 text

		 //SerialBT.print("*L");  // update GUI4 text
		 //SerialBT.print("on");
		 //SerialBT.print("*");
	 }


 }


////////////////////////////  LAST FUNCTION  /////////////////////////
void Z_LAST()
{

}


//////////////////////  BUGS /////////////////////////////////
/*
// 12/17/21  :  FUN animation must complete before another starts in order to preserve the image.

1/2/22: 1:  RING IMAGE selection above 5 produces eratic images (should be stored images)
1/2/22: 2: all positions of the 8way CYCLE should produce animated images when held: done
1/2/22: 3:  depth of text went to 3 --> make sure when TEXT is displayed that correct FAST LED depth is correct: fixed by RESET
		a.  note this occured after bug 1
1/4/22 4. can't repeart stored ring image unless proceeded by RANDOM RING




/////////////////////////////////////////////////////////////////
*/

/////////////////////////////////////////////////////////////////////
//void SPARKLE(int dimming, int sparkle, int duration, int number_of_LEDS)  // make any image sparkle
//// NOTE: This function works perfectly it just doesn't produce anything very pretty
//																		  // dimming = minimum brightness level,  larger number = more dimming
////sparkle = larger number is less sparkle: 2 = maximum sparkle (i.e. 50% of LEDs will sparkle)
//// duration = how long LED is dimmed in ms
//// number of LEDS = number to be sparkled starting with the outside LEDs first
//{
//	if (sparkle >= 2)
//	{
//		//for (int n = 0; n < NUM_LEDS; ++n)
//		//{
//		//	leds_saved[0][n] = 0; // clear array
//		//}
//		
//		
//		for (int adr = 0; adr < number_of_LEDS; ++adr)
//		{
//			if (leds1[adr])  // test if lit
//			{
//				//		leds1[adr] = CHSV(hue, 255, 255);
//
//						// decide if LED is to change brighntess
//
//				int rn = random(0, sparkle);
//
//				if (rn == 1)  // I arbitrairly choose 1 
//				{
//
//					//leds_saved[0][adr] = 1;   // flag that brightness was changed
//
//					leds1[adr].maximizeBrightness();
//					leds1[adr].fadeLightBy(dimming); // Dim a color 
//
//					leds3[adr].maximizeBrightness();
//					leds3[adr].fadeLightBy(dimming); // Dim a color 
//
//					int adr_mod = modify_adr(0, 0, adr);
//
//					leds2[adr_mod].maximizeBrightness();
//					leds2[adr_mod].fadeLightBy(dimming); // Dim a color 
//
//					leds4[adr_mod].maximizeBrightness();
//					leds4[adr_mod].fadeLightBy(dimming); // Dim a color 
//
//				}
//
//			}
//		}
//
//
//		// I need to bypass SHOW_var as it contains a dimming function
//		if (G_active != number_of_LEDS) // if current set to SLOW LEDs
//		{
//			SET_VAR(number_of_LEDS);  // set to display to a variable number of LEDs
//		}
//
//
//		FastLED.show(); // I need to bypass SHOW_var as it contains a dimming function
//		delay(duration);
//
//		for (int adr = 0; adr < number_of_LEDS; ++adr)   // restore previous brightness
//		{
//			if (leds1[adr])  // test if lit
//			{
//			
//
//					leds1[adr].maximizeBrightness();
//					leds3[adr].maximizeBrightness();
//					
//					leds1[adr].fadeLightBy(G_dim);
//					leds3[adr].fadeLightBy(G_dim);
//					
//
//					int adr_mod = modify_adr(0, 0, adr);
//
//					leds2[adr_mod].maximizeBrightness();	
//					leds4[adr_mod].maximizeBrightness();
//					
//					leds3[adr_mod].fadeLightBy(G_dim);
//					leds4[adr_mod].fadeLightBy(G_dim);
//
//			}
//		}
//	}
//
//}

//******************************************************************************************
//void FLIP(int flip)  // flip the displays, flip=1 to flip, flip=0 to set back to normal 
//{
//	if (flip == 1)
//	{
//		if (G_flipped == 0)  // keep track if image is flipped or nor
//		{
//			G_flipped = 1;
//		}
//		else
//		{
//			G_flipped = 0;
//		}
//
//		if (G_upside_down == 1)
//		{
//			G_upside_down = 0;
//		}
//		else
//		{
//			G_upside_down = 1;
//		}
//
//	}
//	else   // flip=0
//	{
//		if (G_flipped == 1)  // if flipped return to normal
//		{
//			if (G_upside_down == 1)
//			{
//				G_upside_down = 0;
//			}
//			else
//			{
//				G_upside_down = 1;
//			}
//			G_flipped = 0;  // no longer flipped
//		}
//	}
//
//}

//******************************************************************************************





//**********************************GOOD INFO**************************************

//    %%%%%%%%%%%%%%%%%%%%%%%%%%%   at 330 RPM   %%%%%%%%%%%%%%%%%%%%%%%%%
//active_columns = 1
//G_max_flashes = 72
//blanks = 10
//
//active_columns = 2
//G_max_flashes = 74
//blanks = 11
//
//active_columns = 3
//G_max_flashes = 72
//blanks = 10
//
//active_columns = 4
//G_max_flashes = 60
//blanks = 9
//
//active_columns = 5
//G_max_flashes = 48
//blanks = 7
//
//active_columns = 6
//G_max_flashes = 40
//blanks = 6
//
//active_columns = 7
//G_max_flashes = 36
//blanks = 5
//
//active_columns = 8
//G_max_flashes = 30
//blanks = 4
//
//active_columns = 9
//G_max_flashes = 28
//blanks = 4
//
//active_columns = 10
//G_max_flashes = 24
//blanks = 3
//
//active_columns = 11
//G_max_flashes = 22
//blanks = 3
//
//active_columns = 12
//G_max_flashes = 20
//blanks = 3
//
//active_columns = 13
//G_max_flashes = 20
//blanks = 3
//
//active_columns = 14
//G_max_flashes = 18
//blanks = 2
//
//active_columns = 15
//G_max_flashes = 16
//blanks = 2
//
//active_columns = 16
//G_max_flashes = 16
//blanks = 2
//
//active_columns = 17
//G_max_flashes = 14
//blanks = 2
//
//active_columns = 18
//G_max_flashes = 14
//blanks = 2
//
//active_columns = 19
//G_max_flashes = 14
//blanks = 2
//
//active_columns = 20
//G_max_flashes = 12
//blanks = 1
//
//active_columns = 21
//G_max_flashes = 12
//blanks = 1
//



